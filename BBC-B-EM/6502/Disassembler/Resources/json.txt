[
{"address": "0xC4C0", "comment": "get number of items in VDU queue"},
{"address": "0xC4C3", "comment": "if parameters needed then C512"},
{"address": "0xC4C5", "comment": "else check status byte"},
{"address": "0xC4C7", "comment": "if cursor editing enabled two cursors exist"},
{"address": "0xC4C9", "comment": "swap values"},
{"address": "0xC4CC", "comment": "then set up write cursor"},
{"address": "0xC4CF", "comment": "if display disabled C4D8"},
{"address": "0xC4D1", "comment": "else if character in A=RETURN terminate edit"},
{"address": "0xC4D3", "comment": "else C4D8"},
{"address": "0xC4D5", "comment": "terminate edit"},
{"address": "0xC4D8", "comment": "is character DELETE ?"},
{"address": "0xC4DA", "comment": "if so C4ED"},
{"address": "0xC4DC", "comment": "is it less than space? (i.e. VDU control code)"},
{"address": "0xC4DE", "comment": "if so C4EF"},
{"address": "0xC4E0", "comment": "else check VDU byte again"},
{"address": "0xC4E2", "comment": "if screen disabled C4EA"},
{"address": "0xC4E4", "comment": "else display a character"},
{"address": "0xC4E7", "comment": "and cursor right"},
{"address": "0xC4ED", "comment": "to replace delete character"},
{"address": "0xC4EF", "comment": "Y=A"},
{"address": "0xC4F0", "comment": "get lo byte of link address"},
{"address": "0xC4F3", "comment": "store it in jump vector"},
{"address": "0xC4F6", "comment": "get hi byte"},
{"address": "0xC4F9", "comment": "if negative (as it will be if a direct address)"},
{"address": "0xC4FB", "comment": "else X=A"},
{"address": "0xC4FC", "comment": "set up negated parameter count"},
{"address": "0xC4FE", "comment": "store it as number of items in VDU queue"},
{"address": "0xC501", "comment": "get back A"},
{"address": "0xC502", "comment": "A=A/16"},
{"address": "0xC506", "comment": "clear carry"},
{"address": "0xC507", "comment": "add &C3 to get hi byte of link address"},
{"address": "0xC50C", "comment": "check if cursor editing enabled"},
{"address": "0xC50E", "comment": "if so re-exchange pointers"},
{"address": "0xC510", "comment": "clear carry"},
{"address": "0xC511", "comment": "and exit"},
{"address": "0xC512", "comment": "store parameter in queue"},
{"address": "0xC515", "comment": "increment X"},
{"address": "0xC516", "comment": "store it as VDU queue"},
{"address": "0xC519", "comment": "if not 0 C532 as more parameters are needed"},
{"address": "0xC51B", "comment": "get VDU status byte"},
{"address": "0xC51D", "comment": "if screen disabled C534"},
{"address": "0xC51F", "comment": "else if cursor editing C526"},
{"address": "0xC521", "comment": "execute required function"},
{"address": "0xC524", "comment": "clear carry"},
{"address": "0xC525", "comment": "and exit"},
{"address": "0xC526", "comment": "swap values of cursors"},
{"address": "0xC529", "comment": "set up write cursor"},
{"address": "0xC52C", "comment": "execute required function"},
{"address": "0xC52F", "comment": "re-exchange pointers"},
{"address": "0xC532", "comment": "carry clear"},
{"address": "0xC533", "comment": "exit"},
{"address": "0xC534", "comment": "if upper byte of link address not &C5"},
{"address": "0xC537", "comment": "printer is not interested"},
{"address": "0xC539", "comment": "so C532"},
{"address": "0xC53B", "comment": "else X=A"},
{"address": "0xC53C", "comment": "A=VDU status byte"},
{"address": "0xC53E", "comment": "get bit 0 into carry"},
{"address": "0xC53F", "comment": "if printer not enabled exit"},
{"address": "0xC541", "comment": "restore A"},
{"address": "0xC542", "comment": "else send byte in A (next byte) to printer"},
{"address": "0xC545", "comment": "upper byte of link address"},
{"address": "0xC548", "comment": "restore A"},
{"address": "0xC549", "comment": "is it 7 or less?"},
{"address": "0xC54B", "comment": "if so C553"},
{"address": "0xC54D", "comment": "invert it"},
{"address": "0xC54F", "comment": "c is set if A >&0D"},
{"address": "0xC551", "comment": "re invert"},
{"address": "0xC553", "comment": "VDU status byte"},
{"address": "0xC555", "comment": "if display disabled C580"},
{"address": "0xC557", "comment": "push processor flags"},
{"address": "0xC558", "comment": "execute required function"},
{"address": "0xC55B", "comment": "get back flags"},
{"address": "0xC55C", "comment": "if carry clear (from C54B/F)"},
{"address": "0xC55E", "comment": "VDU status byte"},
{"address": "0xC560", "comment": "Carry is set if printer is enabled"},
{"address": "0xC561", "comment": "VDU status byte"},
{"address": "0xC563", "comment": "if no cursor editing  C511 to exit"},
{"address": "0xC565", "comment": "restore normal write cursor"},
{"address": "0xC568", "comment": "save flags and"},
{"address": "0xC569", "comment": "A"},
{"address": "0xC56A", "comment": "X=&18"},
{"address": "0xC56C", "comment": "Y=&64"},
{"address": "0xC56E", "comment": "exchange &300/1+X with &300/1+Y"},
{"address": "0xC571", "comment": "set up display address"},
{"address": "0xC574", "comment": "set cursor position"},
{"address": "0xC577", "comment": "VDU status byte"},
{"address": "0xC579", "comment": "invert bit 1 to allow or bar scrolling"},
{"address": "0xC57B", "comment": "VDU status byte"},
{"address": "0xC57D", "comment": "restore flags and A"},
{"address": "0xC57F", "comment": "and exit"},
{"address": "0xC580", "comment": "if A<>6"},
{"address": "0xC582", "comment": "return via C58C"},
{"address": "0xC584", "comment": "A=&7F"},
{"address": "0xC586", "comment": "and goto C5A8 ALWAYS!!"},
{"address": "0xC588", "comment": "VDU status byte"},
{"address": "0xC58A", "comment": "set A from bit 5 of status byte"},
{"address": "0xC58C", "comment": "and exit"},
{"address": "0xC58D", "comment": "Y=0"},
{"address": "0xC58F", "comment": "paged mode counter"},
{"address": "0xC592", "comment": "A=04"},
{"address": "0xC594", "comment": "jump to C59D"},
{"address": "0xC596", "comment": "select printer buffer and output character"},
{"address": "0xC599", "comment": "A=&94"},
{"address": "0xC59B", "comment": "if A=&15 A now =&80: if A=&94 A now =1"},
{"address": "0xC59D", "comment": "VDU status byte set bit 0 or bit 7"},
{"address": "0xC59F", "comment": "branch forward to store"},
{"address": "0xC5A1", "comment": "select printer buffer and output character"},
{"address": "0xC5A4", "comment": "A=10 to clear status bits below..."},
{"address": "0xC5A6", "comment": "convert to &FB or &FE"},
{"address": "0xC5A8", "comment": "VDU status byte clear bit 0 or bit 2 of status"},
{"address": "0xC5AA", "comment": "VDU status byte"},
{"address": "0xC5AC", "comment": "exit"},
{"address": "0xC5AD", "comment": "pixels per byte"},
{"address": "0xC5B0", "comment": "if no graphics in current mode C5AC"},
{"address": "0xC5B2", "comment": "set CRT controller for text cursor"},
{"address": "0xC5B5", "comment": "this to clear bit 5 of status byte"},
{"address": "0xC5B7", "comment": "via C5A8 exit"},
{"address": "0xC5B9", "comment": "pixels per byte"},
{"address": "0xC5BC", "comment": "if none this is text mode so exit"},
{"address": "0xC5BE", "comment": "set up graphics cursor"},
{"address": "0xC5C0", "comment": "via C954"},
{"address": "0xC5C3", "comment": "set bit 5 via exit C59D"},
{"address": "0xC5C5", "comment": "A=0 if text cursor A=&20 if graphics cursor"},
{"address": "0xC5C8", "comment": "move cursor left 8 pixels if graphics"},
{"address": "0xC5CA", "comment": "else decrement text column"},
{"address": "0xC5CD", "comment": "store new text column"},
{"address": "0xC5D0", "comment": "if it is less than text window left"},
{"address": "0xC5D3", "comment": "do wraparound  cursor to rt of screen 1 line up"},
{"address": "0xC5D5", "comment": "text cursor 6845 address"},
{"address": "0xC5D8", "comment": "subtract"},
{"address": "0xC5D9", "comment": "bytes per character"},
{"address": "0xC5DC", "comment": "put in X"},
{"address": "0xC5DD", "comment": "get text cursor 6845 address"},
{"address": "0xC5E0", "comment": "subtract 0"},
{"address": "0xC5E2", "comment": "compare with hi byte of screen RAM address"},
{"address": "0xC5E5", "comment": "if = or greater"},
{"address": "0xC5E7", "comment": "add screen RAM size hi byte to wrap around"},
{"address": "0xC5EA", "comment": "Y=A"},
{"address": "0xC5EB", "comment": "Y hi and X lo byte of cursor position"},
{"address": "0xC5EE", "comment": "text window right"},
{"address": "0xC5F1", "comment": "text column"},
{"address": "0xC5F4", "comment": "paged mode counter"},
{"address": "0xC5F7", "comment": "if still greater than 0 skip next instruction"},
{"address": "0xC5F9", "comment": "paged mode counter to restore X=0"},
{"address": "0xC5FC", "comment": "current text line"},
{"address": "0xC5FF", "comment": "top of text window"},
{"address": "0xC602", "comment": "if its at top of window C60A"},
{"address": "0xC604", "comment": "else decrement current text line"},
{"address": "0xC607", "comment": "and carry on moving cursor"},
{"address": "0xC60A", "comment": "clear carry"},
{"address": "0xC60B", "comment": "check for window violatations"},
{"address": "0xC60E", "comment": "A=8 to check for software scrolling"},
{"address": "0xC610", "comment": "compare against VDU status byte"},
{"address": "0xC612", "comment": "if not enabled C619"},
{"address": "0xC614", "comment": "set screen start register and adjust RAM"},
{"address": "0xC617", "comment": "jump C61C"},
{"address": "0xC619", "comment": "soft scroll 1 line"},
{"address": "0xC61C", "comment": "and exit"},
{"address": "0xC61F", "comment": "X=0 to select horizontal parameters"},
{"address": "0xC621", "comment": "store X"},
{"address": "0xC623", "comment": "check for window violations"},
{"address": "0xC626", "comment": "restore X"},
{"address": "0xC628", "comment": "set carry"},
{"address": "0xC629", "comment": "current graphics cursor X>1=vertical"},
{"address": "0xC62C", "comment": "subtract 8 to move back 1 character"},
{"address": "0xC62E", "comment": "store in current graphics cursor X>1=verticaal"},
{"address": "0xC631", "comment": "if carry set skip next"},
{"address": "0xC633", "comment": "current graphics cursor hi -1"},
{"address": "0xC636", "comment": "&DA=0 if no violation else 1 if vert violation"},
{"address": "0xC638", "comment": "if violation C658"},
{"address": "0xC63A", "comment": "check for window violations"},
{"address": "0xC63D", "comment": "if none C658"},
{"address": "0xC63F", "comment": "else get back X"},
{"address": "0xC641", "comment": "graphics window rt X=0 top X=2"},
{"address": "0xC644", "comment": "is X=0"},
{"address": "0xC646", "comment": "if not C64A"},
{"address": "0xC648", "comment": "else subtract 7"},
{"address": "0xC64A", "comment": "current graphics cursor X>1=vertical"},
{"address": "0xC64D", "comment": "graphics window hi rt X=0 top X=2"},
{"address": "0xC650", "comment": "subtract carry"},
{"address": "0xC652", "comment": "current graphics cursor X<2=horizontal else vertical"},
{"address": "0xC655", "comment": "A=X"},
{"address": "0xC656", "comment": "cursor up"},
{"address": "0xC658", "comment": "set up external coordinates for graphics"},
{"address": "0xC65B", "comment": "A=0 if text cursor A=&20 if graphics cursor"},
{"address": "0xC65E", "comment": "if text cursor then C5F4"},
{"address": "0xC660", "comment": "else X=2"},
{"address": "0xC662", "comment": "goto C6B6"},
{"address": "0xC664", "comment": "VDU status byte"},
{"address": "0xC666", "comment": "check bit 5"},
{"address": "0xC668", "comment": "if set then graphics cursor in use so C6B4"},
{"address": "0xC66A", "comment": "text column"},
{"address": "0xC66D", "comment": "text window right"},
{"address": "0xC670", "comment": "if X exceeds window right then C684"},
{"address": "0xC672", "comment": "text column"},
{"address": "0xC675", "comment": "text cursor 6845 address"},
{"address": "0xC678", "comment": "add bytes per character"},
{"address": "0xC67B", "comment": "X=A"},
{"address": "0xC67C", "comment": "text cursor 6845 address"},
{"address": "0xC67F", "comment": "add carry if set"},
{"address": "0xC681", "comment": "use X and Y to set new cursor address"},
{"address": "0xC684", "comment": "text window left"},
{"address": "0xC687", "comment": "text column"},
{"address": "0xC68A", "comment": "clear carry"},
{"address": "0xC68B", "comment": "check bottom margin, X=line count"},
{"address": "0xC68E", "comment": "current text line"},
{"address": "0xC691", "comment": "bottom margin"},
{"address": "0xC694", "comment": "if X=>current bottom margin C69B"},
{"address": "0xC696", "comment": "else increment current text line"},
{"address": "0xC69B", "comment": "check for window violations"},
{"address": "0xC69E", "comment": "check bit 3"},
{"address": "0xC6A0", "comment": "VDU status byte"},
{"address": "0xC6A2", "comment": "if software scrolling enabled C6A9"},
{"address": "0xC6A4", "comment": "perform hardware scroll"},
{"address": "0xC6A9", "comment": "execute upward scroll"},
{"address": "0xC6AC", "comment": "clear a line"},
{"address": "0xC6AF", "comment": "set up display address"},
{"address": "0xC6B6", "comment": "store X"},
{"address": "0xC6B8", "comment": "check for window violations"},
{"address": "0xC6BB", "comment": "get back X"},
{"address": "0xC6BD", "comment": "clear carry"},
{"address": "0xC6BE", "comment": "current graphics cursor X>1=vertical"},
{"address": "0xC6C1", "comment": "Add 8 pixels"},
{"address": "0xC6C3", "comment": "current graphics cursor X>1=vertical"},
{"address": "0xC6C8", "comment": "current graphics cursor X<2=horizontal else vertical"},
{"address": "0xC6CB", "comment": "A=0 no window violations 1 or 2 indicates violation"},
{"address": "0xC6CD", "comment": "if outside window C658"},
{"address": "0xC6CF", "comment": "check for window violations"},
{"address": "0xC6D2", "comment": "if no violations C658"},
{"address": "0xC6D4", "comment": "get back X"},
{"address": "0xC6D6", "comment": "graphics window X<2 =left else bottom"},
{"address": "0xC6D9", "comment": "If X=0"},
{"address": "0xC6DB", "comment": "C6DF"},
{"address": "0xC6DD", "comment": "else add 7"},
{"address": "0xC6DF", "comment": "current graphics cursor X>1=vertical"},
{"address": "0xC6E2", "comment": "graphics window hi X<2 =left else bottom"},
{"address": "0xC6E5", "comment": "add anny carry"},
{"address": "0xC6E7", "comment": "current graphics cursor X<2=horizontal else vertical"},
{"address": "0xC6EA", "comment": "A=X"},
{"address": "0xC6EB", "comment": "if X=0 C6F5 cursor down"},
{"address": "0xC6ED", "comment": "set up external coordinates for graphics"},
{"address": "0xC6F0", "comment": "A=0 if text cursor A=&20 if graphics cursor"},
{"address": "0xC6F3", "comment": "if text cursor back to C68A"},
{"address": "0xC6F5", "comment": "else X=2 to indicate vertical movement"},
{"address": "0xC6F7", "comment": "move graphics cursor down"},
{"address": "0xC6FA", "comment": "screen mode"},
{"address": "0xC6FD", "comment": "get bottom margin"},
{"address": "0xC700", "comment": "compare with top margin"},
{"address": "0xC703", "comment": "if bottom margin exceeds top return"},
{"address": "0xC705", "comment": "text window bottom margin maximum"},
{"address": "0xC708", "comment": "if equal then its OK"},
{"address": "0xC70A", "comment": "else exit"},
{"address": "0xC70C", "comment": "get right margin"},
{"address": "0xC70F", "comment": "put it in Y"},
{"address": "0xC710", "comment": "text window right hand margin maximum"},
{"address": "0xC713", "comment": "if equal then OK"},
{"address": "0xC715", "comment": "if greater than maximum exit"},
{"address": "0xC717", "comment": "set carry to subtract"},
{"address": "0xC718", "comment": "left margin"},
{"address": "0xC71B", "comment": "if left greater than right exit"},
{"address": "0xC71D", "comment": "else A=Y (window width)"},
{"address": "0xC71E", "comment": "calculate number of bytes in a line"},
{"address": "0xC721", "comment": "A=8 to set bit  of &D0"},
{"address": "0xC723", "comment": "indicating that text window is defined"},
{"address": "0xC726", "comment": "point to parameters"},
{"address": "0xC728", "comment": "point to text window margins"},
{"address": "0xC72A", "comment": "(&300/3+Y)=(&300/3+X)"},
{"address": "0xC72D", "comment": "set up screen address"},
{"address": "0xC730", "comment": "home cursor within window"},
{"address": "0xC732", "comment": "set cursor position"},
{"address": "0xC735", "comment": "Y=3 to point to hi byte of Y coordinate"},
{"address": "0xC737", "comment": "get it"},
{"address": "0xC739", "comment": "store it"},
{"address": "0xC73C", "comment": "point to next byte"},
{"address": "0xC73D", "comment": "transfer till Y=&FF lo byte of X coordinate in &328"},
{"address": "0xC741", "comment": "check window boundaries"},
{"address": "0xC744", "comment": "Y=4"},
{"address": "0xC746", "comment": "jump to C750"},
{"address": "0xC748", "comment": "number of logical colours less 1"},
{"address": "0xC74B", "comment": "put it in X"},
{"address": "0xC74C", "comment": "colour pallette"},
{"address": "0xC74F", "comment": "increment Y to point to byte 1"},
{"address": "0xC750", "comment": "store data"},
{"address": "0xC752", "comment": "issue 0s"},
{"address": "0xC754", "comment": "to next bytes until Y=4"},
{"address": "0xC758", "comment": "and exit"},
{"address": "0xC759", "comment": "A=0 if text cursor A=&20 if graphics cursor"},
{"address": "0xC75C", "comment": "if graphics cursor &C7BD"},
{"address": "0xC75E", "comment": "VDU status byte"},
{"address": "0xC760", "comment": "check if software scrolling (text window set)"},
{"address": "0xC762", "comment": "if so C767"},
{"address": "0xC764", "comment": "initialise screen display and home cursor"},
{"address": "0xC767", "comment": "top of text window"},
{"address": "0xC76A", "comment": "current text line"},
{"address": "0xC76D", "comment": "clear a line"},
{"address": "0xC770", "comment": "current text line"},
{"address": "0xC773", "comment": "bottom margin"},
{"address": "0xC776", "comment": "X=X+1"},
{"address": "0xC777", "comment": "if X at compare is less than bottom margin clear next"},
{"address": "0xC779", "comment": "A=0 if text cursor A=&20 if graphics cursor"},
{"address": "0xC77C", "comment": "if text cursor C781"},
{"address": "0xC77E", "comment": "home graphic cursor if graphic"},
{"address": "0xC781", "comment": "store 0 in last two parameters"},
{"address": "0xC787", "comment": "A=0 if text cursor A=&20 if graphics cursor"},
{"address": "0xC78A", "comment": "exit"},
{"address": "0xC78C", "comment": "exchange text column/line with workspace 0328/9"},
{"address": "0xC78F", "comment": "clear carry"},
{"address": "0xC790", "comment": "get X coordinate"},
{"address": "0xC793", "comment": "add to text window left"},
{"address": "0xC796", "comment": "store as text column"},
{"address": "0xC799", "comment": "get Y coordinate"},
{"address": "0xC79D", "comment": "add top of text window"},
{"address": "0xC7A0", "comment": "current text line"},
{"address": "0xC7A3", "comment": "set up screen address"},
{"address": "0xC7A6", "comment": "set cursor position if C=0 (point on screen)"},
{"address": "0xC7A8", "comment": "else point to workspace"},
{"address": "0xC7AA", "comment": "and line/column to restore old values"},
{"address": "0xC7AC", "comment": "exchange &300/1+X with &300/1+Y"},
{"address": "0xC7AF", "comment": "A=0 if text cursor A=&20 if graphics cursor"},
{"address": "0xC7B2", "comment": "if text C7B7"},
{"address": "0xC7B4", "comment": "else set graphics cursor to left hand columm"},
{"address": "0xC7B7", "comment": "set text column to left hand column"},
{"address": "0xC7BA", "comment": "set up cursor and display address"},
{"address": "0xC7BD", "comment": "home graphic cursor"},
{"address": "0xC7C0", "comment": "pixels per byte"},
{"address": "0xC7C3", "comment": "if 0 current mode has no graphics so exit"},
{"address": "0xC7C5", "comment": "Background graphics colour"},
{"address": "0xC7C8", "comment": "background graphics plot mode (GCOL n)"},
{"address": "0xC7CB", "comment": "set graphics byte mask in &D4/5"},
{"address": "0xC7CE", "comment": "graphics window"},
{"address": "0xC7D0", "comment": "workspace"},
{"address": "0xC7D2", "comment": "set(300/7+Y) from (300/7+X)"},
{"address": "0xC7D5", "comment": "set carry"},
{"address": "0xC7D6", "comment": "graphics window top low"},
{"address": "0xC7D9", "comment": "graphics window bottom low"},
{"address": "0xC7DC", "comment": "Y=difference"},
{"address": "0xC7DD", "comment": "increment"},
{"address": "0xC7DE", "comment": "and store in workspace (this is line count)"},
{"address": "0xC7E5", "comment": "clear line"},
{"address": "0xC7E8", "comment": "decrement window height in pixels"},
{"address": "0xC7F3", "comment": "decrement line count"},
{"address": "0xC7F6", "comment": "if <>0 then do it again"},
{"address": "0xC7F8", "comment": "exit"},
{"address": "0xC7F9", "comment": "Y=0"},
{"address": "0xC7FB", "comment": "jump to C7FF"},
{"address": "0xC7FD", "comment": "Y=2"},
{"address": "0xC7FF", "comment": "get last parameter"},
{"address": "0xC802", "comment": "if +ve its foreground colour so C805"},
{"address": "0xC804", "comment": "else Y=Y+1"},
{"address": "0xC805", "comment": "number of logical colours less 1"},
{"address": "0xC808", "comment": "store it"},
{"address": "0xC80A", "comment": "number of logical colours less 1"},
{"address": "0xC80D", "comment": "if none exit"},
{"address": "0xC80F", "comment": "else limit to an available colour and clear M"},
{"address": "0xC811", "comment": "clear carry"},
{"address": "0xC812", "comment": "Add last parameter to get pointer to table"},
{"address": "0xC814", "comment": "pointer into X"},
{"address": "0xC815", "comment": "get colour bitmap from table"},
{"address": "0xC818", "comment": "colour Y=0=text fgnd, 1=text bkgnd, 2=graphics fg, etc"},
{"address": "0xC81B", "comment": "If Y>1"},
{"address": "0xC81D", "comment": "then its graphics so C82C else"},
{"address": "0xC81F", "comment": "foreground text colour"},
{"address": "0xC822", "comment": "invert"},
{"address": "0xC824", "comment": "text colour byte to be orred or EORed into memory"},
{"address": "0xC826", "comment": "background text colour"},
{"address": "0xC829", "comment": "text colour byte to be orred or EORed into memory"},
{"address": "0xC82B", "comment": "and exit"},
{"address": "0xC82C", "comment": "Get GCOL action"},
{"address": "0xC82F", "comment": "Store at &35B foreground, &35C background"},
{"address": "0xC832", "comment": "exit"},
{"address": "0xC833", "comment": "SPACE character for teletext background"},
{"address": "0xC835", "comment": "Set as background colour"},
{"address": "0xC839", "comment": "X=5"},
{"address": "0xC83B", "comment": "A=0"},
{"address": "0xC83D", "comment": "Zero all colour settings"},
{"address": "0xC840", "comment": "txtfgd, txtbgd, gfxfdg, gfxbgd, gcolgfd, gcolbgd"},
{"address": "0xC843", "comment": "Number of logical colours less 1"},
{"address": "0xC846", "comment": "If zero, teletext so to C833 to set ttxt background"},
{"address": "0xC848", "comment": "A=&FF"},
{"address": "0xC84A", "comment": "Is it a 16-colour MODE?"},
{"address": "0xC84C", "comment": "Not 16 colours, skip past"},
{"address": "0xC84E", "comment": "A=&3F for <16 colours, A=&FF for 16 colours"},
{"address": "0xC850", "comment": "foreground text colour"},
{"address": "0xC853", "comment": "foreground graphics colour"},
{"address": "0xC856", "comment": "invert A"},
{"address": "0xC858", "comment": "text colour byte to be ORed or EORed into memory"},
{"address": "0xC85A", "comment": "text colour byte to be ORed or EORed into memory"},
{"address": "0xC85C", "comment": "set first parameter of 5"},
{"address": "0xC85F", "comment": "if there are 4 colours"},
{"address": "0xC861", "comment": "goto C874"},
{"address": "0xC863", "comment": "if less there are 2 colours goto C885"},
{"address": "0xC865", "comment": "set second parameter"},
{"address": "0xC868", "comment": "do VDU 19 etc"},
{"address": "0xC86B", "comment": "decrement first parameter"},
{"address": "0xC86E", "comment": "and last parameter"},
{"address": "0xC874", "comment": "X=7"},
{"address": "0xC876", "comment": "set first parameter"},
{"address": "0xC879", "comment": "and do VDU 19"},
{"address": "0xC884", "comment": "exit"},
{"address": "0xC885", "comment": "X=7"},
{"address": "0xC887", "comment": "execute VDU 19"},
{"address": "0xC88A", "comment": "X=0"},
{"address": "0xC88C", "comment": "store it as"},
{"address": "0xC88F", "comment": "both parameters"},
{"address": "0xC892", "comment": "push processor flags"},
{"address": "0xC893", "comment": "disable interrupts"},
{"address": "0xC894", "comment": "get first parameter and"},
{"address": "0xC897", "comment": "number of logical colours less 1"},
{"address": "0xC89A", "comment": "to make legal, then X=A"},
{"address": "0xC89B", "comment": "A=second parameter"},
{"address": "0xC89E", "comment": "make legal"},
{"address": "0xC8A0", "comment": "colour pallette"},
{"address": "0xC8A3", "comment": "Y=A"},
{"address": "0xC8A4", "comment": "number of logical colours less 1"},
{"address": "0xC8A7", "comment": "store it"},
{"address": "0xC8A9", "comment": "is it 4 colour mode??"},
{"address": "0xC8AB", "comment": "save flags"},
{"address": "0xC8AC", "comment": "A=X"},
{"address": "0xC8AD", "comment": "rotate A into &FA"},
{"address": "0xC8B4", "comment": "A=Y"},
{"address": "0xC8B8", "comment": "Y=0"},
{"address": "0xC8BA", "comment": "check flags"},
{"address": "0xC8BC", "comment": "if A<>3 earlier C8CC"},
{"address": "0xC8BE", "comment": "else A=&60 to test bits 5 and 6"},
{"address": "0xC8C0", "comment": "if not set C8CB"},
{"address": "0xC8C2", "comment": "else if both set"},
{"address": "0xC8C4", "comment": "C8CB"},
{"address": "0xC8C6", "comment": "A=X"},
{"address": "0xC8C7", "comment": "invert"},
{"address": "0xC8C9", "comment": "and if not 0 C8CC"},
{"address": "0xC8CB", "comment": "X=A"},
{"address": "0xC8CC", "comment": "call Osbyte 155 pass data to pallette register"},
{"address": "0xC8D1", "comment": "number of logical colours less 1"},
{"address": "0xC8D9", "comment": "if Y<16 do it again"},
{"address": "0xC8DD", "comment": "pull flags twice"},
{"address": "0xC8DF", "comment": "and exit"},
{"address": "0xC8E0", "comment": "push flags"},
{"address": "0xC8E1", "comment": "and with number of logical colours less 1"},
{"address": "0xC8E4", "comment": "X=A"},
{"address": "0xC8E5", "comment": "Y=Y+1"},
{"address": "0xC8E6", "comment": "get physical colour"},
{"address": "0xC8E8", "comment": "do VDU19 with parameters in X and A"},
{"address": "0xC8EB", "comment": "get parameter"},
{"address": "0xC8EE", "comment": "goto CB33"},
{"address": "0xC8F1", "comment": "get character to define"},
{"address": "0xC8F4", "comment": "is it"},
{"address": "0xC8F6", "comment": "if less then it is a control instruction, go to C93F"},
{"address": "0xC8F8", "comment": "else save parameter"},
{"address": "0xC8F9", "comment": "A=A/32"},
{"address": "0xC8FE", "comment": "X=A"},
{"address": "0xC8FF", "comment": "get font flag mask from table (A=&80/2^X)"},
{"address": "0xC902", "comment": "font flag"},
{"address": "0xC905", "comment": "and if A<>0 C927 storage area is established already"},
{"address": "0xC907", "comment": "or with font flag to set bit found to be 0"},
{"address": "0xC90A", "comment": "font flag"},
{"address": "0xC90D", "comment": "get A back"},
{"address": "0xC90E", "comment": "And 3 to clear all but bits 0 and 1"},
{"address": "0xC910", "comment": "clear carry"},
{"address": "0xC911", "comment": "add &BF (A=&C0,&C1,&C2) to select a character page"},
{"address": "0xC913", "comment": "store it"},
{"address": "0xC915", "comment": "get font location byte (normally &0C)"},
{"address": "0xC918", "comment": "store it"},
{"address": "0xC91A", "comment": "Y=0 so (&DE) holds (&C000 -&C2FF)"},
{"address": "0xC920", "comment": "transfer page to storage area"},
{"address": "0xC927", "comment": "get A back"},
{"address": "0xC928", "comment": "set up character definition pointers"},
{"address": "0xC92B", "comment": "Y=7"},
{"address": "0xC92D", "comment": "transfer definition parameters"},
{"address": "0xC930", "comment": "to RAM definition"},
{"address": "0xC935", "comment": "and exit"},
{"address": "0xC936", "comment": "Pull A"},
{"address": "0xC937", "comment": "and exit"},
{"address": "0xC938", "comment": "A=PLOT action number from VDU 25"},
{"address": "0xC93B", "comment": "clear carry=PLOT"},
{"address": "0xC93C", "comment": "jump via VDUV vector, A=PLOT number or VDU 23 number"},
{"address": "0xC93F", "comment": "is A=1"},
{"address": "0xC941", "comment": "if less (0) then set CRT register directly"},
{"address": "0xC943", "comment": "if not 1 jump to VDUV with CS for VDU extension"},
{"address": "0xC945", "comment": "A=0 if text cursor, A=&20 if graphics cursor"},
{"address": "0xC948", "comment": "if graphics exit"},
{"address": "0xC94A", "comment": "A=&20 - preload to turn cursor off"},
{"address": "0xC94C", "comment": "Y=second VDU parameter"},
{"address": "0xC94F", "comment": "if 0, jump to C954 to turn cursor off"},
{"address": "0xC951", "comment": "get last setting of CRT controller register"},
{"address": "0xC954", "comment": "Y=10 - cursor control register number"},
{"address": "0xC956", "comment": "jump to C985, Y=register, Y=value"},
{"address": "0xC958", "comment": "get third parameter - value"},
{"address": "0xC95B", "comment": "and second parameter - register"},
{"address": "0xC95E", "comment": "is Y=7"},
{"address": "0xC960", "comment": "if less C985"},
{"address": "0xC962", "comment": "else if >7 C967"},
{"address": "0xC964", "comment": "else ADD screen vertical display adjustment"},
{"address": "0xC967", "comment": "If Y<>8"},
{"address": "0xC969", "comment": "C972"},
{"address": "0xC96B", "comment": "if bit 7 set"},
{"address": "0xC96D", "comment": "C972"},
{"address": "0xC96F", "comment": "else EOR with interlace toggle"},
{"address": "0xC972", "comment": "Y=10??"},
{"address": "0xC974", "comment": "if not C985"},
{"address": "0xC976", "comment": "last setting of CRT controller register"},
{"address": "0xC979", "comment": "Y=A"},
{"address": "0xC97A", "comment": "VDU status byte"},
{"address": "0xC97C", "comment": "check bit 5 printing at graphics cursor?"},
{"address": "0xC97E", "comment": "push flags"},
{"address": "0xC97F", "comment": "Y=A"},
{"address": "0xC980", "comment": "Y=10"},
{"address": "0xC982", "comment": "pull flags"},
{"address": "0xC983", "comment": "if graphics in use then C98B"},
{"address": "0xC985", "comment": "else set CRTC address register"},
{"address": "0xC988", "comment": "and poke new value to register Y"},
{"address": "0xC98B", "comment": "exit"},
{"address": "0xC98C", "comment": "pixels per byte"},
{"address": "0xC98F", "comment": "if no graphics available go to VDU Extension"},
{"address": "0xC991", "comment": "else enter Plot routine at D060"},
{"address": "0xC994", "comment": "window area start address lo"},
{"address": "0xC997", "comment": "window area start address hi"},
{"address": "0xC99A", "comment": "subtract bytes per character row from this"},
{"address": "0xC99D", "comment": "if no wraparound needed C9B3"},
{"address": "0xC99F", "comment": "screen RAM size hi byte to wrap around"},
{"address": "0xC9A4", "comment": "window area start address lo"},
{"address": "0xC9A7", "comment": "window area start address hi"},
{"address": "0xC9AA", "comment": "add bytes per char. row"},
{"address": "0xC9AF", "comment": "wrap around in other direction"},
{"address": "0xC9B0", "comment": "screen RAM size hi byte"},
{"address": "0xC9B3", "comment": "window area start address hi"},
{"address": "0xC9B6", "comment": "window area start address lo"},
{"address": "0xC9B9", "comment": "Y=12"},
{"address": "0xC9BB", "comment": "jump to CA0E"},
{"address": "0xC9BD", "comment": "A=0"},
{"address": "0xC9BF", "comment": "X=&2C"},
{"address": "0xC9C1", "comment": "clear all windows"},
{"address": "0xC9C5", "comment": "until X=&FF"},
{"address": "0xC9C7", "comment": "screen mode"},
{"address": "0xC9CA", "comment": "text window right hand margin maximum"},
{"address": "0xC9CD", "comment": "text window right"},
{"address": "0xC9D0", "comment": "calculate number of bytes in a line"},
{"address": "0xC9D3", "comment": "text window bottom margin maximum"},
{"address": "0xC9D6", "comment": "bottom margin"},
{"address": "0xC9D9", "comment": "Y=3"},
{"address": "0xC9DB", "comment": "set as last parameter"},
{"address": "0xC9DE", "comment": "increment Y"},
{"address": "0xC9DF", "comment": "set parameters"},
{"address": "0xC9E8", "comment": "and do VDU 24"},
{"address": "0xC9ED", "comment": "clear bit 3 of &D0"},
{"address": "0xC9F0", "comment": "window area start address lo"},
{"address": "0xC9F3", "comment": "window area start address hi"},
{"address": "0xC9F6", "comment": "text cursor 6845 address"},
{"address": "0xC9F9", "comment": "text cursor 6845 address"},
{"address": "0xC9FC", "comment": "set cursor position"},
{"address": "0xC9FF", "comment": "screen RAM size hi byte"},
{"address": "0xCA02", "comment": "set &D8/9 from X/A"},
{"address": "0xCA06", "comment": "text cursor 6845 address"},
{"address": "0xCA09", "comment": "text cursor 6845 address"},
{"address": "0xCA0C", "comment": "Y=15"},
{"address": "0xCA0E", "comment": "Push A"},
{"address": "0xCA0F", "comment": "screen mode"},
{"address": "0xCA12", "comment": "is it mode 7? - should check map type or colours=0"},
{"address": "0xCA14", "comment": "get back A"},
{"address": "0xCA15", "comment": "if mode 7 selected CA27"},
{"address": "0xCA17", "comment": "else store X"},
{"address": "0xCA19", "comment": "divide X/A by 8"},
{"address": "0xCA24", "comment": "goto CA2B"},
{"address": "0xCA27", "comment": "mode 7 subtract &74"},
{"address": "0xCA29", "comment": "EOR with &20"},
{"address": "0xCA2B", "comment": "write to CRTC address file register"},
{"address": "0xCA2E", "comment": "and to relevant address (register 14)"},
{"address": "0xCA31", "comment": "Increment Y"},
{"address": "0xCA32", "comment": "write to CRTC address file register"},
{"address": "0xCA35", "comment": "and to relevant address (register 15)"},
{"address": "0xCA38", "comment": "and RETURN"},
{"address": "0xCA39", "comment": "exchange 310/3 with 328/3"},
{"address": "0xCA40", "comment": "calculate width=right - left"},
{"address": "0xCA46", "comment": "exchange 310/3 with 328/3 and exit"},
{"address": "0xCA48", "comment": "X=&20"},
{"address": "0xCA4A", "comment": "scale pointers to mode"},
{"address": "0xCA4D", "comment": "X=&1C"},
{"address": "0xCA4F", "comment": "scale pointers to mode"},
{"address": "0xCA52", "comment": "check for negative margins"},
{"address": "0xCA58", "comment": "if found exchange 310/3 with 328/3 and exit"},
{"address": "0xCA5D", "comment": "exchange 310/3 with 328/3 and exit"},
{"address": "0xCA5F", "comment": "screen mode"},
{"address": "0xCA62", "comment": "right margin hi"},
{"address": "0xCA65", "comment": "store it"},
{"address": "0xCA67", "comment": "right margin lo"},
{"address": "0xCA6A", "comment": "/2"},
{"address": "0xCA6C", "comment": "A=A/2"},
{"address": "0xCA6D", "comment": "/2"},
{"address": "0xCA6F", "comment": "exchange 310/3 with 328/3"},
{"address": "0xCA71", "comment": "A=A/2"},
{"address": "0xCA72", "comment": "A=A/2"},
{"address": "0xCA73", "comment": "text window right hand margin maximum"},
{"address": "0xCA76", "comment": "if equal CA7A"},
{"address": "0xCA78", "comment": "exchange 310/3 with 328/3"},
{"address": "0xCA7A", "comment": "Y=0"},
{"address": "0xCA7C", "comment": "X=&1C"},
{"address": "0xCA7E", "comment": "set(300/7+Y) from (300/7+X)"},
{"address": "0xCA81", "comment": "X=10"},
{"address": "0xCA83", "comment": "Y=&28"},
{"address": "0xCA85", "comment": "exchange 300/3+Y and 300/3+X"},
{"address": "0xCA88", "comment": "Y=Y+1"},
{"address": "0xCA89", "comment": "A=Y"},
{"address": "0xCA8A", "comment": "Y=0"},
{"address": "0xCA8C", "comment": "text window width hi (bytes)"},
{"address": "0xCA8F", "comment": "text window width lo (bytes)"},
{"address": "0xCA92", "comment": "bytes per character"},
{"address": "0xCA95", "comment": "/2"},
{"address": "0xCA96", "comment": "if 0 exit"},
{"address": "0xCA98", "comment": "text window width lo (bytes)"},
{"address": "0xCA9B", "comment": "text window width hi (bytes)"},
{"address": "0xCA9E", "comment": "/2"},
{"address": "0xCAA6", "comment": "(&300/3+Y)=(&300/3+X)"},
{"address": "0xCAA9", "comment": "set up external coordinates for graphics"},
{"address": "0xCAAC", "comment": "cursor left"},
{"address": "0xCAAF", "comment": "A=0 if text cursor A=&20 if graphics cursor"},
{"address": "0xCAB2", "comment": "if graphics then CAC7"},
{"address": "0xCAB4", "comment": "number of logical colours less 1"},
{"address": "0xCAB7", "comment": "if colours=0, mode 7 CAC2"},
{"address": "0xCAB9", "comment": "else store A (always 0)"},
{"address": "0xCABB", "comment": "A=&C0"},
{"address": "0xCABD", "comment": "store in &DF (&DE) now points to C300 SPACE pattern"},
{"address": "0xCABF", "comment": "display a space"},
{"address": "0xCAC2", "comment": "A=&20"},
{"address": "0xCAC4", "comment": "and return to display a space"},
{"address": "0xCAC7", "comment": "for graphics cursor"},
{"address": "0xCAC9", "comment": "set up character definition pointers"},
{"address": "0xCACC", "comment": "Background graphics colour"},
{"address": "0xCACF", "comment": "Y=0"},
{"address": "0xCAD1", "comment": "invert pattern data (to background colour)"},
{"address": "0xCAD4", "comment": "store A"},
{"address": "0xCAD5", "comment": "A=X"},
{"address": "0xCAD6", "comment": "clear carry"},
{"address": "0xCAD7", "comment": "bytes per character row"},
{"address": "0xCADA", "comment": "X=A"},
{"address": "0xCADB", "comment": "get back A"},
{"address": "0xCADC", "comment": "bytes per character row"},
{"address": "0xCADF", "comment": "and return"},
{"address": "0xCAE0", "comment": "zero paged mode line counter"},
{"address": "0xCAE3", "comment": "osbyte 118 read ctrl/shift keys"},
{"address": "0xCAE6", "comment": "if carry clear, ctrl not pressed, CAEA"},
{"address": "0xCAE8", "comment": "if M set, shift pressed, loop to CAE0 do it again"},
{"address": "0xCAEA", "comment": "VDU status byte"},
{"address": "0xCAEC", "comment": "invert bit 2 paged scrolling"},
{"address": "0xCAEE", "comment": "and if 2 cursors, paged mode off, or scrolling"},
{"address": "0xCAF0", "comment": "barred then CB1C to exit"},
{"address": "0xCAF2", "comment": "paged mode counter"},
{"address": "0xCAF5", "comment": "if negative then exit via CB19"},
{"address": "0xCAF7", "comment": "current text line"},
{"address": "0xCAFA", "comment": "bottom margin"},
{"address": "0xCAFD", "comment": "increment line counter and exit"},
{"address": "0xCAFF", "comment": "A=A/4"},
{"address": "0xCB01", "comment": "set carry"},
{"address": "0xCB02", "comment": "paged mode counter"},
{"address": "0xCB05", "comment": "top of text window"},
{"address": "0xCB08", "comment": "bottom margin"},
{"address": "0xCB0B", "comment": "increment line counter and exit"},
{"address": "0xCB0D", "comment": "clear carry"},
{"address": "0xCB0E", "comment": "osbyte 118 read ctrl/shift keys, first loop with CC"},
{"address": "0xCB11", "comment": "set carry"},
{"address": "0xCB12", "comment": "if +ve, shift not pressed, loop until shift pressed"},
{"address": "0xCB16", "comment": "paged mode counter"},
{"address": "0xCB19", "comment": "paged mode counter"},
{"address": "0xCB1D", "comment": "Save MODE in A"},
{"address": "0xCB1E", "comment": "Prepare X=&7F for reset loop"},
{"address": "0xCB20", "comment": "A=0"},
{"address": "0xCB22", "comment": "Clear VDU status byte to set default conditions"},
{"address": "0xCB24", "comment": "Zero VDU workspace at &300 to &37E"},
{"address": "0xCB2A", "comment": "Implode character definitions"},
{"address": "0xCB2D", "comment": "Get initial MODE back to A"},
{"address": "0xCB2E", "comment": "X=&7F"},
{"address": "0xCB30", "comment": "MODE 7 copy cursor character"},
{"address": "0xCB33", "comment": "Check available RAM"},
{"address": "0xCB36", "comment": "If 32K, use all MODEs"},
{"address": "0xCB38", "comment": "Only 16K available, force to use MODEs 4-7"},
{"address": "0xCB3A", "comment": "X=A AND 7 ensure legal mode"},
{"address": "0xCB3C", "comment": "X=mode"},
{"address": "0xCB3D", "comment": "Set current screen MODE"},
{"address": "0xCB40", "comment": "Get number of colours -1 for this MODE"},
{"address": "0xCB43", "comment": "Set current number of logical colours less 1"},
{"address": "0xCB46", "comment": "Get bytes/character for this MODE"},
{"address": "0xCB49", "comment": "Set bytes per character"},
{"address": "0xCB4C", "comment": "Get pixels/byte for this MODE"},
{"address": "0xCB4F", "comment": "Set pixels per byte"},
{"address": "0xCB52", "comment": "If non-zero, skip past"},
{"address": "0xCB54", "comment": "pixels/byte=0, this is MODE 7, prepare A=7 offset into mask table"},
{"address": "0xCB56", "comment": "A=A*2"},
{"address": "0xCB57", "comment": "Y=A"},
{"address": "0xCB58", "comment": "mask table"},
{"address": "0xCB5B", "comment": "colour mask left"},
{"address": "0xCB5E", "comment": "A=A*2"},
{"address": "0xCB5F", "comment": "If still +ve CB5E"},
{"address": "0xCB61", "comment": "colour mask right"},
{"address": "0xCB64", "comment": "screen display memory index table"},
{"address": "0xCB67", "comment": "memory map type"},
{"address": "0xCB6A", "comment": "VDU section control"},
{"address": "0xCB6D", "comment": "set hardware scrolling to VIA"},
{"address": "0xCB70", "comment": "VDU section control"},
{"address": "0xCB73", "comment": "set hardware scrolling to VIA"},
{"address": "0xCB76", "comment": "Screen RAM size hi byte table"},
{"address": "0xCB79", "comment": "screen RAM size hi byte"},
{"address": "0xCB7C", "comment": "screen ram address hi byte"},
{"address": "0xCB7F", "comment": "hi byte of screen RAM address"},
{"address": "0xCB82", "comment": "Y=A"},
{"address": "0xCB83", "comment": "Add 2"},
{"address": "0xCB87", "comment": "/2"},
{"address": "0xCB88", "comment": "X=A"},
{"address": "0xCB89", "comment": "row multiplication table pointer"},
{"address": "0xCB8C", "comment": "store it"},
{"address": "0xCB8E", "comment": "A=&C3"},
{"address": "0xCB90", "comment": "store it (&E0) now points to C3B5 or C375"},
{"address": "0xCB92", "comment": "get number of bytes per row from table"},
{"address": "0xCB95", "comment": "store as bytes per character row"},
{"address": "0xCB98", "comment": "bytes per character row"},
{"address": "0xCB9B", "comment": "A=&43"},
{"address": "0xCB9D", "comment": "A=A AND &D0, clear all except CursorEdit, NoScroll, PrintOn"},
{"address": "0xCBA0", "comment": "get screen mode"},
{"address": "0xCBA3", "comment": "get video ULA control setting"},
{"address": "0xCBA6", "comment": "set video ULA using osbyte 154 code"},
{"address": "0xCBA9", "comment": "Save IRQ state"},
{"address": "0xCBAA", "comment": "Disable IRQs while changing CRTC registers"},
{"address": "0xCBAB", "comment": "Get offset to end of register table for this screen map"},
{"address": "0xCBAE", "comment": "Y=11, 12 registers to set"},
{"address": "0xCBB0", "comment": "Get register data for this register"},
{"address": "0xCBB3", "comment": "Set register Y"},
{"address": "0xCBB6", "comment": "Decrement pointer"},
{"address": "0xCBB7", "comment": "Decrement register number"},
{"address": "0xCBB8", "comment": "Loop until all done"},
{"address": "0xCBBA", "comment": "Restore IRQs"},
{"address": "0xCBBB", "comment": "VDU 20 - set default colours"},
{"address": "0xCBBE", "comment": "VDU 26 - set default windows"},
{"address": "0xCBC1", "comment": "X=0"},
{"address": "0xCBC3", "comment": "hi byte of screen RAM address"},
{"address": "0xCBC6", "comment": "window area start address lo"},
{"address": "0xCBC9", "comment": "window area start address hi"},
{"address": "0xCBCC", "comment": "use X and Y to set new cursor address"},
{"address": "0xCBCF", "comment": "Y=12"},
{"address": "0xCBD1", "comment": "set registers 12 and 13 in CRTC"},
{"address": "0xCBD4", "comment": "background text colour"},
{"address": "0xCBD7", "comment": "memory map type"},
{"address": "0xCBDA", "comment": "get section control number"},
{"address": "0xCBDD", "comment": "set it in jump vector lo"},
{"address": "0xCBE0", "comment": "Y=&CC"},
{"address": "0xCBE2", "comment": "upper byte of link address"},
{"address": "0xCBE5", "comment": "X=0"},
{"address": "0xCBE7", "comment": "Clear paged mode counter"},
{"address": "0xCBEA", "comment": "Set POS to zero"},
{"address": "0xCBED", "comment": "Set VPOS to zero"},
{"address": "0xCBF0", "comment": "Jump via vector set up previously to clear screen memory"},
{"address": "0xCBF3", "comment": "set up character definition pointers"},
{"address": "0xCBF6", "comment": "Y=0"},
{"address": "0xCBF8", "comment": "get first byte"},
{"address": "0xCBFA", "comment": "Y=Y+1"},
{"address": "0xCBFB", "comment": "store it in YX"},
{"address": "0xCBFD", "comment": "until Y=8"},
{"address": "0xCC01", "comment": "then exit"},
{"address": "0xCCF3", "comment": "exit"},
{"address": "0xCCF5", "comment": "jump vector set up previously"},
{"address": "0xCCF8", "comment": "Push A"},
{"address": "0xCCF9", "comment": "A=X"},
{"address": "0xCCFA", "comment": "set carry for subtraction"},
{"address": "0xCCFB", "comment": "bytes per character row"},
{"address": "0xCCFE", "comment": "restore X"},
{"address": "0xCCFF", "comment": "and A"},
{"address": "0xCD00", "comment": "bytes per character row"},
{"address": "0xCD03", "comment": "hi byte of screen RAM address"},
{"address": "0xCD06", "comment": "return"},
{"address": "0xCD07", "comment": "A=15"},
{"address": "0xCD09", "comment": "font flag indicating that page &0C,&C0-&C2 are"},
{"address": "0xCD0C", "comment": "A=&0C"},
{"address": "0xCD0E", "comment": "set loop counter"},
{"address": "0xCD10", "comment": "set all font location bytes"},
{"address": "0xCD13", "comment": "to page &0C to indicate only page available"},
{"address": "0xCD14", "comment": "for user character definitions"},
{"address": "0xCD16", "comment": "is X=7 or greater"},
{"address": "0xCD18", "comment": "if not CD1C"},
{"address": "0xCD1A", "comment": "else X=6"},
{"address": "0xCD1C", "comment": "character definition explosion switch"},
{"address": "0xCD1F", "comment": "A=primary OSHWM"},
{"address": "0xCD22", "comment": "X=0"},
{"address": "0xCD24", "comment": "character definition explosion switch"},
{"address": "0xCD29", "comment": "get soft character RAM allocation"},
{"address": "0xCD2C", "comment": "font location bytes"},
{"address": "0xCD2F", "comment": "Add 1"},
{"address": "0xCD31", "comment": "X=X+1"},
{"address": "0xCD32", "comment": "if X<>0 then CD24"},
{"address": "0xCD34", "comment": "Set new value of OSHWM (bottom of user memory)"},
{"address": "0xCD37", "comment": "Y=A"},
{"address": "0xCD38", "comment": "If OSHWM=&0000, return via CD06 (ERROR? will never happen)"},
{"address": "0xCD3A", "comment": "X=&11"},
{"address": "0xCD3C", "comment": "Issue paged ROM service call &11,<new OSHWM>"},
{"address": "0xCD3F", "comment": "A=2 to check if scrolling disabled"},
{"address": "0xCD41", "comment": "VDU status byte"},
{"address": "0xCD43", "comment": "if scrolling is barred CD47"},
{"address": "0xCD45", "comment": "if cursor editing mode disabled RETURN"},
{"address": "0xCD47", "comment": "bottom margin"},
{"address": "0xCD4A", "comment": "if carry clear on entry CD4F"},
{"address": "0xCD4C", "comment": "else if carry set get top of text window"},
{"address": "0xCD4F", "comment": "and if cursor editing enabled CD59"},
{"address": "0xCD51", "comment": "get current text line"},
{"address": "0xCD54", "comment": "pull return link from stack"},
{"address": "0xCD56", "comment": "set up cursor and display address"},
{"address": "0xCD59", "comment": "push flags"},
{"address": "0xCD5A", "comment": "Y coordinate of text input cursor"},
{"address": "0xCD5D", "comment": "if A=line count of text input cursor CD78 to exit"},
{"address": "0xCD5F", "comment": "get back flags"},
{"address": "0xCD62", "comment": "Y coordinate of text input cursor"},
{"address": "0xCD65", "comment": "exit"},
{"address": "0xCD66", "comment": "Y coordinate of text input cursor"},
{"address": "0xCD69", "comment": "exit"},
{"address": "0xCD6A", "comment": "save flags"},
{"address": "0xCD6B", "comment": "save A"},
{"address": "0xCD6C", "comment": "bytes per character"},
{"address": "0xCD6F", "comment": "Y=Y-1"},
{"address": "0xCD70", "comment": "if Y=0 Mode 7 is in use"},
{"address": "0xCD72", "comment": "get previously saved character under cursor"},
{"address": "0xCD75", "comment": "restore it to character cell of current character"},
{"address": "0xCD77", "comment": "pull A"},
{"address": "0xCD78", "comment": "pull flags"},
{"address": "0xCD79", "comment": "and exit"},
{"address": "0xCD7A", "comment": "push flags"},
{"address": "0xCD7B", "comment": "push A"},
{"address": "0xCD7C", "comment": "bytes per character"},
{"address": "0xCD80", "comment": "if not mode 7"},
{"address": "0xCD82", "comment": "get character from current character cell"},
{"address": "0xCD84", "comment": "store it"},
{"address": "0xCD87", "comment": "mode 7 write cursor character"},
{"address": "0xCD8A", "comment": "store it in current character cell"},
{"address": "0xCD8C", "comment": "and exit"},
{"address": "0xCD8F", "comment": "A=&FF =cursor"},
{"address": "0xCD91", "comment": "except in mode 2 (Y=&1F)"},
{"address": "0xCD93", "comment": "if not CD97"},
{"address": "0xCD95", "comment": "load cursor byte mask"},
{"address": "0xCD97", "comment": "store it"},
{"address": "0xCD99", "comment": "get scan line byte"},
{"address": "0xCD9B", "comment": "invert it"},
{"address": "0xCD9D", "comment": "store it on scan line"},
{"address": "0xCD9F", "comment": "decrement scan line counter"},
{"address": "0xCDA0", "comment": "do it again"},
{"address": "0xCDA2", "comment": "then jump to &CD77"},
{"address": "0xCDA4", "comment": "exchange line and column cursors with workspace copies"},
{"address": "0xCDA7", "comment": "bottom margin"},
{"address": "0xCDAA", "comment": "current text line"},
{"address": "0xCDAD", "comment": "set up display address"},
{"address": "0xCDB0", "comment": "subtract bytes per character row from this"},
{"address": "0xCDB3", "comment": "wraparound if necessary"},
{"address": "0xCDB5", "comment": "screen RAM size hi byte"},
{"address": "0xCDB8", "comment": "store A"},
{"address": "0xCDBA", "comment": "X"},
{"address": "0xCDBC", "comment": "A again"},
{"address": "0xCDBE", "comment": "if C set there was no wraparound so CDC6"},
{"address": "0xCDC0", "comment": "copy line to new position"},
{"address": "0xCDC6", "comment": "subtract bytes per character row from X/A"},
{"address": "0xCDC9", "comment": "if a result is outside screen RAM CDC0"},
{"address": "0xCDCB", "comment": "perform a copy"},
{"address": "0xCDCE", "comment": "set write pointer from read pointer"},
{"address": "0xCDD6", "comment": "decrement window height"},
{"address": "0xCDD8", "comment": "and if not zero CDB0"},
{"address": "0xCDDA", "comment": "point to workspace"},
{"address": "0xCDDC", "comment": "point to text column/line"},
{"address": "0xCDDE", "comment": "number of bytes to swap"},
{"address": "0xCDE0", "comment": "exchange (328/9)+Y with (318/9)+X"},
{"address": "0xCDE2", "comment": "point to graphics cursor"},
{"address": "0xCDE4", "comment": "point to last graphics cursor"},
{"address": "0xCDE6", "comment": "A =4"},
{"address": "0xCDE8", "comment": "store it as loop counter"},
{"address": "0xCDEA", "comment": "get byte"},
{"address": "0xCDED", "comment": "store it"},
{"address": "0xCDEE", "comment": "get byte pointed to by Y"},
{"address": "0xCDF1", "comment": "put it in 300+X"},
{"address": "0xCDF4", "comment": "get back A"},
{"address": "0xCDF5", "comment": "put it in 300+Y"},
{"address": "0xCDF8", "comment": "increment pointers"},
{"address": "0xCDFA", "comment": "decrement loop counter"},
{"address": "0xCDFC", "comment": "and if not 0 do it again"},
{"address": "0xCDFE", "comment": "and exit"},
{"address": "0xCDFF", "comment": "exchange line and column cursors with workspace copies"},
{"address": "0xCE02", "comment": "top of text window"},
{"address": "0xCE05", "comment": "current text line"},
{"address": "0xCE08", "comment": "set up display address"},
{"address": "0xCE0B", "comment": "add bytes per char. row"},
{"address": "0xCE11", "comment": "screen RAM size hi byte"},
{"address": "0xCE14", "comment": "(&DA)=X/A"},
{"address": "0xCE18", "comment": "&DC=A"},
{"address": "0xCE1C", "comment": "copy line to new position"},
{"address": "0xCE1F", "comment": "exit"},
{"address": "0xCE22", "comment": "add bytes per char. row"},
{"address": "0xCE25", "comment": "if outside screen RAM CE1C"},
{"address": "0xCE27", "comment": "perform a copy"},
{"address": "0xCE32", "comment": "decrement window height"},
{"address": "0xCE34", "comment": "CE0B if not 0"},
{"address": "0xCE36", "comment": "exchange text column/linelse CDDA"},
{"address": "0xCE38", "comment": "text window width hi (bytes)"},
{"address": "0xCE3B", "comment": "if no more than 256 bytes to copy X=0 so CE4D"},
{"address": "0xCE3D", "comment": "Y=0 to set loop counter"},
{"address": "0xCE3F", "comment": "copy 256 bytes"},
{"address": "0xCE44", "comment": "Till Y=0 again"},
{"address": "0xCE46", "comment": "increment hi bytes"},
{"address": "0xCE4A", "comment": "decrement window width"},
{"address": "0xCE4B", "comment": "if not 0 go back and do loop again"},
{"address": "0xCE4D", "comment": "text window width lo (bytes)"},
{"address": "0xCE50", "comment": "if Y=0 CE5A"},
{"address": "0xCE52", "comment": "else Y=Y-1"},
{"address": "0xCE53", "comment": "copy Y bytes"},
{"address": "0xCE57", "comment": "A=Y"},
{"address": "0xCE58", "comment": "if not 0 CE52"},
{"address": "0xCE5A", "comment": "and exit"},
{"address": "0xCE5B", "comment": "exchange text column/line with workspace"},
{"address": "0xCE5E", "comment": "set carry"},
{"address": "0xCE5F", "comment": "bottom margin"},
{"address": "0xCE62", "comment": "top of text window"},
{"address": "0xCE65", "comment": "store it"},
{"address": "0xCE67", "comment": "set text column to left hand column"},
{"address": "0xCE69", "comment": "get back return address"},
{"address": "0xCE6B", "comment": "exchange text column/line with workspace"},
{"address": "0xCE6E", "comment": "text window left"},
{"address": "0xCE71", "comment": "Jump CEE3 always!"},
{"address": "0xCE73", "comment": "get back A"},
{"address": "0xCE75", "comment": "push A"},
{"address": "0xCE76", "comment": "set carry"},
{"address": "0xCE77", "comment": "text window right"},
{"address": "0xCE7A", "comment": "text window left"},
{"address": "0xCE7F", "comment": "bytes per character to set loop counter"},
{"address": "0xCE82", "comment": "copy loop"},
{"address": "0xCE8A", "comment": "X=2"},
{"address": "0xCE8C", "comment": "clear carry"},
{"address": "0xCE8F", "comment": "bytes per character"},
{"address": "0xCE98", "comment": "if this remains in screen RAM OK"},
{"address": "0xCE9A", "comment": "else wrap around screen"},
{"address": "0xCE9B", "comment": "screen RAM size hi byte"},
{"address": "0xCEA0", "comment": "X=X-2"},
{"address": "0xCEA2", "comment": "if X=0 adjust second set of pointers"},
{"address": "0xCEA4", "comment": "decrement window width"},
{"address": "0xCEA6", "comment": "and if still +ve do it all again"},
{"address": "0xCEA8", "comment": "get back A"},
{"address": "0xCEA9", "comment": "and store it"},
{"address": "0xCEAB", "comment": "then exit"},
{"address": "0xCEAC", "comment": "text column"},
{"address": "0xCEAF", "comment": "save it"},
{"address": "0xCEB0", "comment": "set text column to left hand column"},
{"address": "0xCEB3", "comment": "set up display address"},
{"address": "0xCEB6", "comment": "set carry"},
{"address": "0xCEB7", "comment": "text window right"},
{"address": "0xCEBA", "comment": "text window left"},
{"address": "0xCEBD", "comment": "as window width"},
{"address": "0xCEBF", "comment": "background text colour"},
{"address": "0xCEC2", "comment": "bytes per character"},
{"address": "0xCEC5", "comment": "Y=Y-1 decrementing loop counter"},
{"address": "0xCEC6", "comment": "store background colour at this point on screen"},
{"address": "0xCEC8", "comment": "if Y<>0 do it again"},
{"address": "0xCECA", "comment": "else A=X"},
{"address": "0xCECB", "comment": "clear carry to add"},
{"address": "0xCECC", "comment": "bytes per character"},
{"address": "0xCECF", "comment": "X=A restoring it"},
{"address": "0xCED0", "comment": "get hi byte"},
{"address": "0xCED2", "comment": "Add carry if any"},
{"address": "0xCED4", "comment": "if +ve CeDA"},
{"address": "0xCED6", "comment": "else wrap around"},
{"address": "0xCED7", "comment": "screen RAM size hi byte"},
{"address": "0xCEDA", "comment": "restore D8/9"},
{"address": "0xCEDE", "comment": "decrement window width"},
{"address": "0xCEE0", "comment": "ind if not 0 do it all again"},
{"address": "0xCEE2", "comment": "get back A"},
{"address": "0xCEE3", "comment": "restore text column"},
{"address": "0xCEE6", "comment": "set carry"},
{"address": "0xCEE7", "comment": "and exit"},
{"address": "0xCEE8", "comment": "text column"},
{"address": "0xCEEB", "comment": "text window left"},
{"address": "0xCEEE", "comment": "if less than left margin return with carry set"},
{"address": "0xCEF0", "comment": "text window right"},
{"address": "0xCEF3", "comment": "if equal to right margin thats OK"},
{"address": "0xCEF5", "comment": "if greater than right margin return with carry set"},
{"address": "0xCEF7", "comment": "current text line"},
{"address": "0xCEFA", "comment": "top of text window"},
{"address": "0xCEFD", "comment": "if less than top margin"},
{"address": "0xCEFF", "comment": "bottom margin"},
{"address": "0xCF02", "comment": "set up display address"},
{"address": "0xCF04", "comment": "or greater than bottom margin return with carry set"},
{"address": "0xCF06", "comment": "current text line"},
{"address": "0xCF09", "comment": "A=A*2"},
{"address": "0xCF0A", "comment": "Y=A"},
{"address": "0xCF0B", "comment": "get CRTC multiplication table pointer"},
{"address": "0xCF0D", "comment": "&D9=A"},
{"address": "0xCF0F", "comment": "Y=Y+1"},
{"address": "0xCF10", "comment": "A=2"},
{"address": "0xCF12", "comment": "memory map type"},
{"address": "0xCF15", "comment": "save flags"},
{"address": "0xCF16", "comment": "get CRTC multiplication table pointer"},
{"address": "0xCF18", "comment": "pull flags"},
{"address": "0xCF1B", "comment": "&D9=&D9/2"},
{"address": "0xCF1D", "comment": "A=A/2 +(128*carry)"},
{"address": "0xCF1E", "comment": "window area start address lo"},
{"address": "0xCF21", "comment": "store it"},
{"address": "0xCF25", "comment": "window area start address hi"},
{"address": "0xCF29", "comment": "text column"},
{"address": "0xCF2C", "comment": "bytes per character"},
{"address": "0xCF2F", "comment": "X=X-1"},
{"address": "0xCF30", "comment": "if X=0 mode 7 CF44"},
{"address": "0xCF32", "comment": "is it mode 1 or mode 5?"},
{"address": "0xCF34", "comment": "yes CF39 with carry set"},
{"address": "0xCF36", "comment": "if its less (mode 0,3,4,6) CF3A"},
{"address": "0xCF38", "comment": "A=A*16 if entered here (mode 2)"},
{"address": "0xCF39", "comment": "A=A*8 if entered here"},
{"address": "0xCF3A", "comment": "A=A*4 if entered here"},
{"address": "0xCF3C", "comment": "if carry clear"},
{"address": "0xCF3E", "comment": "Y=Y+2"},
{"address": "0xCF40", "comment": "A=A*2"},
{"address": "0xCF41", "comment": "if carry clear add to &D8"},
{"address": "0xCF43", "comment": "if not Y=Y+1"},
{"address": "0xCF44", "comment": "clear carry"},
{"address": "0xCF45", "comment": "add to &D8"},
{"address": "0xCF47", "comment": "and store it"},
{"address": "0xCF49", "comment": "text cursor 6845 address"},
{"address": "0xCF4C", "comment": "X=A"},
{"address": "0xCF4D", "comment": "A=Y"},
{"address": "0xCF4E", "comment": "Add carry if set"},
{"address": "0xCF50", "comment": "text cursor 6845 address"},
{"address": "0xCF53", "comment": "if less than &800 goto &CF59"},
{"address": "0xCF55", "comment": "else wrap around"},
{"address": "0xCF56", "comment": "screen RAM size hi byte"},
{"address": "0xCF59", "comment": "store in high byte"},
{"address": "0xCF5B", "comment": "clear carry"},
{"address": "0xCF5C", "comment": "and exit"},
{"address": "0xCF5D", "comment": "foreground graphics colour"},
{"address": "0xCF60", "comment": "foreground graphics plot mode (GCOL n)"},
{"address": "0xCF63", "comment": "set graphics byte mask in &D4/5"},
{"address": "0xCF66", "comment": "copy (324/7) graphics cursor to workspace (328/B)"},
{"address": "0xCF69", "comment": "Y=0"},
{"address": "0xCF6B", "comment": "&DC=Y"},
{"address": "0xCF6D", "comment": "Y=&DC"},
{"address": "0xCF6F", "comment": "get pattern byte"},
{"address": "0xCF71", "comment": "if A=0 CF86"},
{"address": "0xCF73", "comment": "else &DD=A"},
{"address": "0xCF75", "comment": "and if >0 CF7A"},
{"address": "0xCF77", "comment": "else display a pixel"},
{"address": "0xCF7A", "comment": "current horizontal graphics cursor"},
{"address": "0xCF7F", "comment": "current horizontal graphics cursor"},
{"address": "0xCF82", "comment": "&DD=&DD*2"},
{"address": "0xCF84", "comment": "and if<>0 CF75"},
{"address": "0xCF86", "comment": "point to workspace"},
{"address": "0xCF88", "comment": "point to horizontal graphics cursor"},
{"address": "0xCF8A", "comment": "0300/1+Y=0300/1+X"},
{"address": "0xCF8D", "comment": "current vertical graphics cursor"},
{"address": "0xCF92", "comment": "current vertical graphics cursor"},
{"address": "0xCF95", "comment": "current vertical graphics cursor"},
{"address": "0xCF9B", "comment": "if Y<8 then do loop again"},
{"address": "0xCF9D", "comment": "else"},
{"address": "0xCF9F", "comment": "point to workspace"},
{"address": "0xCFA1", "comment": "point to graphics cursor"},
{"address": "0xCFA3", "comment": "(&300/3+Y)=(&300/3+X)"},
{"address": "0xCFA6", "comment": "point to graphics window TOP"},
{"address": "0xCFA8", "comment": "point to workspace"},
{"address": "0xCFAA", "comment": "0300/1+Y=0300/1+X"},
{"address": "0xCFAD", "comment": "X=0 point to graphics window left"},
{"address": "0xCFAF", "comment": "Y=&24"},
{"address": "0xCFB1", "comment": "0300/1+Y=0300/1+X"},
{"address": "0xCFB4", "comment": "set up external coordinates for graphics"},
{"address": "0xCFB7", "comment": "Number of logical colours less 1"},
{"address": "0xCFBA", "comment": "Zero, MODE 7, jump to CFDC"},
{"address": "0xCFBC", "comment": "Set up character definition pointers"},
{"address": "0xCFBF", "comment": "Get number of logical colours less 1 again"},
{"address": "0xCFC2", "comment": "Get VDU status byte"},
{"address": "0xCFC4", "comment": "Test bit 5 for printing at graphics cursor"},
{"address": "0xCFC6", "comment": "If set, jump to CF5D for graphics printing"},
{"address": "0xCFC8", "comment": "Prepare Y=7 for 8 pixel lines"},
{"address": "0xCFCA", "comment": "Test X=3"},
{"address": "0xCFCC", "comment": "If four-colour mode, jump to CFEE"},
{"address": "0xCFCE", "comment": "If >3, jump to D01E to deal with 16 colours"},
{"address": "0xCFD0", "comment": "Get character pixel line"},
{"address": "0xCFD2", "comment": "Mask if foreground=background"},
{"address": "0xCFD4", "comment": "Toggle for inverted pixels"},
{"address": "0xCFD6", "comment": "Write to screen"},
{"address": "0xCFD8", "comment": "Y=Y-1"},
{"address": "0xCFD9", "comment": "Loop for all 8 pixel lines"},
{"address": "0xCFDB", "comment": "And exit"},
{"address": "0xCFDC", "comment": "Y=2 to check 3 teletext characters"},
{"address": "0xCFDE", "comment": "Compare with teletext conversion table"},
{"address": "0xCFE1", "comment": "If equal jump to CFE9 to convert it"},
{"address": "0xCFE3", "comment": "Else Y=Y-1"},
{"address": "0xCFE4", "comment": "And loop to check all three characters"},
{"address": "0xCFE6", "comment": "Write byte to screen, X=0 as number of colours"},
{"address": "0xCFE8", "comment": "And exit"},
{"address": "0xCFE9", "comment": "Convert with teletext conversion table"},
{"address": "0xCFEC", "comment": "And write it to screen"},
{"address": "0xCFEE", "comment": "Get character pixel line"},
{"address": "0xCFF0", "comment": "Save it"},
{"address": "0xCFF1", "comment": "Move high nybble to low nybble"},
{"address": "0xCFF5", "comment": "Index into colour table"},
{"address": "0xCFF6", "comment": "Get 4-colour pixel mask for this nybble"},
{"address": "0xCFF9", "comment": "Mask where foreground=background"},
{"address": "0xCFFB", "comment": "Toggle where pixels inverted"},
{"address": "0xCFFD", "comment": "Write to screen"},
{"address": "0xCFFF", "comment": "A=Y"},
{"address": "0xD000", "comment": "Clear carry"},
{"address": "0xD001", "comment": "Add 8 to point to next columns of bytes"},
{"address": "0xD003", "comment": "Y=A"},
{"address": "0xD004", "comment": "Get pixel line back"},
{"address": "0xD005", "comment": "Keep bottom nybble"},
{"address": "0xD007", "comment": "Index into colour table"},
{"address": "0xD008", "comment": "Get 4-colour pixel mask for this nybble"},
{"address": "0xD00B", "comment": "Mask where foreground=background"},
{"address": "0xD00D", "comment": "Toggle where pixels inverted"},
{"address": "0xD00F", "comment": "Write to screen"},
{"address": "0xD011", "comment": "A=Y"},
{"address": "0xD012", "comment": "A=A-9, move pointer back to previous column and decrement"},
{"address": "0xD014", "comment": "Y=A"},
{"address": "0xD015", "comment": "if +ve do loop again"},
{"address": "0xD017", "comment": "And exit"},
{"address": "0xD018", "comment": "Y=Y-&21"},
{"address": "0xD01B", "comment": "IF Y IS negative then RETURN"},
{"address": "0xD01D", "comment": "else A=Y"},
{"address": "0xD01E", "comment": "Get character pixel line"},
{"address": "0xD020", "comment": "Store it in workspace"},
{"address": "0xD022", "comment": "set carry"},
{"address": "0xD023", "comment": "A=0"},
{"address": "0xD025", "comment": "carry now occupies bit 0 of DC"},
{"address": "0xD027", "comment": "when DC=0 again D018 to deal with next pattern byte"},
{"address": "0xD029", "comment": "get bit 7 from &DC into A bit 0"},
{"address": "0xD02A", "comment": "rotate again to get second"},
{"address": "0xD02C", "comment": "bit into A"},
{"address": "0xD02D", "comment": "and store result in X"},
{"address": "0xD02E", "comment": "multiply by &55 using look up table"},
{"address": "0xD031", "comment": "and set colour factors"},
{"address": "0xD035", "comment": "and store result"},
{"address": "0xD037", "comment": "clear carry"},
{"address": "0xD038", "comment": "Y=Y+8 moving screen RAM pointer on 8 bytes"},
{"address": "0xD03C", "comment": "loop to D023 to deal with next bit pair"},
{"address": "0xD03E", "comment": "23456780  C holds 1"},
{"address": "0xD03F", "comment": "34567801  C holds 2"},
{"address": "0xD040", "comment": "45678012  C holds 3"},
{"address": "0xD041", "comment": "save this pattern"},
{"address": "0xD043", "comment": "12"},
{"address": "0xD045", "comment": "00000123 C=0"},
{"address": "0xD046", "comment": "X=A=0 - 7"},
{"address": "0xD047", "comment": "A=00000023"},
{"address": "0xD049", "comment": "A=&BF,C0 or C1"},
{"address": "0xD04B", "comment": "this is used as a pointer"},
{"address": "0xD04C", "comment": "A=&80/2^X i.e.1,2,4,8,&10,&20,&40, or &80"},
{"address": "0xD04F", "comment": "with font flag"},
{"address": "0xD052", "comment": "if 0 D057"},
{"address": "0xD054", "comment": "else get hi byte from table"},
{"address": "0xD057", "comment": "store Y"},
{"address": "0xD059", "comment": "get back pattern"},
{"address": "0xD05B", "comment": "convert to 45678000"},
{"address": "0xD05D", "comment": "and restore it"},
{"address": "0xD05F", "comment": "exit"},
{"address": "0xD060", "comment": "X=>coords in VDU queue"},
{"address": "0xD062", "comment": "Translate coordinates"},
{"address": "0xD065", "comment": "Get plot action"},
{"address": "0xD068", "comment": "Test for 4 for MOVE absolute, if so jump to D0D9"},
{"address": "0xD06A", "comment": "to quickly finish, without testing for UKVDUV"},
{"address": "0xD06C", "comment": "Prepare Y=5 for GCOL 5 - no action"},
{"address": "0xD06E", "comment": "Mask plot action to get colour mode in bit 0 and 1"},
{"address": "0xD070", "comment": "If 0, move without plotting, but still test fr UKVDUV"},
{"address": "0xD072", "comment": "Move bit 0 of action into Cy"},
{"address": "0xD073", "comment": "If set, action=%01 or %11, jump to D078 to use colour"},
{"address": "0xD075", "comment": "Set Y=4 for GCOL 4 - invert pixel"},
{"address": "0xD076", "comment": "Skip forward with %10 to invert current colour"},
{"address": "0xD078", "comment": "X=A, X=0 for foreground colour, X=1 for background colour"},
{"address": "0xD079", "comment": "Get foreground or background GCOL action"},
{"address": "0xD07C", "comment": "Get foreground or background graphics colour"},
{"address": "0xD07F", "comment": "X=colour"},
{"address": "0xD080", "comment": "Set up plot masks in D4/5 from Y=GCOL action, X=colour"},
{"address": "0xD083", "comment": "Get plot action"},
{"address": "0xD086", "comment": "If &80-&FF, not implemented, jump to D0AB to pass to UKVDUV"},
{"address": "0xD088", "comment": "Test bit 6"},
{"address": "0xD089", "comment": "Bit 6 is 0, plot action is 0-63, jump to D0C6 to draw line"},
{"address": "0xD08B", "comment": "Mask out colour and abs/rel modes in bottom nybble"},
{"address": "0xD08D", "comment": "Shift action into top three bits"},
{"address": "0xD08E", "comment": "%01000xxx, plot action 64-71, jump to D0D6 to plot a point"},
{"address": "0xD090", "comment": "Toggle bit 6 of PLOT action * 4"},
{"address": "0xD092", "comment": "%01010xxx, plot action 80-87, jump to D0A8 to fill triangle"},
{"address": "0xD094", "comment": "Save A"},
{"address": "0xD095", "comment": "copy 0320/3 to 0324/7 setting XY in current graphics"},
{"address": "0xD098", "comment": "Get back A - PLOT action * 4"},
{"address": "0xD099", "comment": "Toggle bit 6 and bit 5"},
{"address": "0xD09B", "comment": "%01001xxx, plot actions 72-78, jump to D0AE for lateral fill"},
{"address": "0xD09F", "comment": "Not %01011xxx, jump to pass to UKVDUV"},
{"address": "0xD0A1", "comment": "Set A=2 for..."},
{"address": "0xD0A3", "comment": "Store it in workspace"},
{"address": "0xD0A5", "comment": "And jump to D506 to do line blanking"},
{"address": "0xD0A8", "comment": "Jump to fill triangle routine"},
{"address": "0xD0AB", "comment": "Pass to UKVDUV - VDU extension vector"},
{"address": "0xD0AE", "comment": "Store zero in workspace"},
{"address": "0xD0B0", "comment": "Jump to do lateral fill"},
{"address": "0xD0B3", "comment": "A=colour"},
{"address": "0xD0B4", "comment": "ORA colour with GCOL action table byte"},
{"address": "0xD0B7", "comment": "EOR with following byte"},
{"address": "0xD0BA", "comment": "Store as plot mask"},
{"address": "0xD0BC", "comment": "A=colour"},
{"address": "0xD0C3", "comment": "Store as"},
{"address": "0xD0C5", "comment": "exit with masks in &D4/5"},
{"address": "0xD0C6", "comment": "shift left again"},
{"address": "0xD0C7", "comment": "if -ve options are in range 32-63 not implemented"},
{"address": "0xD0C9", "comment": "shift left twice more"},
{"address": "0xD0CB", "comment": "if still +ve type is 0-7 or 16-23 so D0D0"},
{"address": "0xD0CD", "comment": "else display start point"},
{"address": "0xD0D0", "comment": "perform calculations and draw line"},
{"address": "0xD0D3", "comment": "finish"},
{"address": "0xD0D6", "comment": "plot a point"},
{"address": "0xD0D9", "comment": "swap current and last graphics position"},
{"address": "0xD0DC", "comment": "Y=&24"},
{"address": "0xD0DE", "comment": "X=&20"},
{"address": "0xD0E0", "comment": "copy parameters to 324/7 (300/3 +Y)"},
{"address": "0xD0E3", "comment": "X=>current graphics position"},
{"address": "0xD0E5", "comment": "Check window and calculate pixel address"},
{"address": "0xD0E8", "comment": "Inside graphics windows, skip to plot it"},
{"address": "0xD0EA", "comment": "Outside graphics winsow, exit"},
{"address": "0xD0EB", "comment": "Check window and calculate address for PLOT coord"},
{"address": "0xD0EE", "comment": "If outside window, skip to exit"},
{"address": "0xD0F0", "comment": "Get graphics scan line"},
{"address": "0xD0F3", "comment": "Get bits to modify for this pixel"},
{"address": "0xD0F7", "comment": "Get byte from screen"},
{"address": "0xD0F9", "comment": "Save it for a moment"},
{"address": "0xD101", "comment": "Write it to screen"},
{"address": "0xD103", "comment": "And exit"},
{"address": "0xD104", "comment": "Get byte from screen"},
{"address": "0xD106", "comment": "Mask in bits to set"},
{"address": "0xD108", "comment": "Toggle any bits to invert"},
{"address": "0xD10A", "comment": "Store back to screen"},
{"address": "0xD10C", "comment": "And exit"},
{"address": "0xD10D", "comment": "X=&24"},
{"address": "0xD10F", "comment": "Y=0"},
{"address": "0xD111", "comment": "&DA=0"},
{"address": "0xD113", "comment": "Y=2"},
{"address": "0xD115", "comment": "check vertical graphics position 326/7"},
{"address": "0xD118", "comment": "DATA is set in &DA bits 0 and 1 then shift left"},
{"address": "0xD11A", "comment": "twice to make room for next pass"},
{"address": "0xD11C", "comment": "X=&22"},
{"address": "0xD11E", "comment": "Y=0"},
{"address": "0xD120", "comment": "left and right margins 300/1, 304/5"},
{"address": "0xD123", "comment": "X=X+2"},
{"address": "0xD125", "comment": "A=&DA"},
{"address": "0xD127", "comment": "exit"},
{"address": "0xD128", "comment": "check for window violation"},
{"address": "0xD12B", "comment": "300/1 +Y > 302/3+X"},
{"address": "0xD12E", "comment": "then window fault"},
{"address": "0xD134", "comment": "so D146"},
{"address": "0xD136", "comment": "check other windows"},
{"address": "0xD142", "comment": "if no violation exit"},
{"address": "0xD144", "comment": "else DA=DA+1"},
{"address": "0xD146", "comment": "DA=DA+1"},
{"address": "0xD148", "comment": "and exit  DA=0 no problems DA=1 first check 2, 2nd"},
{"address": "0xD149", "comment": "A=&FF"},
{"address": "0xD14B", "comment": "then &D150"},
{"address": "0xD14D", "comment": "get first parameter in plot"},
{"address": "0xD150", "comment": "store in &DA"},
{"address": "0xD152", "comment": "Y=2"},
{"address": "0xD154", "comment": "set up vertical coordinates/2"},
{"address": "0xD157", "comment": "/2 again to convert 1023 to 0-255 for internal use"},
{"address": "0xD15A", "comment": "Y=0"},
{"address": "0xD15C", "comment": "X=x-2"},
{"address": "0xD15E", "comment": "set up horiz. coordinates/2 this is OK for mode0,4"},
{"address": "0xD161", "comment": "get number of pixels/byte (-1)"},
{"address": "0xD164", "comment": "if Y=3 (modes 1 and 5)"},
{"address": "0xD166", "comment": "D16D"},
{"address": "0xD168", "comment": "for modes 0 & 4 this is 7 so D170"},
{"address": "0xD16A", "comment": "for other modes divide by 2 twice"},
{"address": "0xD16D", "comment": "divide by 2"},
{"address": "0xD170", "comment": "get screen display type"},
{"address": "0xD173", "comment": "if not 0 (modes 3-7) divide by 2 again"},
{"address": "0xD175", "comment": "and exit"},
{"address": "0xD176", "comment": "clear carry"},
{"address": "0xD177", "comment": "get &DA"},
{"address": "0xD179", "comment": "if bit 2=0"},
{"address": "0xD17B", "comment": "then D186 to calculate relative coordinates"},
{"address": "0xD17D", "comment": "else get coordinate"},
{"address": "0xD184", "comment": "and goto D194"},
{"address": "0xD186", "comment": "get coordinate"},
{"address": "0xD189", "comment": "add cursor position"},
{"address": "0xD18C", "comment": "save it"},
{"address": "0xD190", "comment": "add cursor"},
{"address": "0xD193", "comment": "clear carry"},
{"address": "0xD194", "comment": "save new cursor"},
{"address": "0xD197", "comment": "add graphics origin"},
{"address": "0xD19A", "comment": "store it"},
{"address": "0xD19D", "comment": "get back lo byte"},
{"address": "0xD19E", "comment": "save it in new cursor lo"},
{"address": "0xD1A1", "comment": "clear carry"},
{"address": "0xD1A2", "comment": "add to graphics orgin"},
{"address": "0xD1A5", "comment": "store it"},
{"address": "0xD1A8", "comment": "if carry set"},
{"address": "0xD1AA", "comment": "increment hi byte as you would expect!"},
{"address": "0xD1AD", "comment": "get hi byte"},
{"address": "0xD1B1", "comment": "divide by 2"},
{"address": "0xD1B7", "comment": "and exit"},
{"address": "0xD1B8", "comment": "Y=10"},
{"address": "0xD1BA", "comment": "copy 324/7 to 310/3 i.e.current graphics cursor"},
{"address": "0xD1BD", "comment": "X=2"},
{"address": "0xD1BF", "comment": "Y=2"},
{"address": "0xD1C1", "comment": "multiply 312/3 by 4 and subtract graphics origin"},
{"address": "0xD1C4", "comment": "X=0"},
{"address": "0xD1C6", "comment": "Y=4"},
{"address": "0xD1C8", "comment": "get  number of pixels/byte"},
{"address": "0xD1CB", "comment": "Y=Y-1"},
{"address": "0xD1CC", "comment": "divide by 2"},
{"address": "0xD1CD", "comment": "if result not 0 D1CB"},
{"address": "0xD1CF", "comment": "else get screen display type"},
{"address": "0xD1D2", "comment": "and if 0 D1D5"},
{"address": "0xD1D5", "comment": "multiply coordinate by 2"},
{"address": "0xD1DB", "comment": "Y-Y-1"},
{"address": "0xD1DC", "comment": "and if Y<>0 do it again"},
{"address": "0xD1DE", "comment": "set carry"},
{"address": "0xD1E2", "comment": "increment X"},
{"address": "0xD1E3", "comment": "get current graphics position in external coordinates"},
{"address": "0xD1E6", "comment": "subtract origin"},
{"address": "0xD1E9", "comment": "store in graphics position"},
{"address": "0xD1EC", "comment": "and exit"},
{"address": "0xD1ED", "comment": "Set X and Y spans in workspace 328/9 32A/B"},
{"address": "0xD1F0", "comment": "compare spans"},
{"address": "0xD1F3", "comment": "if result -ve spans are different in sign so"},
{"address": "0xD1F6", "comment": "goto D207"},
{"address": "0xD1F8", "comment": "else A=hi byte of difference in spans"},
{"address": "0xD204", "comment": "and goto D214"},
{"address": "0xD207", "comment": "A = hi byte of SUM of spans"},
{"address": "0xD214", "comment": "A=A/2"},
{"address": "0xD215", "comment": "X=0"},
{"address": "0xD21A", "comment": "if positive result D21E"},
{"address": "0xD21C", "comment": "else X=2"},
{"address": "0xD21E", "comment": "store it"},
{"address": "0xD220", "comment": "set up vector address"},
{"address": "0xD223", "comment": "in 35D"},
{"address": "0xD229", "comment": "and 35E"},
{"address": "0xD22C", "comment": "get hi byte of span"},
{"address": "0xD22F", "comment": "if +ve D235"},
{"address": "0xD231", "comment": "X=&24"},
{"address": "0xD233", "comment": "jump to D237"},
{"address": "0xD235", "comment": "X=&20"},
{"address": "0xD237", "comment": "store it"},
{"address": "0xD239", "comment": "Y=&2C"},
{"address": "0xD23B", "comment": "get X coordinate data or horizontal coord of"},
{"address": "0xD23E", "comment": "get back original X"},
{"address": "0xD240", "comment": "covert &20 to &24 and vice versa"},
{"address": "0xD247", "comment": "copy 330/1 to 300/1+X"},
{"address": "0xD24A", "comment": "get plot type"},
{"address": "0xD24D", "comment": "check bit 4"},
{"address": "0xD251", "comment": "move to bit 7"},
{"address": "0xD252", "comment": "store it"},
{"address": "0xD254", "comment": "X=&2C"},
{"address": "0xD256", "comment": "check for window violations"},
{"address": "0xD25B", "comment": "if none then D263"},
{"address": "0xD25D", "comment": "else set bit 6 of &DB"},
{"address": "0xD265", "comment": "check window violations again"},
{"address": "0xD268", "comment": "if bit 7 of &DC NOT set"},
{"address": "0xD26A", "comment": "D26D"},
{"address": "0xD26C", "comment": "else exit"},
{"address": "0xD26D", "comment": "X=&DE"},
{"address": "0xD26F", "comment": "if X=0 D273"},
{"address": "0xD271", "comment": "A=A/2"},
{"address": "0xD272", "comment": "A=A/2"},
{"address": "0xD273", "comment": "clear all but bit 2"},
{"address": "0xD275", "comment": "if bit 2 set D27E"},
{"address": "0xD277", "comment": "else A=X"},
{"address": "0xD278", "comment": "A=A or 4 setting bit 3"},
{"address": "0xD27A", "comment": "X=A"},
{"address": "0xD27B", "comment": "set 300/1+x to 330/1"},
{"address": "0xD27E", "comment": "more calcualtions"},
{"address": "0xD281", "comment": "A=&DE EOR 2"},
{"address": "0xD285", "comment": "X=A"},
{"address": "0xD286", "comment": "Y=A"},
{"address": "0xD287", "comment": "compare upper byte of spans"},
{"address": "0xD28D", "comment": "if signs are the same D290"},
{"address": "0xD28F", "comment": "else X=X+1"},
{"address": "0xD290", "comment": "get vector addresses and store 332/3"},
{"address": "0xD29C", "comment": "A=&7F"},
{"address": "0xD29E", "comment": "store it"},
{"address": "0xD2A1", "comment": "if bit 6 set"},
{"address": "0xD2A3", "comment": "the D2CE"},
{"address": "0xD2A5", "comment": "get VDU section number"},
{"address": "0xD2A8", "comment": "X=A"},
{"address": "0xD2A9", "comment": "set carry"},
{"address": "0xD2AA", "comment": "subtract coordinates"},
{"address": "0xD2B8", "comment": "Y=hi"},
{"address": "0xD2BA", "comment": "X=lo=A"},
{"address": "0xD2BB", "comment": "and if A+Ve D2C0"},
{"address": "0xD2BD", "comment": "negate Y/A"},
{"address": "0xD2C0", "comment": "X=A increment Y/A"},
{"address": "0xD2C1", "comment": "Y=Y+1"},
{"address": "0xD2C4", "comment": "X=X+1"},
{"address": "0xD2C5", "comment": "A=X"},
{"address": "0xD2C6", "comment": "if A=0 D2CA"},
{"address": "0xD2C8", "comment": "else Y=0"},
{"address": "0xD2CA", "comment": "&DF=Y"},
{"address": "0xD2CC", "comment": "if 0 then D2D7"},
{"address": "0xD2CE", "comment": "A=X"},
{"address": "0xD2CF", "comment": "A=A/4"},
{"address": "0xD2D1", "comment": "bit 1 set"},
{"address": "0xD2D5", "comment": "and store"},
{"address": "0xD2D7", "comment": "X=&2C"},
{"address": "0xD2E2", "comment": "X=X-1"},
{"address": "0xD2E3", "comment": "A=&3B"},
{"address": "0xD2E5", "comment": "if 0 D306"},
{"address": "0xD2E7", "comment": "else if +ve D2F9"},
{"address": "0xD2EC", "comment": "if bit 7=0 D2F3"},
{"address": "0xD2EE", "comment": "else decrement"},
{"address": "0xD2F1", "comment": "and if not 0 D316"},
{"address": "0xD2F6", "comment": "A=A*2"},
{"address": "0xD2F7", "comment": "if +ve D306"},
{"address": "0xD2FD", "comment": "calculate screen position"},
{"address": "0xD300", "comment": "get back original X"},
{"address": "0xD306", "comment": "byte mask for current graphics point"},
{"address": "0xD308", "comment": "and with graphics colour byte"},
{"address": "0xD30A", "comment": "or  with curent graphics cell line"},
{"address": "0xD30C", "comment": "store result"},
{"address": "0xD30E", "comment": "same again with next byte (hi??)"},
{"address": "0xD314", "comment": "then store it in current graphics line"},
{"address": "0xD316", "comment": "set carry"},
{"address": "0xD317", "comment": "A=&335/6-&337/8"},
{"address": "0xD326", "comment": "if carry set D339"},
{"address": "0xD33D", "comment": "if carry clear jump to VDU routine else D348"},
{"address": "0xD342", "comment": "Y=Y-1"},
{"address": "0xD343", "comment": "if + D348"},
{"address": "0xD345", "comment": "else d3d3 to advance pointers"},
{"address": "0xD348", "comment": "and JUMP (&35D)"},
{"address": "0xD34B", "comment": "Y=Y+1"},
{"address": "0xD34C", "comment": "if Y<>8"},
{"address": "0xD34E", "comment": "then D348"},
{"address": "0xD350", "comment": "else clear carry"},
{"address": "0xD351", "comment": "get address of top line of cuirrent graphics cell"},
{"address": "0xD353", "comment": "add number of bytes/character row"},
{"address": "0xD356", "comment": "store it"},
{"address": "0xD358", "comment": "do same for hibyte"},
{"address": "0xD35D", "comment": "if result -ve then we are above screen RAM"},
{"address": "0xD35F", "comment": "so"},
{"address": "0xD360", "comment": "subtract screen memory size hi"},
{"address": "0xD363", "comment": "store it this wraps around point to screen RAM"},
{"address": "0xD365", "comment": "Y=0"},
{"address": "0xD36A", "comment": "shift byte mask"},
{"address": "0xD36C", "comment": "if carry clear (&D1 was +ve) goto D348"},
{"address": "0xD36E", "comment": "else reset pointers"},
{"address": "0xD371", "comment": "and off to do more"},
{"address": "0xD374", "comment": "shift byte mask"},
{"address": "0xD376", "comment": "if carry clear (&D1 was +ve) goto D348"},
{"address": "0xD378", "comment": "else reset pointers"},
{"address": "0xD37B", "comment": "and off to do more"},
{"address": "0xD37E", "comment": "Y=Y-1"},
{"address": "0xD37F", "comment": "if +ve D38D"},
{"address": "0xD381", "comment": "advance pointers"},
{"address": "0xD384", "comment": "goto D38D normally"},
{"address": "0xD386", "comment": "shift byte mask"},
{"address": "0xD388", "comment": "if carry clear (&D1 was +ve) goto D348"},
{"address": "0xD38A", "comment": "else reset pointers"},
{"address": "0xD38D", "comment": "pull flags"},
{"address": "0xD38E", "comment": "X=X+1"},
{"address": "0xD38F", "comment": "if X>0 D395"},
{"address": "0xD391", "comment": "else increment &DD"},
{"address": "0xD393", "comment": "and if not 0 D39F"},
{"address": "0xD395", "comment": "else if BIT 6 = 1"},
{"address": "0xD397", "comment": "goto D3A0"},
{"address": "0xD399", "comment": "if BIT 7=1 D3D0"},
{"address": "0xD39B", "comment": "else Decrement &DF"},
{"address": "0xD39D", "comment": "and if not Zero D3D0"},
{"address": "0xD39F", "comment": "else return"},
{"address": "0xD3A0", "comment": "A=&DE"},
{"address": "0xD3A2", "comment": "&DC=X"},
{"address": "0xD3A4", "comment": "clear all but bit 1"},
{"address": "0xD3A6", "comment": "X=A"},
{"address": "0xD3A7", "comment": "and if carry set goto D3C2"},
{"address": "0xD3A9", "comment": "if Bit 7 of &DE =1"},
{"address": "0xD3AB", "comment": "then D3B7"},
{"address": "0xD3AD", "comment": "else increment"},
{"address": "0xD3B0", "comment": "and if not 0 D3C2"},
{"address": "0xD3B2", "comment": "else increment hi byte"},
{"address": "0xD3B5", "comment": "and if carry clear D3C2"},
{"address": "0xD3B7", "comment": "esle A=32C,X"},
{"address": "0xD3BA", "comment": "and if not 0 D3BF"},
{"address": "0xD3BC", "comment": "decrement hi byte"},
{"address": "0xD3BF", "comment": "decrement lo byte"},
{"address": "0xD3C2", "comment": "A=X"},
{"address": "0xD3C3", "comment": "invert bit 2"},
{"address": "0xD3C5", "comment": "X=A"},
{"address": "0xD3C6", "comment": "Increment 32C/D"},
{"address": "0xD3CE", "comment": "X=&DC"},
{"address": "0xD3D0", "comment": "jump to D2E3"},
{"address": "0xD3D3", "comment": "SET CARRY"},
{"address": "0xD3D4", "comment": "subtract number of bytes/line from address of"},
{"address": "0xD3D6", "comment": "top line of current graphics cell"},
{"address": "0xD3E0", "comment": "compare with bottom of screen memory"},
{"address": "0xD3E3", "comment": "if outside screen RAM"},
{"address": "0xD3E5", "comment": "add screen memory size to wrap it around"},
{"address": "0xD3E8", "comment": "store in current address of graphics cell top line"},
{"address": "0xD3EA", "comment": "Y=7"},
{"address": "0xD3EC", "comment": "and RETURN"},
{"address": "0xD3ED", "comment": "get current left colour mask"},
{"address": "0xD3F0", "comment": "store it"},
{"address": "0xD3F2", "comment": "get current top line of graphics cell"},
{"address": "0xD3F4", "comment": "ADD 7"},
{"address": "0xD3FC", "comment": "and return"},
{"address": "0xD3FD", "comment": "get right colour mask"},
{"address": "0xD400", "comment": "store it"},
{"address": "0xD402", "comment": "A=top line graphics cell low"},
{"address": "0xD404", "comment": "if not 0 D408"},
{"address": "0xD406", "comment": "else decrement hi byte"},
{"address": "0xD408", "comment": "subtract 9 (8 + carry)"},
{"address": "0xD40A", "comment": "and store in low byte"},
{"address": "0xD40C", "comment": "return"},
{"address": "0xD40D", "comment": "X=&28"},
{"address": "0xD40F", "comment": "Y=&20"},
{"address": "0xD414", "comment": "X=X+2"},
{"address": "0xD416", "comment": "Y=Y+2"},
{"address": "0xD418", "comment": "set carry"},
{"address": "0xD419", "comment": "subtract coordinates"},
{"address": "0xD42B", "comment": "and return"},
{"address": "0xD42C", "comment": "A=&DE"},
{"address": "0xD42E", "comment": "if A=0 D437"},
{"address": "0xD430", "comment": "X=&28"},
{"address": "0xD432", "comment": "Y=&2A"},
{"address": "0xD434", "comment": "exchange 300/1+Y with 300/1+X"},
{"address": "0xD437", "comment": "X=&28"},
{"address": "0xD439", "comment": "Y=&37"},
{"address": "0xD43B", "comment": "copy &300/4+Y to &300/4+X"},
{"address": "0xD43E", "comment": "set carry"},
{"address": "0xD43F", "comment": "X=&DE"},
{"address": "0xD441", "comment": "subtract 32C/D,X from 330/1"},
{"address": "0xD447", "comment": "partial answer in Y"},
{"address": "0xD44E", "comment": "if -ve D453"},
{"address": "0xD450", "comment": "else negate Y/A"},
{"address": "0xD453", "comment": "store A"},
{"address": "0xD455", "comment": "and Y"},
{"address": "0xD457", "comment": "X=&35"},
{"address": "0xD459", "comment": "get coordinates"},
{"address": "0xD46D", "comment": "if A is +ve RETURN"},
{"address": "0xD46F", "comment": "else negate Y/A"},
{"address": "0xD472", "comment": "store back again"},
{"address": "0xD47A", "comment": "get back A"},
{"address": "0xD47B", "comment": "and exit"},
{"address": "0xD47C", "comment": "A=8"},
{"address": "0xD47E", "comment": "copy 8 bytes"},
{"address": "0xD480", "comment": "Y=&30"},
{"address": "0xD482", "comment": "A=2"},
{"address": "0xD484", "comment": "copy 2 bytes"},
{"address": "0xD486", "comment": "copy 4 bytes from 324/7 to 328/B"},
{"address": "0xD49A", "comment": "and return"},
{"address": "0xD49B", "comment": "save A"},
{"address": "0xD49C", "comment": "A=Y"},
{"address": "0xD49D", "comment": "invert"},
{"address": "0xD49F", "comment": "Y=A"},
{"address": "0xD4A0", "comment": "get back A"},
{"address": "0xD4A1", "comment": "invert"},
{"address": "0xD4A3", "comment": "Y=Y+1"},
{"address": "0xD4A4", "comment": "if not 0 exit"},
{"address": "0xD4A6", "comment": "else"},
{"address": "0xD4A7", "comment": "add 1 to A"},
{"address": "0xD4A9", "comment": "return"},
{"address": "0xD4AA", "comment": "check window boundaries and set up screen pointer"},
{"address": "0xD4AD", "comment": "if A<>0 D4B7"},
{"address": "0xD4AF", "comment": "else get byte from current graphics cell"},
{"address": "0xD4B1", "comment": "compare with current background colour"},
{"address": "0xD4B4", "comment": "store it"},
{"address": "0xD4B6", "comment": "and RETURN"},
{"address": "0xD4B7", "comment": "get back return link"},
{"address": "0xD4B9", "comment": "increment current graphics cursor vertical lo"},
{"address": "0xD4BF", "comment": "check current screen state"},
{"address": "0xD4C2", "comment": "if A and &D1 <> 0 a plotted point has been found"},
{"address": "0xD4C4", "comment": "so D4B9"},
{"address": "0xD4C6", "comment": "X=0"},
{"address": "0xD4C8", "comment": "update pointers"},
{"address": "0xD4CB", "comment": "if 0 then D4FA"},
{"address": "0xD4CD", "comment": "else Y=graphics scan line"},
{"address": "0xD4D2", "comment": "if carry set D4D9"},
{"address": "0xD4D4", "comment": "else D574"},
{"address": "0xD4D7", "comment": "if carry clear D4FA"},
{"address": "0xD4D9", "comment": "else D3FD to pick up colour multiplier"},
{"address": "0xD4DC", "comment": "get graphics cell line"},
{"address": "0xD4DE", "comment": "EOR with background colour"},
{"address": "0xD4E1", "comment": "and store"},
{"address": "0xD4E3", "comment": "if not 0 D4F7"},
{"address": "0xD4E5", "comment": "else set carry"},
{"address": "0xD4E6", "comment": "A=X"},
{"address": "0xD4E7", "comment": "add pixels/byte"},
{"address": "0xD4EA", "comment": "and if carry clear D4F0"},
{"address": "0xD4EC", "comment": "else increment &DB"},
{"address": "0xD4EE", "comment": "and if +ve D4F7"},
{"address": "0xD4F0", "comment": "else X=A"},
{"address": "0xD4F1", "comment": "display a pixel"},
{"address": "0xD4F4", "comment": "set carry"},
{"address": "0xD4F5", "comment": "goto D4D9"},
{"address": "0xD4FA", "comment": "Y=0"},
{"address": "0xD503", "comment": "exchange 300/3 +Y with 300/3+X"},
{"address": "0xD506", "comment": "check screen pixel"},
{"address": "0xD509", "comment": "Y=5"},
{"address": "0xD50E", "comment": "A=x"},
{"address": "0xD50F", "comment": "if A<>0 d513"},
{"address": "0xD511", "comment": "else  &DB=&dB-1"},
{"address": "0xD513", "comment": "X=X-1"},
{"address": "0xD519", "comment": "update pointers"},
{"address": "0xD51C", "comment": "get byte from graphics line"},
{"address": "0xD51E", "comment": "EOR with background colour"},
{"address": "0xD521", "comment": "and store it"},
{"address": "0xD525", "comment": "If A-0 back to D514"},
{"address": "0xD527", "comment": "else A=&DA"},
{"address": "0xD529", "comment": "if A<>d53D"},
{"address": "0xD52B", "comment": "else set carry"},
{"address": "0xD52C", "comment": "A=x"},
{"address": "0xD52D", "comment": "Add number of pixels/byte"},
{"address": "0xD530", "comment": "and if carry clear D536"},
{"address": "0xD534", "comment": "and if +ve D53D"},
{"address": "0xD536", "comment": "get back X"},
{"address": "0xD537", "comment": "display a point"},
{"address": "0xD53A", "comment": "set carry"},
{"address": "0xD53B", "comment": "goto D519"},
{"address": "0xD548", "comment": "scale pointers"},
{"address": "0xD54B", "comment": "get byte mask"},
{"address": "0xD54D", "comment": "save it"},
{"address": "0xD54E", "comment": "clear carry"},
{"address": "0xD551", "comment": "get back A"},
{"address": "0xD552", "comment": "X=X+1"},
{"address": "0xD553", "comment": "if not 0 D559"},
{"address": "0xD555", "comment": "else inc &DB"},
{"address": "0xD557", "comment": "if +ve D56F"},
{"address": "0xD55B", "comment": "if Bit 7 D1 set D56F"},
{"address": "0xD55D", "comment": "else or withA"},
{"address": "0xD55F", "comment": "save result"},
{"address": "0xD560", "comment": "A=&D1"},
{"address": "0xD562", "comment": "test bits 6 and 7 of &DA"},
{"address": "0xD564", "comment": "save flags"},
{"address": "0xD565", "comment": "get into A"},
{"address": "0xD566", "comment": "EOR and DC"},
{"address": "0xD568", "comment": "save A"},
{"address": "0xD56C", "comment": "A=A EOR &D1 (byte mask)"},
{"address": "0xD56F", "comment": "store it"},
{"address": "0xD571", "comment": "and display a pixel"},
{"address": "0xD574", "comment": "A=0"},
{"address": "0xD576", "comment": "Clear carry"},
{"address": "0xD577", "comment": "goto D583 if carry clear"},
{"address": "0xD579", "comment": "X=X+1"},
{"address": "0xD57A", "comment": "If <>0 D580"},
{"address": "0xD57C", "comment": "else inc &DB"},
{"address": "0xD57E", "comment": "and if +ve d56F"},
{"address": "0xD580", "comment": "A=A*2"},
{"address": "0xD581", "comment": "if C set D58E"},
{"address": "0xD583", "comment": "else A=A OR (&D1)"},
{"address": "0xD585", "comment": "set V and M from &DA b6 b7"},
{"address": "0xD589", "comment": "A=A EOR &D1"},
{"address": "0xD58B", "comment": "/2"},
{"address": "0xD58C", "comment": "if carry clear D56F"},
{"address": "0xD58E", "comment": "*2"},
{"address": "0xD58F", "comment": "set carry"},
{"address": "0xD590", "comment": "to D56F"},
{"address": "0xD592", "comment": "Y/A=(&300/1 +X)-(&320/1)"},
{"address": "0xD5A0", "comment": "if result -ve D5A5"},
{"address": "0xD5A2", "comment": "or negate Y/A"},
{"address": "0xD5A5", "comment": "store A"},
{"address": "0xD5A7", "comment": "A=Y"},
{"address": "0xD5A8", "comment": "X=A"},
{"address": "0xD5AB", "comment": "exit"},
{"address": "0xD5AC", "comment": "Y=&DA"},
{"address": "0xD5AE", "comment": "A=X"},
{"address": "0xD5AF", "comment": "Y=A"},
{"address": "0xD5B0", "comment": "A=&DB"},
{"address": "0xD5B2", "comment": "if -ve D5B6"},
{"address": "0xD5B4", "comment": "A=0"},
{"address": "0xD5B6", "comment": "X=&DA"},
{"address": "0xD5B8", "comment": "if <>0 D5BD"},
{"address": "0xD5BA", "comment": "negate"},
{"address": "0xD5C0", "comment": "Y/A+(&300/1 +X)=(&320/1)"},
{"address": "0xD5CD", "comment": "return"},
{"address": "0xD5CE", "comment": "A=3"},
{"address": "0xD5D3", "comment": "A=7"},
{"address": "0xD5D5", "comment": "Save A"},
{"address": "0xD5D6", "comment": "exchange last 2 graphics cursor coordinates with"},
{"address": "0xD5D9", "comment": "convert to external coordinates"},
{"address": "0xD5DC", "comment": "X=3"},
{"address": "0xD5DE", "comment": "save A"},
{"address": "0xD5DF", "comment": "Y=A"},
{"address": "0xD5E0", "comment": "get graphics coordinate"},
{"address": "0xD5E3", "comment": "store it in OS buffer"},
{"address": "0xD5E5", "comment": "decrement Y and X"},
{"address": "0xD5E7", "comment": "if +ve do it again"},
{"address": "0xD5E9", "comment": "then Exit"},
{"address": "0xD5EA", "comment": "X=&20"},
{"address": "0xD5EC", "comment": "Y=&3E"},
{"address": "0xD5EE", "comment": "copy 300/7+X to 300/7+Y"},
{"address": "0xD5F1", "comment": "exchange 320/3 with 324/7 if 316/7=<322/3"},
{"address": "0xD5F4", "comment": "X=&14"},
{"address": "0xD5F6", "comment": "Y=&24"},
{"address": "0xD602", "comment": "calculate 032A/B-(324/5-320/1)"},
{"address": "0xD605", "comment": "and store"},
{"address": "0xD608", "comment": "result"},
{"address": "0xD60B", "comment": "set pointers"},
{"address": "0xD612", "comment": "copy 320/3 32/31"},
{"address": "0xD615", "comment": "exchange 314/7 with 324/7"},
{"address": "0xD619", "comment": "execute fill routine"},
{"address": "0xD632", "comment": "X=&20"},
{"address": "0xD634", "comment": "Y=&14"},
{"address": "0xD642", "comment": "if 302/3+Y>302/3+X return"},
{"address": "0xD644", "comment": "else swap 302/3+X with 302/3+Y"},
{"address": "0xD647", "comment": "read current text cursor (X)"},
{"address": "0xD64A", "comment": "set carry"},
{"address": "0xD64B", "comment": "subtract left hand column of current text window"},
{"address": "0xD64E", "comment": "X=A"},
{"address": "0xD64F", "comment": "get current text cursor (Y)"},
{"address": "0xD653", "comment": "suptract top row of current window"},
{"address": "0xD656", "comment": "Y=A"},
{"address": "0xD657", "comment": "and exit"},
{"address": "0xD658", "comment": "store flags"},
{"address": "0xD659", "comment": "X=&20"},
{"address": "0xD65B", "comment": "Y=&35"},
{"address": "0xD65D", "comment": "335/6=(324/5+X-320/1)"},
{"address": "0xD668", "comment": "set pointers"},
{"address": "0xD66B", "comment": "set 339/C=320/3"},
{"address": "0xD683", "comment": "check VDU queque"},
{"address": "0xD688", "comment": "display a line"},
{"address": "0xD68D", "comment": "update pointers"},
{"address": "0xD692", "comment": "and again!"},
{"address": "0xD695", "comment": "update VDU queque"},
{"address": "0xD698", "comment": "and if not empty do it again"},
{"address": "0xD69A", "comment": "else increment next byte"},
{"address": "0xD69D", "comment": "and do it again"},
{"address": "0xD69F", "comment": "pull flags"},
{"address": "0xD6A0", "comment": "if carry clear exit"},
{"address": "0xD6A8", "comment": "is 300/1+x<300/1+Y"},
{"address": "0xD6B4", "comment": "if so D6BC"},
{"address": "0xD6B6", "comment": "else A=Y"},
{"address": "0xD6B7", "comment": "Y=&DE"},
{"address": "0xD6B9", "comment": "X=A"},
{"address": "0xD6BA", "comment": "&DE=X"},
{"address": "0xD6BC", "comment": "&DF=Y"},
{"address": "0xD6C8", "comment": "check for window violations"},
{"address": "0xD6DA", "comment": "set a screen address"},
{"address": "0xD6DD", "comment": "X=&DE"},
{"address": "0xD6DF", "comment": "check for window violations"},
{"address": "0xD6E2", "comment": "A=A/2"},
{"address": "0xD6E3", "comment": "if A<>0 then exit"},
{"address": "0xD6E5", "comment": "else if C clear D6E9"},
{"address": "0xD70B", "comment": "display a point"},
{"address": "0xD70E", "comment": "restore X"},
{"address": "0xD710", "comment": "and A"},
{"address": "0xD711", "comment": "store it"},
{"address": "0xD714", "comment": "get back A"},
{"address": "0xD715", "comment": "and store it"},
{"address": "0xD718", "comment": "exit"},
{"address": "0xD720", "comment": "display a point"},
{"address": "0xD72F", "comment": "number of pixels/byte"},
{"address": "0xD732", "comment": "if 3 mode = goto D73B"},
{"address": "0xD736", "comment": "else if <3 mode 2 goto D73E"},
{"address": "0xD738", "comment": "else rotate bottom bit of &DD"},
{"address": "0xD73A", "comment": "into Accumulator"},
{"address": "0xD73B", "comment": "rotate bottom bit of &DD"},
{"address": "0xD73D", "comment": "into Accumulator"},
{"address": "0xD73E", "comment": "Y=line in current graphics cell containing current"},
{"address": "0xD741", "comment": "X=A"},
{"address": "0xD744", "comment": "Y=Y-8"},
{"address": "0xD74B", "comment": "decrement byte of top line off current graphics cell"},
{"address": "0xD74D", "comment": "display a point"},
{"address": "0xD754", "comment": "pixels/byte"},
{"address": "0xD75A", "comment": "A=0"},
{"address": "0xD75D", "comment": "or with right colour mask"},
{"address": "0xD763", "comment": "store as byte mask"},
{"address": "0xD765", "comment": "Y=Y-8"},
{"address": "0xD76A", "comment": "if carry clear"},
{"address": "0xD76C", "comment": "decrement byte of top line off current graphics cell"},
{"address": "0xD76E", "comment": "display a point"},
{"address": "0xD771", "comment": "and exit via D70E"},
{"address": "0xD7C2", "comment": "get number of logical colours"},
{"address": "0xD7C5", "comment": "if Y<>0 mode <>7 so D7DC"},
{"address": "0xD7C7", "comment": "get character in current character cell"},
{"address": "0xD7C9", "comment": "Y=2"},
{"address": "0xD7CB", "comment": "compare with conversion table"},
{"address": "0xD7CE", "comment": "if not equal D7D4"},
{"address": "0xD7D0", "comment": "else get next lower byte from table"},
{"address": "0xD7D3", "comment": "Y=Y-1"},
{"address": "0xD7D4", "comment": "Y=Y-1"},
{"address": "0xD7D5", "comment": "and if +ve do it again"},
{"address": "0xD7D7", "comment": "Y=current screen mode"},
{"address": "0xD7DA", "comment": "return with character in X, setting EQ/NE"},
{"address": "0xD7DC", "comment": "set up copy of the pattern bytes at text cursor"},
{"address": "0xD7DF", "comment": "X=&20"},
{"address": "0xD7E1", "comment": "A=&20"},
{"address": "0xD7E2", "comment": "Save it"},
{"address": "0xD7E3", "comment": "get pattern address for code in A"},
{"address": "0xD7E6", "comment": "get back A"},
{"address": "0xD7E7", "comment": "and X"},
{"address": "0xD7E8", "comment": "Y=7"},
{"address": "0xD7EA", "comment": "get byte in pattern copy"},
{"address": "0xD7ED", "comment": "check against pattern source"},
{"address": "0xD7EF", "comment": "if not the same D7F9"},
{"address": "0xD7F1", "comment": "else Y=Y-1"},
{"address": "0xD7F2", "comment": "and if +ve D7EA"},
{"address": "0xD7F4", "comment": "A=X"},
{"address": "0xD7F5", "comment": "is X=&7F (delete)"},
{"address": "0xD7F7", "comment": "if not D7D7"},
{"address": "0xD7F9", "comment": "else X=X+1"},
{"address": "0xD7FA", "comment": "get byte lo address"},
{"address": "0xD7FC", "comment": "clear carry"},
{"address": "0xD7FD", "comment": "add 8"},
{"address": "0xD7FF", "comment": "store it"},
{"address": "0xD801", "comment": "and go back to check next character if <>0"},
{"address": "0xD803", "comment": "A=X"},
{"address": "0xD804", "comment": "if <>0 D7E1"},
{"address": "0xD806", "comment": "else D7D7"},
{"address": "0xD808", "comment": "Y=7"},
{"address": "0xD80A", "comment": "&DA=Y"},
{"address": "0xD80C", "comment": "A=1"},
{"address": "0xD80E", "comment": "&DB=A"},
{"address": "0xD810", "comment": "A=left colour mask"},
{"address": "0xD813", "comment": "store an &DC"},
{"address": "0xD815", "comment": "get a byte from current text character"},
{"address": "0xD817", "comment": "EOR with text background colour"},
{"address": "0xD81A", "comment": "clear carry"},
{"address": "0xD81B", "comment": "and check bits of colour mask"},
{"address": "0xD81D", "comment": "if result =0 then D820"},
{"address": "0xD81F", "comment": "else set carry"},
{"address": "0xD820", "comment": "&DB=&DB+Carry"},
{"address": "0xD824", "comment": "else  &DC=&DC/2"},
{"address": "0xD826", "comment": "if carry clear D81B"},
{"address": "0xD828", "comment": "A=Y"},
{"address": "0xD829", "comment": "ADD ( (7+carry)"},
{"address": "0xD82B", "comment": "Y=A"},
{"address": "0xD82E", "comment": "read modified values into Y and A"},
{"address": "0xD832", "comment": "store copy"},
{"address": "0xD835", "comment": "and do it again"},
{"address": "0xD836", "comment": "until 8 bytes copied"},
{"address": "0xD838", "comment": "exit"},
{"address": "0xD839", "comment": "store A"},
{"address": "0xD83A", "comment": "X=A"},
{"address": "0xD83B", "comment": "set up positional data"},
{"address": "0xD83E", "comment": "get back A"},
{"address": "0xD83F", "comment": "X=A"},
{"address": "0xD840", "comment": "set a screen address after checking for window"},
{"address": "0xD843", "comment": "if A<>0 D85A to exit with A=&FF"},
{"address": "0xD845", "comment": "else get top line of current graphics cell"},
{"address": "0xD847", "comment": "A=A*2 C=bit 7"},
{"address": "0xD848", "comment": "&DA=&DA+2 +C  C=bit 7 &DA"},
{"address": "0xD84A", "comment": "byte mask=bM*2 +carry from &DA"},
{"address": "0xD84C", "comment": "save flags"},
{"address": "0xD84D", "comment": "if carry set D851"},
{"address": "0xD84F", "comment": "else restore &DA with bit =0"},
{"address": "0xD851", "comment": "pull flags"},
{"address": "0xD852", "comment": "if Z set D847"},
{"address": "0xD854", "comment": "else A=&DA AND number of colours in current mode -1"},
{"address": "0xD859", "comment": "then exit"},
{"address": "0xD85A", "comment": "A=&FF"},
{"address": "0xD85C", "comment": "exit"},
{"address": "0xD85D", "comment": "X=&20"},
{"address": "0xD862", "comment": "if A<>0 there is a window violation so D85C"},
{"address": "0xD864", "comment": "else set up graphics scan line variable"},
{"address": "0xD86C", "comment": "in 31A"},
{"address": "0xD86F", "comment": "A=Y"},
{"address": "0xD870", "comment": "A=A/2"},
{"address": "0xD871", "comment": "A=A/2"},
{"address": "0xD872", "comment": "A=A/2"},
{"address": "0xD873", "comment": "A=A*2 this gives integer value bit 0 =0"},
{"address": "0xD874", "comment": "Y=A"},
{"address": "0xD875", "comment": "get high byte of offset from screen RAM start"},
{"address": "0xD877", "comment": "store it"},
{"address": "0xD879", "comment": "Y=Y+1"},
{"address": "0xD87A", "comment": "get lo byte"},
{"address": "0xD87C", "comment": "get screen map type"},
{"address": "0xD87F", "comment": "if 0 (modes 0,1,2) goto D884"},
{"address": "0xD881", "comment": "else &DA=&DA/2"},
{"address": "0xD883", "comment": "and A=A/2 +C if set"},
{"address": "0xD884", "comment": "add screen top left hand corner lo"},
{"address": "0xD887", "comment": "store it"},
{"address": "0xD889", "comment": "get high  byte"},
{"address": "0xD88B", "comment": "add top left hi"},
{"address": "0xD88E", "comment": "store it"},
{"address": "0xD899", "comment": "and then Add pixels per byte-1"},
{"address": "0xD89F", "comment": "Y=A"},
{"address": "0xD8A0", "comment": "A=&80 /2^Y using look up table"},
{"address": "0xD8A3", "comment": "store it"},
{"address": "0xD8A5", "comment": "get back A"},
{"address": "0xD8A6", "comment": "Y=&number of pixels/byte"},
{"address": "0xD8A9", "comment": "is Y=3 (modes 1,6)"},
{"address": "0xD8AB", "comment": "goto D8B2"},
{"address": "0xD8AD", "comment": "if mode =1 or 4 D8B5"},
{"address": "0xD8AF", "comment": "A/&DA =A/&DA *2"},
{"address": "0xD8B5", "comment": "clear bits 0-2"},
{"address": "0xD8B7", "comment": "clear carry"},
{"address": "0xD8B8", "comment": "add A/&DA to &D6/7"},
{"address": "0xD8C0", "comment": "if result +ve D8C6"},
{"address": "0xD8C2", "comment": "else set carry"},
{"address": "0xD8C3", "comment": "and subtract screen memory size making it wrap round"},
{"address": "0xD8C6", "comment": "store it in &D7"},
{"address": "0xD8C8", "comment": "get line in graphics cell containing current graphics"},
{"address": "0xD8CB", "comment": "point  A=0"},
{"address": "0xD8CD", "comment": "And exit"},
{"address": "0xD8CE", "comment": "Push A"},
{"address": "0xD8CF", "comment": "A=&A0"},
{"address": "0xD8D1", "comment": "X=number of items in VDU queue"},
{"address": "0xD8D4", "comment": "if not 0, D916"},
{"address": "0xD8D6", "comment": "else check VDU status byte"},
{"address": "0xD8D8", "comment": "if either VDU is disabled or plot to graphics"},
{"address": "0xD8DA", "comment": "if cursor editing enabled D8F5"},
{"address": "0xD8DC", "comment": "else get 6845 register start setting"},
{"address": "0xD8DF", "comment": "clear bits 5 and 6"},
{"address": "0xD8E1", "comment": "set bit 6 to modify last cursor size setting"},
{"address": "0xD8E3", "comment": "change write cursor format"},
{"address": "0xD8E6", "comment": "X=&18"},
{"address": "0xD8E8", "comment": "Y=&64"},
{"address": "0xD8EA", "comment": "set text input cursor from text output cursor"},
{"address": "0xD8ED", "comment": "modify character at cursor poistion"},
{"address": "0xD8F0", "comment": "A=2"},
{"address": "0xD8F2", "comment": "bit 1 of VDU status is set to bar scrolling"},
{"address": "0xD8F5", "comment": "A=&BF"},
{"address": "0xD8F7", "comment": "bit 6 of VDU status =0"},
{"address": "0xD8FA", "comment": "Pull A"},
{"address": "0xD8FB", "comment": "clear hi bit (7)"},
{"address": "0xD8FD", "comment": "entire VDU routine !!"},
{"address": "0xD900", "comment": "A=&40"},
{"address": "0xD902", "comment": "exit"},
{"address": "0xD905", "comment": "A=&20"},
{"address": "0xD907", "comment": "if bit 6 cursor editing is set"},
{"address": "0xD90B", "comment": "or bit 5 is set exit &D8CB"},
{"address": "0xD90D", "comment": "read a character from the screen"},
{"address": "0xD910", "comment": "if A=0 on return exit via D917"},
{"address": "0xD912", "comment": "else store A"},
{"address": "0xD913", "comment": "perform cursor right"},
{"address": "0xD916", "comment": "restore A"},
{"address": "0xD917", "comment": "and exit"},
{"address": "0xD918", "comment": "zero bits 2 and 6 of VDU status"},
{"address": "0xD91D", "comment": "set normal cursor"},
{"address": "0xD920", "comment": "A=&0D"},
{"address": "0xD922", "comment": "and return"},
{"address": "0xD923", "comment": "Get current screen mode"},
{"address": "0xD926", "comment": "A=X"},
{"address": "0xD927", "comment": "Ensure mode 0-7"},
{"address": "0xD929", "comment": "Pass to Y into index into screen size table"},
{"address": "0xD92A", "comment": "X=screen size type, 0-4"},
{"address": "0xD92D", "comment": "A=high byte of start address for screen type"},
{"address": "0xD930", "comment": "Returned address is &xx00"},
{"address": "0xD932", "comment": "Check available RAM"},
{"address": "0xD935", "comment": "If bit 7 set then 32K RAM, so return address"},
{"address": "0xD937", "comment": "16K RAM, so drop address to bottom 16K"},
{"address": "0xD939", "comment": "Check screen mode"},
{"address": "0xD93B", "comment": "If mode 4-7, return the address"},
{"address": "0xD93D", "comment": "If mode 0-3, return &0000 as not enough memory"},
{"address": "0xD93E", "comment": "Pass high byte of address to Y"},
{"address": "0xD93F", "comment": "and return address in YX"},
{"address": "0xD9CD", "comment": "set NMI first instruction to RTI"},
{"address": "0xD9CF", "comment": "NMI ram start"},
{"address": "0xD9D2", "comment": "disable interrupts just in case"},
{"address": "0xD9D3", "comment": "clear decimal flag"},
{"address": "0xD9D4", "comment": "reset stack"},
{"address": "0xD9D6", "comment": "(&1FF)"},
{"address": "0xD9D7", "comment": "read interupt enable register of the system VIA"},
{"address": "0xD9DA", "comment": "shift bit 7 into carry"},
{"address": "0xD9DB", "comment": "save whats left"},
{"address": "0xD9DC", "comment": "if Power up A=0 so D9E7"},
{"address": "0xD9DE", "comment": "else if BREAK pressed read BREAK Action flags (set by"},
{"address": "0xD9E1", "comment": "divide by 2"},
{"address": "0xD9E2", "comment": "if (bit 1 not set by *FX200)"},
{"address": "0xD9E4", "comment": "then &DA03"},
{"address": "0xD9E6", "comment": "divide A by 2 again (will always be A=0 as 1 DIV 2=0)"},
{"address": "0xD9E7", "comment": "get page to start clearance from (4)"},
{"address": "0xD9E9", "comment": "store it in ZP 01"},
{"address": "0xD9EB", "comment": "store A at 00"},
{"address": "0xD9ED", "comment": "and in Y to set loop counter"},
{"address": "0xD9EE", "comment": "clear store"},
{"address": "0xD9F0", "comment": "until address &01 =0"},
{"address": "0xD9F4", "comment": "increment pointer"},
{"address": "0xD9F5", "comment": "if not zero loop round again"},
{"address": "0xD9F7", "comment": "else increment again (Y=1) this avoids overwriting"},
{"address": "0xD9F8", "comment": "increment X"},
{"address": "0xD9F9", "comment": "increment &01"},
{"address": "0xD9FB", "comment": "loop until A=&80 then exit"},
{"address": "0xD9FD", "comment": "writes marker for available RAM 40 =16K, 80=32K"},
{"address": "0xDA00", "comment": "write soft key consistency flag"},
{"address": "0xDA03", "comment": "set PORT B to output on bits 0-3 Input 4-7"},
{"address": "0xDA08", "comment": "loop start"},
{"address": "0xDA09", "comment": "write latch IC32"},
{"address": "0xDA0C", "comment": "is it 9"},
{"address": "0xDA0E", "comment": "if so go back and do it again"},
{"address": "0xDA10", "comment": "X=9"},
{"address": "0xDA11", "comment": "A=X"},
{"address": "0xDA12", "comment": "interrogate keyboard"},
{"address": "0xDA15", "comment": "for keyboard links 9-2 and CTRL key (1)"},
{"address": "0xDA17", "comment": "rotate MSB into bit 7 of &FC"},
{"address": "0xDA19", "comment": "get back value of X for loop"},
{"address": "0xDA1A", "comment": "decrement it"},
{"address": "0xDA1B", "comment": "and if >0 do loop again"},
{"address": "0xDA1D", "comment": "clear last BREAK flag"},
{"address": "0xDA20", "comment": "CTRL is now in carry &FC is keyboard links"},
{"address": "0xDA22", "comment": "set LEDs carry on entry, CTRL=bit 0 of A on exit"},
{"address": "0xDA25", "comment": "get carry back into carry flag"},
{"address": "0xDA2A", "comment": "get back A from &D9DB"},
{"address": "0xDA2B", "comment": "if A=0 power up reset so DA36 with X=&9C Y=&8D"},
{"address": "0xDA2D", "comment": "else Y=&7E"},
{"address": "0xDA2F", "comment": "and if not CTRL-BREAK DA42 WARM RESET"},
{"address": "0xDA31", "comment": "else Y=&87 COLD RESET"},
{"address": "0xDA33", "comment": "&28D=1"},
{"address": "0xDA36", "comment": "&28D=&28D+1"},
{"address": "0xDA39", "comment": "get keyboard links set"},
{"address": "0xDA3B", "comment": "invert"},
{"address": "0xDA3D", "comment": "and store at &28F"},
{"address": "0xDA40", "comment": "X=&90"},
{"address": "0xDA42", "comment": "A=0"},
{"address": "0xDA44", "comment": "zero &200+X to &2CD"},
{"address": "0xDA48", "comment": "then set &2CE to &2FF to &FF"},
{"address": "0xDA50", "comment": "set port A of user via to all outputs (printer out)"},
{"address": "0xDA53", "comment": "A=0"},
{"address": "0xDA54", "comment": "X=&E2"},
{"address": "0xDA56", "comment": "Clear zeropage &E2 to &FF"},
{"address": "0xDA59", "comment": "X is now &00"},
{"address": "0xDA5B", "comment": "Set up default vectors and OSBYTE variables"},
{"address": "0xDA5E", "comment": "from the top set by Break type"},
{"address": "0xDA64", "comment": "Set Last Key Pressed in &ED to &62 - SPACEBAR"},
{"address": "0xDA68", "comment": "Set up ACIA"},
{"address": "0xDA77", "comment": "briefly allow interrupts to clear anything pending"},
{"address": "0xDA78", "comment": "disallow again NB, all VIA IRQs are disabled"},
{"address": "0xDA79", "comment": "if bit 6=1 then JSR &F055 (normally 0)"},
{"address": "0xDA7B", "comment": "else DA80"},
{"address": "0xDA7D", "comment": "F055 JMP (&FDFE) probably causes a BRK unless"},
{"address": "0xDA80", "comment": "enable interrupts 1,4,5,6 of system VIA"},
{"address": "0xDA85", "comment": "set system VIA PCR"},
{"address": "0xDA8A", "comment": "set system VIA ACR"},
{"address": "0xDA8F", "comment": "set system VIA T1 counter (Low)"},
{"address": "0xDA94", "comment": "set user VIA PCR"},
{"address": "0xDA97", "comment": "set up A/D converter"},
{"address": "0xDA9A", "comment": "read user VIA IER if = &0E then DAA2 chip present"},
{"address": "0xDA9D", "comment": "so goto DAA2"},
{"address": "0xDA9F", "comment": "else increment user VIA mask to 0 to bar all"},
{"address": "0xDAA2", "comment": "set T1 (hi) to &27 this sets T1 to &270E (9998 uS)"},
{"address": "0xDAA4", "comment": "or 10msec, interrupts occur every 10msec therefore"},
{"address": "0xDAAA", "comment": "clear the sound channels"},
{"address": "0xDAAD", "comment": "read serial ULA control register"},
{"address": "0xDAB0", "comment": "zero bit 7"},
{"address": "0xDAB2", "comment": "and set up serial ULA"},
{"address": "0xDAB5", "comment": "get soft key status flag"},
{"address": "0xDAB8", "comment": "if 0 (keys OK) then DABD"},
{"address": "0xDABA", "comment": "else reset function keys"},
{"address": "0xDABD", "comment": "set up ROM latch and RAM copy to X"},
{"address": "0xDAC0", "comment": "set X to point to offset in table"},
{"address": "0xDAC2", "comment": "get copyright offset from ROM"},
{"address": "0xDAC5", "comment": "get first byte"},
{"address": "0xDAC8", "comment": "compare it with table byte"},
{"address": "0xDACB", "comment": "if not the same then goto DAFB"},
{"address": "0xDACD", "comment": "point to next byte"},
{"address": "0xDACE", "comment": "(s)"},
{"address": "0xDACF", "comment": "and if still +ve go back to check next byte"},
{"address": "0xDAD1", "comment": "get RAM copy of ROM No. in X"},
{"address": "0xDAD3", "comment": "and Y"},
{"address": "0xDAD5", "comment": "increment Y to check"},
{"address": "0xDAD6", "comment": "if ROM 15 is current ROM"},
{"address": "0xDAD8", "comment": "if equal or more than 16 goto &DAFF"},
{"address": "0xDADA", "comment": "else put Y in A"},
{"address": "0xDADB", "comment": "invert it"},
{"address": "0xDADD", "comment": "and store at &FA"},
{"address": "0xDADF", "comment": "store &7F at"},
{"address": "0xDAE1", "comment": "&FB to get address &7FFF-Y"},
{"address": "0xDAE3", "comment": "set new ROM"},
{"address": "0xDAE6", "comment": "Get byte"},
{"address": "0xDAE8", "comment": "switch back to previous ROM"},
{"address": "0xDAEB", "comment": "and compare with previous byte called"},
{"address": "0xDAED", "comment": "if not the same then go back and do it again"},
{"address": "0xDAEF", "comment": "else increment &FA to point to new location"},
{"address": "0xDAF1", "comment": "if &FA<>0 then check next byte"},
{"address": "0xDAF3", "comment": "else inc &FB"},
{"address": "0xDAF5", "comment": "and check that it doesnt exceed"},
{"address": "0xDAF7", "comment": "&84 (1K checked)"},
{"address": "0xDAF9", "comment": "then check next byte(s)"},
{"address": "0xDAFB", "comment": "X=(&F4)"},
{"address": "0xDAFD", "comment": "if +ve then &DB0C"},
{"address": "0xDAFF", "comment": "get ROM type"},
{"address": "0xDB02", "comment": "store it in ROM list"},
{"address": "0xDB05", "comment": "check for BASIC (bit 7 not set)"},
{"address": "0xDB07", "comment": "if not BASIC the DB0C"},
{"address": "0xDB09", "comment": "else store X in BASIC ROM number"},
{"address": "0xDB0C", "comment": "increment X to point to next ROM"},
{"address": "0xDB0D", "comment": "is it 15 or less"},
{"address": "0xDB0F", "comment": "if so goto &DABD for next ROM"},
{"address": "0xDB11", "comment": "if bit 7 low then we have speech system fitted"},
{"address": "0xDB14", "comment": "else goto DB27"},
{"address": "0xDB16", "comment": "(027B)=&FF to indicate speech present"},
{"address": "0xDB19", "comment": "Y=&FF"},
{"address": "0xDB1B", "comment": "initialise speech generator"},
{"address": "0xDB1E", "comment": "via this"},
{"address": "0xDB1F", "comment": "loop"},
{"address": "0xDB21", "comment": "set T2 timer for speech"},
{"address": "0xDB27", "comment": "get back start up options (mode)"},
{"address": "0xDB2A", "comment": "then jump to screen initialisation"},
{"address": "0xDB2D", "comment": "Y=&CA"},
{"address": "0xDB2F", "comment": "to enter this in keyboard buffer"},
{"address": "0xDB32", "comment": "check to see if BOOT address is set up, if so"},
{"address": "0xDB35", "comment": "set up cassette options"},
{"address": "0xDB38", "comment": "test for tube to FIFO buffer 1"},
{"address": "0xDB40", "comment": "put bit 0 into carry"},
{"address": "0xDB41", "comment": "if no tube then DB4D"},
{"address": "0xDB43", "comment": "else"},
{"address": "0xDB45", "comment": "issue ROM service call &FF"},
{"address": "0xDB48", "comment": "if not 0 on exit (Tube not initialised) DB4D"},
{"address": "0xDB4A", "comment": "else set tube flag to show its active"},
{"address": "0xDB4D", "comment": "set current value of PAGE"},
{"address": "0xDB4F", "comment": "issue claim absolute workspace call"},
{"address": "0xDB51", "comment": "via F168"},
{"address": "0xDB54", "comment": "send private workspace claim call"},
{"address": "0xDB56", "comment": "via F168"},
{"address": "0xDB59", "comment": "set primary OSHWM"},
{"address": "0xDB5C", "comment": "set current OSHWM"},
{"address": "0xDB5F", "comment": "issue call for Tube to explode character set etc."},
{"address": "0xDB61", "comment": "Y=FF if tube present else Y=0"},
{"address": "0xDB64", "comment": "and make call via F168"},
{"address": "0xDB67", "comment": "if A=&FE and bit 7 of 0267 is set then continue"},
{"address": "0xDB6A", "comment": "else ignore start up message"},
{"address": "0xDB6C", "comment": "output to screen"},
{"address": "0xDB6E", "comment": "BBC Computer  message"},
{"address": "0xDB71", "comment": "0=warm reset, anything else continue"},
{"address": "0xDB76", "comment": "by checking length of RAM"},
{"address": "0xDB7B", "comment": "and either"},
{"address": "0xDB7F", "comment": "finishing message with 16K or 32K"},
{"address": "0xDB82", "comment": "and two newlines"},
{"address": "0xDB88", "comment": "Look for break intercept"},
{"address": "0xDB8B", "comment": "Read ctrl/shift keys, M=Shift, C=Ctrl, A=%sxxxxxxx"},
{"address": "0xDB8E", "comment": "Save flags, M=Shift"},
{"address": "0xDB8F", "comment": "and get back in A"},
{"address": "0xDB90", "comment": "Move SHIFT state into bit 3"},
{"address": "0xDB93", "comment": "(This could be done without PHP/PLA as A=%sxxxxxxx)"},
{"address": "0xDB94", "comment": "EOR with start-up options which may or may not"},
{"address": "0xDB97", "comment": "invert bit 3"},
{"address": "0xDB99", "comment": "Y=A"},
{"address": "0xDB9A", "comment": "make fs initialisation call, passing boot option in Y"},
{"address": "0xDB9C", "comment": "Eg, RUN, EXEC or LOAD !BOOT file"},
{"address": "0xDB9F", "comment": "if a ROM accepts this call then DBBE"},
{"address": "0xDBA1", "comment": "else put Y in A"},
{"address": "0xDBA2", "comment": "if Y<>0 DBB8"},
{"address": "0xDBA4", "comment": "else set up standard cassette baud rates"},
{"address": "0xDBA6", "comment": "via &F135"},
{"address": "0xDBAD", "comment": "decrement ignore start up message flag"},
{"address": "0xDBB0", "comment": "and attempto to execute */!BOOT"},
{"address": "0xDBB3", "comment": "restore start up message flag"},
{"address": "0xDBB6", "comment": "if not zero then DBBE"},
{"address": "0xDBB8", "comment": "Error from */!BOOT jumps back to here"},
{"address": "0xDBBA", "comment": "A=0, X=0"},
{"address": "0xDBBB", "comment": "Set tape speed"},
{"address": "0xDBBE", "comment": "get last RESET Type"},
{"address": "0xDBC1", "comment": "if not soft reset DBC8"},
{"address": "0xDBC3", "comment": "else get current language ROM address"},
{"address": "0xDBC6", "comment": "if +ve (language available) then skip search routine"},
{"address": "0xDBC8", "comment": "set pointer to highest available rom"},
{"address": "0xDBCA", "comment": "get ROM type from ROM table"},
{"address": "0xDBCD", "comment": "put high bit into carry, bit 6 into bit 7"},
{"address": "0xDBCE", "comment": "if bit 7 set then ROM has a language entry so DBE6"},
{"address": "0xDBD0", "comment": "else search for language until X<0"},
{"address": "0xDBD3", "comment": "if bit 7 of tube flag is set BMI succeeds"},
{"address": "0xDBD5", "comment": "and TUBE is connected else"},
{"address": "0xDBD8", "comment": "make error"},
{"address": "0xDBE6", "comment": "CLC=Entering language from RESET"},
{"address": "0xDBE7", "comment": "Save flags"},
{"address": "0xDBE8", "comment": "Set as current language ROM"},
{"address": "0xDBEB", "comment": "Select the ROM"},
{"address": "0xDBEE", "comment": "A=128"},
{"address": "0xDBF0", "comment": "Y=8"},
{"address": "0xDBF2", "comment": "Display ROM title at &8009"},
{"address": "0xDBF5", "comment": "Save Y on exit, points FAULT to string after title"},
{"address": "0xDBF7", "comment": "Two line feeds"},
{"address": "0xDBFA", "comment": "are output"},
{"address": "0xDBFD", "comment": "Get flags back"},
{"address": "0xDBFE", "comment": "A=1 to indicate language entry"},
{"address": "0xDC00", "comment": "Check if tube exists"},
{"address": "0xDC03", "comment": "Of it is, skip to DC08 to start language via Tube"},
{"address": "0xDC05", "comment": "Else enter language at &8000"},
{"address": "0xDC08", "comment": "Enter Tube code to start language"},
{"address": "0xDC0B", "comment": "Get current ROM number into X"},
{"address": "0xDC0D", "comment": "Store new number in &F4"},
{"address": "0xDC0F", "comment": "Switch in ROM"},
{"address": "0xDC12", "comment": "Y=0 to point to addressed byte"},
{"address": "0xDC14", "comment": "Get byte from address"},
{"address": "0xDC16", "comment": "RAM copy of ROM latch"},
{"address": "0xDC18", "comment": "Write to ROM latch"},
{"address": "0xDC1B", "comment": "And return"},
{"address": "0xDC1C", "comment": "save A"},
{"address": "0xDC1E", "comment": "get back status (flags)"},
{"address": "0xDC1F", "comment": "and save again"},
{"address": "0xDC20", "comment": "check if BRK flag set"},
{"address": "0xDC22", "comment": "if so goto DC27"},
{"address": "0xDC24", "comment": "else JMP (IRQ1V)"},
{"address": "0xDC27", "comment": "save X on stack"},
{"address": "0xDC29", "comment": "get status pointer"},
{"address": "0xDC2A", "comment": "get Program Counter lo"},
{"address": "0xDC2E", "comment": "set carry"},
{"address": "0xDC2F", "comment": "subtract 2 (1+carry)"},
{"address": "0xDC31", "comment": "and store it in &FD"},
{"address": "0xDC33", "comment": "get hi byte"},
{"address": "0xDC36", "comment": "subtract 1 if necessary"},
{"address": "0xDC38", "comment": "and store in &FE"},
{"address": "0xDC3A", "comment": "get currently active ROM"},
{"address": "0xDC3C", "comment": "and store it in &24A"},
{"address": "0xDC3F", "comment": "store stack pointer in &F0"},
{"address": "0xDC41", "comment": "and issue ROM service call 6"},
{"address": "0xDC43", "comment": "(User BRK) to ROMs"},
{"address": "0xDC46", "comment": "get current language"},
{"address": "0xDC49", "comment": "select ROM"},
{"address": "0xDC4C", "comment": "get back original value of X"},
{"address": "0xDC4E", "comment": "get back original value of A"},
{"address": "0xDC50", "comment": "allow interrupts"},
{"address": "0xDC51", "comment": "and JUMP via BRKV (normally into current language)"},
{"address": "0xDC54", "comment": "Y=0 to point to byte after BRK"},
{"address": "0xDC56", "comment": "print message"},
{"address": "0xDC59", "comment": "if BIT 0 set and DISC EXEC error"},
{"address": "0xDC5C", "comment": "occurs"},
{"address": "0xDC5D", "comment": "hang up machine!!!!"},
{"address": "0xDC5F", "comment": "else print two newlines"},
{"address": "0xDC65", "comment": "and set tape speed before entering current"},
{"address": "0xDC69", "comment": "Set b7 of RS423 busy flag"},
{"address": "0xDC6C", "comment": "check bit 7 of current ACIA control register"},
{"address": "0xDC6F", "comment": "if interrupts NOT enabled DC78"},
{"address": "0xDC71", "comment": "else E741 to check if serial buffer full"},
{"address": "0xDC74", "comment": "X=&00 to set RTS low"},
{"address": "0xDC76", "comment": "if carry set goto DC7A to transfer data"},
{"address": "0xDC78", "comment": "X=&40 to set RTS high"},
{"address": "0xDC7A", "comment": "Jump to set ACIA control register"},
{"address": "0xDC7D", "comment": "Read data from ACIA"},
{"address": "0xDC80", "comment": "Check PE:RO:FE:DCD"},
{"address": "0xDC82", "comment": "If any set, jump to generate Serial Error Event"},
{"address": "0xDC84", "comment": "Read RS423 input suppression flag"},
{"address": "0xDC87", "comment": "If not 0, jump to ignore"},
{"address": "0xDC89", "comment": "X=1, serial input buffer"},
{"address": "0xDC8A", "comment": "Put byte in buffer"},
{"address": "0xDC8D", "comment": "Check if serial buffer almost full"},
{"address": "0xDC90", "comment": "If almost full, jump to set RTS high"},
{"address": "0xDC92", "comment": "Return"},
{"address": "0xDC93", "comment": "Clear decimal flag"},
{"address": "0xDC94", "comment": "Get original value of A"},
{"address": "0xDC96", "comment": "Save it"},
{"address": "0xDC97", "comment": "Save X"},
{"address": "0xDC99", "comment": "and Y"},
{"address": "0xDC9B", "comment": "Stack return address to &DE82"},
{"address": "0xDCA1", "comment": "Clear V flag"},
{"address": "0xDCA2", "comment": "Read ACIA status register"},
{"address": "0xDCA5", "comment": "b6 set, jump with serial parity error"},
{"address": "0xDCA7", "comment": "b7=0, no ACIA interrupt, jump to check VIAs"},
{"address": "0xDCA9", "comment": "Get RS423 timeout counter"},
{"address": "0xDCAB", "comment": "Decrement it"},
{"address": "0xDCAC", "comment": "If 0 or <0, RS423 owns 6850, jump to DCDE"},
{"address": "0xDCAE", "comment": "If &41..&80, nobody owns 6850, jump to exit"},
{"address": "0xDCB0", "comment": "CFS owns 6850, jump to read ACIA in CFS routines"},
{"address": "0xDCB3", "comment": "Read ACIA data"},
{"address": "0xDCB7", "comment": "Rotate ACIA Status back"},
{"address": "0xDCB8", "comment": "X=ACIA Status"},
{"address": "0xDCB9", "comment": "A=ACIA Data"},
{"address": "0xDCBA", "comment": "Y=07 for RS423 Error Event"},
{"address": "0xDCBC", "comment": "Jump to issue event"},
{"address": "0xDCC1", "comment": "Read from Serial output buffer"},
{"address": "0xDCC4", "comment": "Buffer is not empty, jump to send byte"},
{"address": "0xDCC6", "comment": "Read printer destination"},
{"address": "0xDCC9", "comment": "Is it serial printer??"},
{"address": "0xDCCB", "comment": "Serial buffer empty, not Serial printer, jump to ... DC68"},
{"address": "0xDCCD", "comment": "X=3 for Printer buffer"},
{"address": "0xDCCE", "comment": "Read from Printer buffer"},
{"address": "0xDCD1", "comment": "Copy Byte Fetched/Not fetched into Printer Buffer full flag"},
{"address": "0xDCD4", "comment": "Printer buffer was empty, so jump to ... DC68"},
{"address": "0xDCD6", "comment": "Send byte to ACIA"},
{"address": "0xDCD9", "comment": "Set timeout counter to &E7"},
{"address": "0xDCDB", "comment": "Serial owns 6850 for 103 more calls"},
{"address": "0xDCDD", "comment": "Exit IRQ"},
{"address": "0xDCDE", "comment": "AND with ACIA IRQ mask (normally &FF)"},
{"address": "0xDCE1", "comment": "Move RxRDY into Carry"},
{"address": "0xDCE2", "comment": "If no RxData, jump to check DCD and TxRDY"},
{"address": "0xDCE4", "comment": "If IRQ=1 (now in b6) RxIRQ must have occured, so jump to DCEB"},
{"address": "0xDCE6", "comment": "Get ACIA control setting"},
{"address": "0xDCE9", "comment": "If bit 7=1, IRQs enabled so jump to read byte and insert into buffer"},
{"address": "0xDCEB", "comment": "Move TxRDY into Carry"},
{"address": "0xDCEC", "comment": "Rotate TxRDY into b7 and DCD into Carry"},
{"address": "0xDCED", "comment": "If Data Carrier Detected, jump to DCB3"},
{"address": "0xDCEF", "comment": "If TxRDY (now in b7) jump to to DCBF to send a byte"},
{"address": "0xDCF1", "comment": "b6 should always be zero by now, but if set, then jump to exit"},
{"address": "0xDCF5", "comment": "Issue service call 5, Unknown Interrupt"},
{"address": "0xDCF8", "comment": "If claimed, then jump to exit"},
{"address": "0xDCFA", "comment": "Otherwise drop return address from stack"},
{"address": "0xDCFC", "comment": "And restore registers"},
{"address": "0xDD01", "comment": "Store A in IRQA"},
{"address": "0xDD03", "comment": "And pass the IRQ in to IRQ2V"},
{"address": "0xDD06", "comment": "Read System VIA interrupt flag register"},
{"address": "0xDD09", "comment": "No System VIA interrupt, jump to check User VIA"},
{"address": "0xDD0B", "comment": "Mask with System VIA bit mask"},
{"address": "0xDD0E", "comment": "and interrupt enable register"},
{"address": "0xDD11", "comment": "Rotate to check for CA1 interupt (frame sync)"},
{"address": "0xDD13", "comment": "No CA1 (frame sync), jump to check speech"},
{"address": "0xDD15", "comment": "decrement vertical sync counter"},
{"address": "0xDD18", "comment": "A=RS423 Timeout counter"},
{"address": "0xDD1A", "comment": "if +ve then DD1E"},
{"address": "0xDD1C", "comment": "else increment it"},
{"address": "0xDD1E", "comment": "load flash counter"},
{"address": "0xDD21", "comment": "if 0 then system is not in use, ignore it"},
{"address": "0xDD23", "comment": "else decrement counter"},
{"address": "0xDD26", "comment": "and if not 0 go on past reset routine"},
{"address": "0xDD28", "comment": "else get mark period count in X"},
{"address": "0xDD2B", "comment": "current VIDEO ULA control setting in A"},
{"address": "0xDD2E", "comment": "shift bit 0 into C to check if first colour"},
{"address": "0xDD2F", "comment": "is effective if so C=0 jump to DD34"},
{"address": "0xDD31", "comment": "else get space period count in X"},
{"address": "0xDD34", "comment": "restore bit"},
{"address": "0xDD35", "comment": "and invert it"},
{"address": "0xDD37", "comment": "then change colour"},
{"address": "0xDD3A", "comment": "&0251=X resetting the counter"},
{"address": "0xDD3D", "comment": "Y=4 and call E494 to check and implement vertical"},
{"address": "0xDD3F", "comment": "sync event (4) if necessary"},
{"address": "0xDD42", "comment": "A=2"},
{"address": "0xDD44", "comment": "clear interrupt 1 and exit"},
{"address": "0xDD47", "comment": "Read User VIA interrupt flag register"},
{"address": "0xDD4A", "comment": "No User VIA interrupt, jump to pass to ROMs"},
{"address": "0xDD4C", "comment": "else check for USER IRQ 1"},
{"address": "0xDD54", "comment": "if bit 1=0 the no interrupt 1 so DCF3"},
{"address": "0xDD56", "comment": "else get printer type"},
{"address": "0xDD59", "comment": "decrement"},
{"address": "0xDD5A", "comment": "if not parallel then DCF3"},
{"address": "0xDD5C", "comment": "reset interrupt 1 flag"},
{"address": "0xDD61", "comment": "disable interrupt 1"},
{"address": "0xDD64", "comment": "and output data to parallel printer"},
{"address": "0xDD69", "comment": "Rotate bit 5 into bit 7"},
{"address": "0xDD6D", "comment": "Not a Timer 2 interrupt, jump to check timers"},
{"address": "0xDD6F", "comment": "Prepare to clear VIA interupt"},
{"address": "0xDD73", "comment": "Clear VIA interupt"},
{"address": "0xDD76", "comment": "Zero high byte of T2 Timer"},
{"address": "0xDD79", "comment": "X=8 for Speech buffer"},
{"address": "0xDD7B", "comment": "Prepare to loop up to four times for Speak from RAM"},
{"address": "0xDD7D", "comment": "Examine Speech buffer"},
{"address": "0xDD80", "comment": "Shift carry into bit 7 of Buffer Busy flag"},
{"address": "0xDD83", "comment": "Buffer empty, so exit, leaving Buffer Not Busy"},
{"address": "0xDD85", "comment": "Buffer not empty, A=first byte waiting"},
{"address": "0xDD86", "comment": "Waiting byte=&00 (Speak, no reset), skip past"},
{"address": "0xDD88", "comment": "Read Speech Processor status"},
{"address": "0xDD8B", "comment": "If bit 7 set, Speech Processor is talking, exit and try later"},
{"address": "0xDD8D", "comment": "Fetch Speech command byte from buffer"},
{"address": "0xDD90", "comment": "Store it"},
{"address": "0xDD92", "comment": "Fetch Speech word high byte from buffer"},
{"address": "0xDD95", "comment": "Store it"},
{"address": "0xDD97", "comment": "Fetch Speech word low byte from buffer"},
{"address": "0xDD9A", "comment": "Store it, giving &F6/7=address to be accessed"},
{"address": "0xDD9C", "comment": "Y=Speech command byte"},
{"address": "0xDD9E", "comment": "SOUND &FF00 - Speak from RAM, no reset"},
{"address": "0xDDA0", "comment": "SOUND &FF01-&FF7F - Speak from RAM, with reset"},
{"address": "0xDDA2", "comment": "Check bit 6 of Speech command"},
{"address": "0xDDA4", "comment": "SOUND &FFC0-&FFFF - Speak word number"},
{"address": "0xDDA6", "comment": "Write address %xxrrrraaaaaaaaaaaaaa to speech processor"},
{"address": "0xDDA9", "comment": "Skip forward to speak from selected address"},
{"address": "0xDDAB", "comment": "Multiply address by 2 to index into word table"},
{"address": "0xDDAF", "comment": "Read address from specified PHROM"},
{"address": "0xDDB2", "comment": "Fetch command code, usually &50=Speak or &00=Nop"},
{"address": "0xDDB5", "comment": "Jump to send command to speak from current address"},
{"address": "0xDDB8", "comment": "Send command to Speech processor to start a new command"},
{"address": "0xDDBD", "comment": "Send Speech data low byte"},
{"address": "0xDDC2", "comment": "Send Speech data high byte"},
{"address": "0xDDC5", "comment": "Shift loop counter"},
{"address": "0xDDC7", "comment": "Loop to send up to four byte-pairs"},
{"address": "0xDDCA", "comment": "bit 6 is in carry so if clear there is no 6 int"},
{"address": "0xDDCC", "comment": "Clear interrupt 6"},
{"address": "0xDDD1", "comment": "get current system clock store pointer (5,or 10)"},
{"address": "0xDDD4", "comment": "put A in X"},
{"address": "0xDDD5", "comment": "and invert lo nybble (5 becomes 10 and vv)"},
{"address": "0xDDD7", "comment": "store A"},
{"address": "0xDDD8", "comment": "put A in Y"},
{"address": "0xDDD9", "comment": "get timer value"},
{"address": "0xDDDC", "comment": "update it"},
{"address": "0xDDDE", "comment": "store result in alternate"},
{"address": "0xDDE1", "comment": "decrement X"},
{"address": "0xDDE2", "comment": "if 0 exit"},
{"address": "0xDDE4", "comment": "else decrement Y"},
{"address": "0xDDE5", "comment": "and go back and do next byte"},
{"address": "0xDDE7", "comment": "get back A"},
{"address": "0xDDE8", "comment": "and store back in clock pointer (i.e. inverse previous"},
{"address": "0xDDEB", "comment": "set loop pointer for countdown timer"},
{"address": "0xDDED", "comment": "increment byte and if"},
{"address": "0xDDF0", "comment": "not 0 then DDFA"},
{"address": "0xDDF2", "comment": "else decrement pointer"},
{"address": "0xDDF3", "comment": "and if not 0 do it again"},
{"address": "0xDDF5", "comment": "process EVENT 5 interval timer"},
{"address": "0xDDFA", "comment": "get byte of inkey countdown timer"},
{"address": "0xDDFD", "comment": "if not 0 then DE07"},
{"address": "0xDDFF", "comment": "else get next byte"},
{"address": "0xDE02", "comment": "if 0 DE0A"},
{"address": "0xDE04", "comment": "decrement 2B2"},
{"address": "0xDE07", "comment": "and 2B1"},
{"address": "0xDE0A", "comment": "read bit 7 of envelope processing byte"},
{"address": "0xDE0D", "comment": "if 0 then DE1A"},
{"address": "0xDE0F", "comment": "else increment to 0"},
{"address": "0xDE12", "comment": "allow interrupts"},
{"address": "0xDE13", "comment": "and do routine sound processes"},
{"address": "0xDE16", "comment": "bar interrupts"},
{"address": "0xDE17", "comment": "DEC envelope processing byte back to 0"},
{"address": "0xDE1A", "comment": "read speech buffer busy flag"},
{"address": "0xDE1D", "comment": "if set speech buffer is empty, skip routine"},
{"address": "0xDE1F", "comment": "update speech system variables"},
{"address": "0xDE26", "comment": "if result >=&60 DE2B"},
{"address": "0xDE28", "comment": "else more speech work"},
{"address": "0xDE2B", "comment": "set V and C"},
{"address": "0xDE2E", "comment": "check if ACIA needs attention"},
{"address": "0xDE31", "comment": "check if key has been pressed"},
{"address": "0xDE35", "comment": "(this is 0 if keyboard is to be ignored, else &FF)"},
{"address": "0xDE38", "comment": "if 0 ignore keyboard"},
{"address": "0xDE3A", "comment": "else set carry"},
{"address": "0xDE3B", "comment": "Call keyboard handler centisecond interupt"},
{"address": "0xDE3E", "comment": "Check for data in user printer channel"},
{"address": "0xDE41", "comment": "if ADC bit 6 is set ADC is not busy"},
{"address": "0xDE44", "comment": "so DE4A"},
{"address": "0xDE46", "comment": "else return"},
{"address": "0xDE47", "comment": "put original bit 4 from FE4D into bit 7 of A"},
{"address": "0xDE48", "comment": "if not set DE72"},
{"address": "0xDE4A", "comment": "else get current ADC channel"},
{"address": "0xDE4D", "comment": "if 0 DE6C"},
{"address": "0xDE4F", "comment": "read low data byte"},
{"address": "0xDE52", "comment": "store it in &2B6,7,8 or 9"},
{"address": "0xDE55", "comment": "get high data byte"},
{"address": "0xDE58", "comment": "and store it in hi byte"},
{"address": "0xDE5B", "comment": "store in Analogue system flag marking last channel"},
{"address": "0xDE5E", "comment": "handle event 3 conversion complete"},
{"address": "0xDE63", "comment": "decrement X"},
{"address": "0xDE64", "comment": "if X=0"},
{"address": "0xDE66", "comment": "get highest ADC channel preseny"},
{"address": "0xDE69", "comment": "and start new conversion"},
{"address": "0xDE6C", "comment": "reset interrupt 4"},
{"address": "0xDE71", "comment": "and return"},
{"address": "0xDE72", "comment": "get original bit 0 in bit 7 position"},
{"address": "0xDE76", "comment": "If bit 7 clear not a keyboard interrupt"},
{"address": "0xDE78", "comment": "Call keyboard handler keypress interupt"},
{"address": "0xDE7B", "comment": "A=1"},
{"address": "0xDE7D", "comment": "and off to reset interrupt and exit"},
{"address": "0xDE7F", "comment": "Jump off to pass Unknown Interrupt to ROMs"},
{"address": "0xDE82", "comment": "restore registers"},
{"address": "0xDE87", "comment": "store A"},
{"address": "0xDE89", "comment": "get back original value of A"},
{"address": "0xDE8B", "comment": "and return to calling routine"},
{"address": "0xDE8C", "comment": "set last channel to finish conversion"},
{"address": "0xDE8F", "comment": "if X<4 then"},
{"address": "0xDE91", "comment": "DE95"},
{"address": "0xDE93", "comment": "else X=4"},
{"address": "0xDE95", "comment": "store it as current ADC channel"},
{"address": "0xDE98", "comment": "get conversion type"},
{"address": "0xDE9B", "comment": "decrement"},
{"address": "0xDE9C", "comment": "A=Y"},
{"address": "0xDE9D", "comment": "and it with 08"},
{"address": "0xDE9F", "comment": "clear carry"},
{"address": "0xDEA0", "comment": "add to current ADC"},
{"address": "0xDEA3", "comment": "-1"},
{"address": "0xDEA5", "comment": "store to the A/D control panel"},
{"address": "0xDEA8", "comment": "and return"},
{"address": "0xDEA9", "comment": "point to start of string at &C300,Y"},
{"address": "0xDEAB", "comment": "store it"},
{"address": "0xDEAD", "comment": "point to lo byte"},
{"address": "0xDEAF", "comment": "store it and start loop"},
{"address": "0xDEB1", "comment": "print character in string"},
{"address": "0xDEB2", "comment": "pointed to by &FD/E"},
{"address": "0xDEB4", "comment": "print it expanding Carriage returns"},
{"address": "0xDEB7", "comment": "store A in X"},
{"address": "0xDEB8", "comment": "and loop again if not =0"},
{"address": "0xDEBA", "comment": "else exit"},
{"address": "0xDEBB", "comment": "store time in INKEY countdown timer"},
{"address": "0xDEBE", "comment": "which is decremented every 10ms"},
{"address": "0xDECD", "comment": "get *EXEC file handle"},
{"address": "0xDED0", "comment": "if 0 (not open) then DEE6"},
{"address": "0xDED2", "comment": "set carry"},
{"address": "0xDED3", "comment": "set bit 7 of CFS active flag to prevent clashes"},
{"address": "0xDED5", "comment": "get a byte from the file"},
{"address": "0xDED8", "comment": "push processor flags to preserve carry"},
{"address": "0xDED9", "comment": "restore &EB"},
{"address": "0xDEDB", "comment": "get back flags"},
{"address": "0xDEDC", "comment": "and if carry clear, character found so exit via DF03"},
{"address": "0xDEDE", "comment": "else A=00 as EXEC file empty"},
{"address": "0xDEE0", "comment": "store it in exec file handle"},
{"address": "0xDEE3", "comment": "and close file via OSFIND"},
{"address": "0xDEE6", "comment": "check ESCAPE flag, if bit 7 set Escape pressed"},
{"address": "0xDEE8", "comment": "so off to DF00"},
{"address": "0xDEEA", "comment": "else get current input buffer number"},
{"address": "0xDEED", "comment": "get a byte from input buffer"},
{"address": "0xDEF0", "comment": "and exit if character returned"},
{"address": "0xDEF2", "comment": "(E6=0 or FF)"},
{"address": "0xDEF4", "comment": "if entry was OSRDCH not timed keypress, so go back and"},
{"address": "0xDEF6", "comment": "else check timers"},
{"address": "0xDEFC", "comment": "and if not zero go round again"},
{"address": "0xDEFE", "comment": "else exit"},
{"address": "0xE01B", "comment": "If none set, jump to pass command on"},
{"address": "0xE01D", "comment": "Set Carry = not entering from RESET"},
{"address": "0xE0A4", "comment": "Save all registers"},
{"address": "0xE0AA", "comment": "Get A back from stack"},
{"address": "0xE0AD", "comment": "Save A"},
{"address": "0xE0AE", "comment": "Check OSWRCH interception flag"},
{"address": "0xE0B1", "comment": "Not set, skip interception call"},
{"address": "0xE0B3", "comment": "Pass character to Y"},
{"address": "0xE0B4", "comment": "A=4 for OSWRCH call"},
{"address": "0xE0B6", "comment": "Call interception code"},
{"address": "0xE0B9", "comment": "If claimed, jump past to exit"},
{"address": "0xE0BB", "comment": "Prepare to not send this to printer"},
{"address": "0xE0BC", "comment": "Check output destination"},
{"address": "0xE0BE", "comment": "Is VDU driver disabled?"},
{"address": "0xE0C1", "comment": "Yes, skip past VDU driver"},
{"address": "0xE0C3", "comment": "Get character back"},
{"address": "0xE0C4", "comment": "Resave character"},
{"address": "0xE0C5", "comment": "Call VDU driver"},
{"address": "0xE0C8", "comment": "Check output destination"},
{"address": "0xE0CA", "comment": "Is printer seperately enabled?"},
{"address": "0xE0CD", "comment": "Yes, jump to call printer driver"},
{"address": "0xE0CF", "comment": "Carry clear, dont sent to printer"},
{"address": "0xE0D1", "comment": "Get character back"},
{"address": "0xE0D2", "comment": "Resave character"},
{"address": "0xE0D3", "comment": "Call printer driver"},
{"address": "0xE0D6", "comment": "Check output destination"},
{"address": "0xE0D9", "comment": "Is serial output enabled?"},
{"address": "0xE0DA", "comment": "No, skip past serial output"},
{"address": "0xE0DC", "comment": "Get serial timout counter"},
{"address": "0xE0DE", "comment": "Decrease counter"},
{"address": "0xE0DF", "comment": "Timed out, skip past serial code"},
{"address": "0xE0E1", "comment": "Get character back"},
{"address": "0xE0E2", "comment": "Resave character"},
{"address": "0xE0E3", "comment": "Save IRQs"},
{"address": "0xE0E4", "comment": "Disable IRQs"},
{"address": "0xE0E5", "comment": "X=2 for serial output buffer"},
{"address": "0xE0E7", "comment": "Save character"},
{"address": "0xE0E8", "comment": "Examine serial output buffer"},
{"address": "0xE0EB", "comment": "Buffer not full, jump to send character"},
{"address": "0xE0ED", "comment": "Wait for buffer to empty a bit"},
{"address": "0xE0F0", "comment": "Get character back"},
{"address": "0xE0F1", "comment": "X=2 for serial output buffer"},
{"address": "0xE0F3", "comment": "Send character to serial output buffer"},
{"address": "0xE0F6", "comment": "Restore IRQs"},
{"address": "0xE0F7", "comment": "Check output destination"},
{"address": "0xE0F9", "comment": "Is SPOOL output disabled?"},
{"address": "0xE0FC", "comment": "Yes, skip past SPOOL output"},
{"address": "0xE0FE", "comment": "Get SPOOL handle"},
{"address": "0xE101", "comment": "If not open, skip past SPOOL output"},
{"address": "0xE103", "comment": "Get character back"},
{"address": "0xE104", "comment": "Resave character"},
{"address": "0xE106", "comment": "Set RFS/CFSs spooling flag"},
{"address": "0xE108", "comment": "Write character to SPOOL channel"},
{"address": "0xE10B", "comment": "Reset RFS/CFSs spooling flag"},
{"address": "0xE10D", "comment": "Restore all registers"},
{"address": "0xE113", "comment": "Exit"},
{"address": "0xE114", "comment": "Test bit 6 of OSBYTE 3 OSWRCH destination"},
{"address": "0xE117", "comment": "Set, printer disabled, jump to E139 to exit"},
{"address": "0xE119", "comment": "Compare with printer ignore character"},
{"address": "0xE11C", "comment": "Matches, jump to E139 to ignore and exit"},
{"address": "0xE11E", "comment": "Save flags"},
{"address": "0xE11F", "comment": "Disable IRQs"},
{"address": "0xE120", "comment": "Save character in X"},
{"address": "0xE121", "comment": "A=4"},
{"address": "0xE123", "comment": "Test bit 2 of OSBYTE 3 OSWRCH destination"},
{"address": "0xE126", "comment": "If set, printer driver disabled, so jump to E138 to exit"},
{"address": "0xE128", "comment": "Get character back to A"},
{"address": "0xE129", "comment": "X=3, printer buffer number"},
{"address": "0xE12B", "comment": "Attempt to put character into buffer 3 - printer buffer"},
{"address": "0xE12E", "comment": "If carry set, not inserted, buffer was full, aborted with Escape"},
{"address": "0xE130", "comment": "Test buffer 3 busy flag, MI=not busy, PL=busy"},
{"address": "0xE133", "comment": "Buffer busy, jump to E138 to exit"},
{"address": "0xE135", "comment": "Call E13A to send first to printer to start interupts"},
{"address": "0xE138", "comment": "Restore IRQs"},
{"address": "0xE139", "comment": "And exit"},
{"address": "0xE13A", "comment": "Get printer destination"},
{"address": "0xE13D", "comment": "If 0 then sink output, jump to E1AD clear buffer and exit"},
{"address": "0xE13F", "comment": "Check if printer 1"},
{"address": "0xE141", "comment": "Not parallel printer, jump to E164"},
{"address": "0xE143", "comment": "Fetch a byte from the printer buffer, returns CS=empty"},
{"address": "0xE146", "comment": "Rotate buffer status into buffer 2 busy flag"},
{"address": "0xE149", "comment": "If buffer empty, set not busy, and jump to E190 to exit"},
{"address": "0xE14B", "comment": "Enable interrupt 1 of the User VIA"},
{"address": "0xE150", "comment": "Write character to centronics port"},
{"address": "0xE153", "comment": "Pulse CA2 line to generate STROBE signal"},
{"address": "0xE156", "comment": "to advise printer that"},
{"address": "0xE158", "comment": "valid data is"},
{"address": "0xE15A", "comment": "waiting"},
{"address": "0xE162", "comment": "Then exit"},
{"address": "0xE164", "comment": "is it Serial printer??"},
{"address": "0xE166", "comment": "if not E191"},
{"address": "0xE168", "comment": "else is RS423 in use by cassette??"},
{"address": "0xE16B", "comment": "if so E1AD to flush buffer"},
{"address": "0xE16D", "comment": "else clear buffer busy flag"},
{"address": "0xE170", "comment": "and RS423 busy flag"},
{"address": "0xE173", "comment": "count buffer if C is clear on return"},
{"address": "0xE176", "comment": "no room in buffer so exit"},
{"address": "0xE178", "comment": "else"},
{"address": "0xE17C", "comment": "push flags"},
{"address": "0xE17D", "comment": "bar interrupts"},
{"address": "0xE17E", "comment": "A=Y"},
{"address": "0xE17F", "comment": "&FA=X"},
{"address": "0xE181", "comment": "A=old value AND Y EOR X"},
{"address": "0xE186", "comment": "get old value in X"},
{"address": "0xE189", "comment": "put new value in"},
{"address": "0xE18C", "comment": "and store to ACIA control register"},
{"address": "0xE18F", "comment": "get back flags"},
{"address": "0xE190", "comment": "and exit"},
{"address": "0xE191", "comment": "Clear carry"},
{"address": "0xE192", "comment": "A=1, character sent to printer"},
{"address": "0xE194", "comment": "Call NETV and UPTV"},
{"address": "0xE197", "comment": "Set or clear printer buffer busy flag"},
{"address": "0xE19A", "comment": "And exit"},
{"address": "0xE19B", "comment": "if bit 7 is set, printer is not being polled"},
{"address": "0xE19E", "comment": "so exit"},
{"address": "0xE1A0", "comment": "else A=0 (A already is 0 from caller)"},
{"address": "0xE1A2", "comment": "X=3"},
{"address": "0xE1A4", "comment": "Y=printer destination"},
{"address": "0xE1A7", "comment": "to JMP (NETV)"},
{"address": "0xE1AA", "comment": "jump to PRINT VECTOR for special routines"},
{"address": "0xE1AD", "comment": "clear carry"},
{"address": "0xE1AE", "comment": "save A"},
{"address": "0xE1AF", "comment": "save flags"},
{"address": "0xE1B0", "comment": "set interrupts"},
{"address": "0xE1B1", "comment": "if carry set on entry then E1BB"},
{"address": "0xE1B3", "comment": "else get byte from baud rate/sound data table"},
{"address": "0xE1B6", "comment": "if +ve the E1BB"},
{"address": "0xE1B8", "comment": "else clear sound data"},
{"address": "0xE1BB", "comment": "set carry"},
{"address": "0xE1BC", "comment": "rotate buffer flag to show buffer empty"},
{"address": "0xE1BF", "comment": "if X>1 then its not an input buffer"},
{"address": "0xE1C1", "comment": "so E1CB"},
{"address": "0xE1C3", "comment": "else Input buffer so A=0"},
{"address": "0xE1C5", "comment": "store as length of key string"},
{"address": "0xE1C8", "comment": "and length of VDU queue"},
{"address": "0xE1CB", "comment": "then enter via count purge vector any user routines"},
{"address": "0xE1CE", "comment": "restore flags"},
{"address": "0xE1CF", "comment": "restore A"},
{"address": "0xE1D0", "comment": "and exit"},
{"address": "0xE1D1", "comment": "if V set then E1DA"},
{"address": "0xE1D3", "comment": "else start of buffer=end of buffer"},
{"address": "0xE1D9", "comment": "and exit"},
{"address": "0xE1DA", "comment": "push flags"},
{"address": "0xE1DB", "comment": "bar interrupts"},
{"address": "0xE1DC", "comment": "push flags"},
{"address": "0xE1DD", "comment": "set carry"},
{"address": "0xE1DE", "comment": "get end of buffer"},
{"address": "0xE1E1", "comment": "subtract start of buffer"},
{"address": "0xE1E4", "comment": "if carry caused E1EA"},
{"address": "0xE1E6", "comment": "set carry"},
{"address": "0xE1E7", "comment": "subtract buffer start offset (i.e. add buffer length)"},
{"address": "0xE1EA", "comment": "pull flags"},
{"address": "0xE1EB", "comment": "if carry clear E1F3 to exit"},
{"address": "0xE1ED", "comment": "clear carry"},
{"address": "0xE1EE", "comment": "adc to get bytes used"},
{"address": "0xE1F1", "comment": "and invert to get space left"},
{"address": "0xE1F3", "comment": "Y=0"},
{"address": "0xE1F5", "comment": "X=A"},
{"address": "0xE1F6", "comment": "get back flags"},
{"address": "0xE1F7", "comment": "and exit"},
{"address": "0xE1F8", "comment": "Disable interrupts"},
{"address": "0xE1F9", "comment": "Enter a byte in buffer X"},
{"address": "0xE1FC", "comment": "If successful exit"},
{"address": "0xE1FE", "comment": "Switch on both keyboard LEDs"},
{"address": "0xE201", "comment": "Save flags (MI=Escape)"},
{"address": "0xE202", "comment": "Save byte attempted to insert"},
{"address": "0xE203", "comment": "Switch off the LEDs"},
{"address": "0xE206", "comment": "Get the byte back"},
{"address": "0xE207", "comment": "Get the flags back"},
{"address": "0xE208", "comment": "If MI, Escape pressed, so abort and return CS"},
{"address": "0xE20A", "comment": "Allow interrupts for a few cycles"},
{"address": "0xE20B", "comment": "Byte didnt enter buffer go and try it again"},
{"address": "0xE20D", "comment": "Return"},
{"address": "0xE20E", "comment": "push A"},
{"address": "0xE20F", "comment": "A=0"},
{"address": "0xE211", "comment": "clear osfile control block workspace"},
{"address": "0xE21D", "comment": "get back A"},
{"address": "0xE21E", "comment": "and exit"},
{"address": "0xE21F", "comment": "&E6=Y"},
{"address": "0xE221", "comment": "A=A*2"},
{"address": "0xE222", "comment": "*4"},
{"address": "0xE223", "comment": "*8"},
{"address": "0xE224", "comment": "*16"},
{"address": "0xE225", "comment": "Y=4"},
{"address": "0xE227", "comment": "A=A*32"},
{"address": "0xE228", "comment": "shift bit 7 of A into shift register"},
{"address": "0xE22B", "comment": "and"},
{"address": "0xE22E", "comment": "shift"},
{"address": "0xE231", "comment": "along"},
{"address": "0xE234", "comment": "if carry set on exit then register has overflowed"},
{"address": "0xE236", "comment": "decrement Y"},
{"address": "0xE237", "comment": "and if Y>0 then do another shift"},
{"address": "0xE239", "comment": "get back original Y"},
{"address": "0xE23B", "comment": "and exit"},
{"address": "0xE23C", "comment": "signal that load is being performed"},
{"address": "0xE23E", "comment": "store address of rest of command line"},
{"address": "0xE242", "comment": "X and Y are stored in OSfile control block"},
{"address": "0xE248", "comment": "Push A"},
{"address": "0xE249", "comment": "X=2"},
{"address": "0xE24B", "comment": "clear the shift register"},
{"address": "0xE24E", "comment": "Y=255"},
{"address": "0xE250", "comment": "store im 2F4"},
{"address": "0xE253", "comment": "Y=0"},
{"address": "0xE254", "comment": "call GSINIT to prepare for reading text line"},
{"address": "0xE257", "comment": "read GSTRANS character from command line"},
{"address": "0xE25A", "comment": "loop to step past filename"},
{"address": "0xE25C", "comment": "get back A without stack changes"},
{"address": "0xE25E", "comment": "IF A=0 (SAVE)  E2C2"},
{"address": "0xE260", "comment": "set up file block"},
{"address": "0xE263", "comment": "if carry set do OSFILE"},
{"address": "0xE265", "comment": "else if A=0 goto OSFILE"},
{"address": "0xE275", "comment": "X=10 issue *SPOOL/EXEC files warning"},
{"address": "0xE277", "comment": "and issue call"},
{"address": "0xE27A", "comment": "if a rom accepts and issues a 0 then E29F to return"},
{"address": "0xE27C", "comment": "else close the current exec file"},
{"address": "0xE27F", "comment": "A=0"},
{"address": "0xE281", "comment": "if A=0 file is closed so"},
{"address": "0xE282", "comment": "Store Y"},
{"address": "0xE284", "comment": "get file handle"},
{"address": "0xE287", "comment": "store A as file handle"},
{"address": "0xE28A", "comment": "if Y<>0 then E28F"},
{"address": "0xE28C", "comment": "else close file via osfind"},
{"address": "0xE28F", "comment": "get back original Y"},
{"address": "0xE291", "comment": "pull flags"},
{"address": "0xE292", "comment": "if A=0 on entry then exit"},
{"address": "0xE294", "comment": "else A=&80"},
{"address": "0xE296", "comment": "to open file Y for output"},
{"address": "0xE299", "comment": "Y=A"},
{"address": "0xE29A", "comment": "and if this is =0 then E310 BAD COMMAND ERROR"},
{"address": "0xE29C", "comment": "store file handle"},
{"address": "0xE29F", "comment": "and exit"},
{"address": "0xE2A0", "comment": "if NE then BAD COMMAND error"},
{"address": "0xE2A2", "comment": "increment 2F4 to 00"},
{"address": "0xE2A5", "comment": "X=&EE"},
{"address": "0xE2A7", "comment": "Y=&02"},
{"address": "0xE2A9", "comment": "get back A"},
{"address": "0xE2AA", "comment": "and JUMP to OSFILE"},
{"address": "0xE2AD", "comment": "look for end of line"},
{"address": "0xE2B0", "comment": "carry is set if it finds hex digit"},
{"address": "0xE2B3", "comment": "so E2C1 exit"},
{"address": "0xE2B5", "comment": "clear shift register"},
{"address": "0xE2B8", "comment": "shift lower nybble of A into shift register"},
{"address": "0xE2BB", "comment": "then check for Hex digit"},
{"address": "0xE2BE", "comment": "if found then do it again"},
{"address": "0xE2C0", "comment": "else set carry"},
{"address": "0xE2C1", "comment": "and exit"},
{"address": "0xE2C2", "comment": "X=0A"},
{"address": "0xE2C7", "comment": "if no hex digit found EXIT via BAD Command error"},
{"address": "0xE2C9", "comment": "clear bit 6"},
{"address": "0xE2CA", "comment": "read next byte from text line"},
{"address": "0xE2CC", "comment": "is it +"},
{"address": "0xE2CE", "comment": "if not assume its a last byte address so e2d4"},
{"address": "0xE2D0", "comment": "else set V and M flags"},
{"address": "0xE2D3", "comment": "increment Y to point to hex group"},
{"address": "0xE2D4", "comment": "X=E"},
{"address": "0xE2D9", "comment": "if carry clear no hex digit so exit via error"},
{"address": "0xE2DB", "comment": "save flags"},
{"address": "0xE2DC", "comment": "if V set them E2ED explicit end address found"},
{"address": "0xE2DE", "comment": "else X=&FC"},
{"address": "0xE2E0", "comment": "clear carry"},
{"address": "0xE2E1", "comment": "and add length data to start address"},
{"address": "0xE2EB", "comment": "repeat until X=0"},
{"address": "0xE2ED", "comment": "X=3"},
{"address": "0xE2EF", "comment": "copy start adddress to load and execution addresses"},
{"address": "0xE2FB", "comment": "get back flag"},
{"address": "0xE2FC", "comment": "if end of command line reached then E2A5"},
{"address": "0xE2FE", "comment": "else set up execution address"},
{"address": "0xE303", "comment": "if error BAD COMMAND"},
{"address": "0xE305", "comment": "and if end of line reached do OSFILE"},
{"address": "0xE307", "comment": "else set up load address"},
{"address": "0xE30C", "comment": "if error BAD command"},
{"address": "0xE30E", "comment": "else on end of line do OSFILE"},
{"address": "0xE327", "comment": "set up key number in A"},
{"address": "0xE32A", "comment": "if not valid number give error"},
{"address": "0xE32C", "comment": "if key number greater than 15"},
{"address": "0xE32E", "comment": "if greater then give error"},
{"address": "0xE330", "comment": "otherwise skip commas, and check for CR"},
{"address": "0xE333", "comment": "save flags for later"},
{"address": "0xE334", "comment": "get pointer to top of existing key strings"},
{"address": "0xE337", "comment": "save Y"},
{"address": "0xE338", "comment": "to preserve text pointer"},
{"address": "0xE339", "comment": "set up soft key definition"},
{"address": "0xE33C", "comment": "get back Y"},
{"address": "0xE33E", "comment": "and flags"},
{"address": "0xE33F", "comment": "if CR found return else E377 to set up new string"},
{"address": "0xE341", "comment": "else return to set null string"},
{"address": "0xE342", "comment": "convert the number to binary"},
{"address": "0xE345", "comment": "if bad number call bad command"},
{"address": "0xE347", "comment": "save X"},
{"address": "0xE348", "comment": "save A"},
{"address": "0xE349", "comment": "clear &E4/E5"},
{"address": "0xE34F", "comment": "skip commas and check for newline (CR)"},
{"address": "0xE352", "comment": "if CR found E36C"},
{"address": "0xE354", "comment": "convert character to binary"},
{"address": "0xE357", "comment": "if bad character bad command error"},
{"address": "0xE359", "comment": "else save it"},
{"address": "0xE35B", "comment": "skip comma and check CR"},
{"address": "0xE35E", "comment": "if CR then E36C"},
{"address": "0xE360", "comment": "get another parameter"},
{"address": "0xE363", "comment": "if bad error"},
{"address": "0xE365", "comment": "else store in E4"},
{"address": "0xE367", "comment": "now we must have a newline"},
{"address": "0xE36A", "comment": "if none then output an error"},
{"address": "0xE36C", "comment": "Y=third osbyte parameter"},
{"address": "0xE36E", "comment": "X=2nd"},
{"address": "0xE370", "comment": "A=first"},
{"address": "0xE371", "comment": "call osbyte"},
{"address": "0xE374", "comment": "if V set on return then error"},
{"address": "0xE376", "comment": "else RETURN"},
{"address": "0xE378", "comment": "GSINIT to scan dull string"},
{"address": "0xE37B", "comment": "call GSREAD, carry is set if end of line found"},
{"address": "0xE37E", "comment": "E388 to deal with end of line"},
{"address": "0xE380", "comment": "point to first byte of new key definition"},
{"address": "0xE381", "comment": "if X=0 buffer WILL overflow so exit with BAD KEY error"},
{"address": "0xE383", "comment": "store character"},
{"address": "0xE386", "comment": "and loop to get next byte if end of line not found"},
{"address": "0xE388", "comment": "if Z clear then no matching  found or for some"},
{"address": "0xE38A", "comment": "else if all OK save flags"},
{"address": "0xE38B", "comment": "bar interrupts"},
{"address": "0xE38C", "comment": "and move string"},
{"address": "0xE38F", "comment": "set loop counter"},
{"address": "0xE391", "comment": "if key being defined is found"},
{"address": "0xE393", "comment": "then skip rest of loop"},
{"address": "0xE395", "comment": "else get start of string X"},
{"address": "0xE398", "comment": "compare with start of string Y"},
{"address": "0xE39B", "comment": "if not the same then skip rest of loop"},
{"address": "0xE39D", "comment": "else store top of string definition"},
{"address": "0xE3A0", "comment": "in designated key pointer"},
{"address": "0xE3A3", "comment": "decrement loop pointer X"},
{"address": "0xE3A4", "comment": "and do it all again"},
{"address": "0xE3A6", "comment": "get back flags"},
{"address": "0xE3A7", "comment": "and exit"},
{"address": "0xE3A8", "comment": "push flags"},
{"address": "0xE3A9", "comment": "bar interrupts"},
{"address": "0xE3AA", "comment": "get top of currently defined strings"},
{"address": "0xE3AE", "comment": "subtract to get the number of bytes in strings"},
{"address": "0xE3B1", "comment": "store this"},
{"address": "0xE3B3", "comment": "save X"},
{"address": "0xE3B5", "comment": "and X=16"},
{"address": "0xE3B7", "comment": "get start offset (from B00) of key string X"},
{"address": "0xE3BB", "comment": "subtract offset of string we are working on"},
{"address": "0xE3BE", "comment": "if carry clear (B00+Y>B00+X) or"},
{"address": "0xE3C0", "comment": "result (in A)=0"},
{"address": "0xE3C2", "comment": "or greater or equal to number of bytes above"},
{"address": "0xE3C4", "comment": "then E3C8"},
{"address": "0xE3C6", "comment": "else store A in &FB"},
{"address": "0xE3C8", "comment": "point to next lower key offset"},
{"address": "0xE3C9", "comment": "and if 0 or +ve go back and do it again"},
{"address": "0xE3CB", "comment": "else get back value of X"},
{"address": "0xE3CD", "comment": "get back latest value of A"},
{"address": "0xE3CF", "comment": "pull flags"},
{"address": "0xE3D0", "comment": "and return"},
{"address": "0xE3D1", "comment": "push P"},
{"address": "0xE3D2", "comment": "bar interrupts"},
{"address": "0xE3D3", "comment": "save X"},
{"address": "0xE3D4", "comment": "push A"},
{"address": "0xE3D5", "comment": "get key number"},
{"address": "0xE3D7", "comment": "and set up &FB"},
{"address": "0xE3DA", "comment": "get start of string"},
{"address": "0xE3DD", "comment": "put it in Y"},
{"address": "0xE3DE", "comment": "clear carry"},
{"address": "0xE3DF", "comment": "add number of bytes above string"},
{"address": "0xE3E1", "comment": "put this in X"},
{"address": "0xE3E2", "comment": "and store it"},
{"address": "0xE3E4", "comment": "check number of bytes left to remove from key buffer"},
{"address": "0xE3E7", "comment": "if not in use continue"},
{"address": "0xE3F6", "comment": "decrement consistence flag to &FF to warn that key"},
{"address": "0xE3F9", "comment": "pull A"},
{"address": "0xE3FB", "comment": "subtract &FA"},
{"address": "0xE3FD", "comment": "and re store it"},
{"address": "0xE3FF", "comment": "if 0 then E40D"},
{"address": "0xE401", "comment": "else move string"},
{"address": "0xE404", "comment": "from X to Y"},
{"address": "0xE409", "comment": "for length of string"},
{"address": "0xE40D", "comment": "store end of moved string(s)"},
{"address": "0xE40F", "comment": "get back key number"},
{"address": "0xE411", "comment": "point at top of last string"},
{"address": "0xE413", "comment": "get this value"},
{"address": "0xE416", "comment": "compare it with start of new or re defined key"},
{"address": "0xE419", "comment": "if less then E422"},
{"address": "0xE41B", "comment": "if = then E422"},
{"address": "0xE41D", "comment": "shift key definitions accordingly"},
{"address": "0xE422", "comment": "point to next lowest string def"},
{"address": "0xE423", "comment": "and if =>0 then loop and do it again"},
{"address": "0xE425", "comment": "else make top of key definitions"},
{"address": "0xE428", "comment": "the start of our key def"},
{"address": "0xE42B", "comment": "get new end of strings"},
{"address": "0xE42C", "comment": "and store it"},
{"address": "0xE42F", "comment": "put A in X"},
{"address": "0xE430", "comment": "reset consistency flag"},
{"address": "0xE433", "comment": "restore flags"},
{"address": "0xE434", "comment": "and exit"},
{"address": "0xE450", "comment": "get buffer base address lo"},
{"address": "0xE453", "comment": "store it"},
{"address": "0xE455", "comment": "get buffer base address hi"},
{"address": "0xE458", "comment": "store it"},
{"address": "0xE45A", "comment": "exit"},
{"address": "0xE45B", "comment": "set V and"},
{"address": "0xE45E", "comment": "jump to E461"},
{"address": "0xE460", "comment": "clear V"},
{"address": "0xE461", "comment": "Jump via REMV"},
{"address": "0xE464", "comment": "push flags"},
{"address": "0xE465", "comment": "bar interrupts"},
{"address": "0xE466", "comment": "get output pointer for buffer X"},
{"address": "0xE469", "comment": "compare to input pointer"},
{"address": "0xE46C", "comment": "if equal buffer is empty so jump to return with SEC"},
{"address": "0xE46E", "comment": "else A=Y"},
{"address": "0xE46F", "comment": "and get buffer pointer into FA/B"},
{"address": "0xE472", "comment": "read byte from buffer"},
{"address": "0xE474", "comment": "if V was set on input, jump to return with CLC"},
{"address": "0xE476", "comment": "otherwise, update buffer pointer"},
{"address": "0xE477", "comment": "increment Y"},
{"address": "0xE478", "comment": "A=Y"},
{"address": "0xE479", "comment": "pointer<>0, not reached end of buffer"},
{"address": "0xE47B", "comment": "get offset to start of buffer"},
{"address": "0xE47E", "comment": "set update buffer output pointer"},
{"address": "0xE481", "comment": "if buffer is input (0 or 1)"},
{"address": "0xE483", "comment": "then skip checking empty buffer"},
{"address": "0xE485", "comment": "compare output pointer with input pointer"},
{"address": "0xE488", "comment": "not the same, so not empty, so go to E48F"},
{"address": "0xE48A", "comment": "buffer is empty"},
{"address": "0xE48C", "comment": "send Event 0 for Buffer Empty event"},
{"address": "0xE48F", "comment": "get back the byte from buffer"},
{"address": "0xE490", "comment": "put it in Y for OSBYTE caller"},
{"address": "0xE491", "comment": "restore IRQs"},
{"address": "0xE492", "comment": "clear carry to indicate success"},
{"address": "0xE493", "comment": "and exit"},
{"address": "0xE494", "comment": "push flags"},
{"address": "0xE495", "comment": "bar interrupts"},
{"address": "0xE496", "comment": "push A"},
{"address": "0xE497", "comment": "&FA=A"},
{"address": "0xE499", "comment": "get enable event flag"},
{"address": "0xE49C", "comment": "if 0 event is not enabled so exit with SEC"},
{"address": "0xE49E", "comment": "else A=Y"},
{"address": "0xE49F", "comment": "Y=A"},
{"address": "0xE4A1", "comment": "vector through &220"},
{"address": "0xE4A4", "comment": "get back A"},
{"address": "0xE4A5", "comment": "get back flags"},
{"address": "0xE4A6", "comment": "clear carry for success"},
{"address": "0xE4A7", "comment": "and exit"},
{"address": "0xE4A8", "comment": "A=Y"},
{"address": "0xE4A9", "comment": "Y=2"},
{"address": "0xE4AB", "comment": "check event"},
{"address": "0xE4AE", "comment": "Y=A"},
{"address": "0xE4AF", "comment": "A=Y"},
{"address": "0xE4B0", "comment": "jump to INSBV"},
{"address": "0xE4B3", "comment": "save flags"},
{"address": "0xE4B4", "comment": "bar interrupts"},
{"address": "0xE4B5", "comment": "save A"},
{"address": "0xE4B6", "comment": "get buffer input pointer"},
{"address": "0xE4B9", "comment": "increment Y"},
{"address": "0xE4BA", "comment": "if Y<>0 then hasnt wrapped past end"},
{"address": "0xE4BC", "comment": "get offset to buffer start"},
{"address": "0xE4BF", "comment": "put it in A"},
{"address": "0xE4C0", "comment": "compare it with output pointer"},
{"address": "0xE4C3", "comment": "if equal buffer is full so jump forwards"},
{"address": "0xE4C5", "comment": "get unupdated input pointer back"},
{"address": "0xE4C8", "comment": "store updated input pointer"},
{"address": "0xE4CB", "comment": "and point &FA/B to buffer base"},
{"address": "0xE4CE", "comment": "get back byte"},
{"address": "0xE4CF", "comment": "store it in buffer"},
{"address": "0xE4D1", "comment": "restore interupts"},
{"address": "0xE4D2", "comment": "clear carry for success"},
{"address": "0xE4D3", "comment": "and exit"},
{"address": "0xE4D4", "comment": "get back byte"},
{"address": "0xE4D5", "comment": "are we are working on an input buffer?"},
{"address": "0xE4D7", "comment": "if output buffer, skip buffer full event"},
{"address": "0xE4D9", "comment": "else Y=1"},
{"address": "0xE4DB", "comment": "send Event 1 - Input Buffer Full"},
{"address": "0xE4DE", "comment": "push A to balance next PLA"},
{"address": "0xE4DF", "comment": "restore A"},
{"address": "0xE4E0", "comment": "restore flags"},
{"address": "0xE4E1", "comment": "set carry"},
{"address": "0xE4E2", "comment": "and exit"},
{"address": "0xE4E3", "comment": "Save A"},
{"address": "0xE4E4", "comment": "convert lower to upper case"},
{"address": "0xE4E6", "comment": "is it A or greater?"},
{"address": "0xE4E8", "comment": "if not exit routine with carry set"},
{"address": "0xE4EA", "comment": "is it less than Z"},
{"address": "0xE4EC", "comment": "if so exit with carry clear"},
{"address": "0xE4EE", "comment": "else clear carry"},
{"address": "0xE4EF", "comment": "get back original value of A"},
{"address": "0xE4F0", "comment": "and Return"},
{"address": "0xE4F1", "comment": "X=0 to indicate keyboard buffer"},
{"address": "0xE4F3", "comment": "A=buffer number"},
{"address": "0xE4F4", "comment": "and with RS423 mode (0 treat as keyboard"},
{"address": "0xE4F7", "comment": "so if RS423 buffer AND RS423 in normal mode (1) E4AF"},
{"address": "0xE4F9", "comment": "else Y=A character to write"},
{"address": "0xE4FA", "comment": "compare with current escape ASCII code (0=match)"},
{"address": "0xE4FD", "comment": "or with current ESCAPE status (0=ESC, 1=ASCII)"},
{"address": "0xE500", "comment": "if ASCII or no match E4A8 to enter byte in buffer"},
{"address": "0xE502", "comment": "else get ESCAPE/BREAK action byte"},
{"address": "0xE505", "comment": "Rotate to get ESCAPE bit into carry"},
{"address": "0xE506", "comment": "get character back in A"},
{"address": "0xE507", "comment": "and if escape disabled exit with carry clear"},
{"address": "0xE509", "comment": "else signal EVENT 6 Escape pressed"},
{"address": "0xE50E", "comment": "if event handles ESCAPE then exit with carry clear"},
{"address": "0xE510", "comment": "else set ESCAPE flag"},
{"address": "0xE513", "comment": "clear carry"},
{"address": "0xE514", "comment": "and exit"},
{"address": "0xE515", "comment": "get bit 1 into carry"},
{"address": "0xE516", "comment": "get keycode back into A"},
{"address": "0xE517", "comment": "if carry is set return keycode"},
{"address": "0xE519", "comment": "A=Y get back original key code (&80-&FF)"},
{"address": "0xE51A", "comment": "PUSH A"},
{"address": "0xE51B", "comment": "get high nybble into lo"},
{"address": "0xE51E", "comment": "A=8-&F"},
{"address": "0xE51F", "comment": "and invert bit 2"},
{"address": "0xE521", "comment": "Y=A = 8-F"},
{"address": "0xE522", "comment": "read 026D to 0274 code interpretation status"},
{"address": "0xE525", "comment": "is it 01"},
{"address": "0xE527", "comment": "if so expand as soft key via E594"},
{"address": "0xE529", "comment": "else get back original byte"},
{"address": "0xE52A", "comment": "if above CMP generated Carry then code 0 must have"},
{"address": "0xE52C", "comment": "else add ASCII to BASE key number so clear hi nybble"},
{"address": "0xE52E", "comment": "clear carry"},
{"address": "0xE52F", "comment": "add ASCII base"},
{"address": "0xE532", "comment": "clear carry"},
{"address": "0xE533", "comment": "and exit"},
{"address": "0xE534", "comment": "produce bell"},
{"address": "0xE537", "comment": "get back A, buffer number"},
{"address": "0xE538", "comment": "X=buffer number"},
{"address": "0xE539", "comment": "get byte from buffer X"},
{"address": "0xE53C", "comment": "if buffer empty E593 to exit"},
{"address": "0xE53E", "comment": "else Push byte"},
{"address": "0xE53F", "comment": "if not RS423 input buffer, skip past"},
{"address": "0xE546", "comment": "Restore X=1 (RS423 input buffer)"},
{"address": "0xE548", "comment": "set carry"},
{"address": "0xE549", "comment": "get back original byte"},
{"address": "0xE54A", "comment": "if carry clear (not RS423 input), skip past"},
{"address": "0xE54C", "comment": "check RS423 mode (0 treat as keyboard)"},
{"address": "0xE54F", "comment": "if not 0 ignore escapes etc., return with byte"},
{"address": "0xE551", "comment": "Y=byte from input buffer"},
{"address": "0xE552", "comment": "if code is less that &80 its simple so return with it"},
{"address": "0xE554", "comment": "else clear high nybble"},
{"address": "0xE556", "comment": "if less than 11 then treat as top-bit keypress"},
{"address": "0xE558", "comment": "function key or special keys"},
{"address": "0xE55A", "comment": "else add &7C (&7B +C) to convert codes &xB-&xF to &87-&8B"},
{"address": "0xE55C", "comment": "Push A"},
{"address": "0xE55D", "comment": "get cursor editing status"},
{"address": "0xE560", "comment": "not cursor editing, treat as top-bit keypress"},
{"address": "0xE562", "comment": "else get character destination status"},
{"address": "0xE565", "comment": "get bit 1 into carry"},
{"address": "0xE568", "comment": "if carry is set, VDU disabled, loop back for another keypress"},
{"address": "0xE56A", "comment": "else is it COPY key"},
{"address": "0xE56C", "comment": "jump with COPY key"},
{"address": "0xE56E", "comment": "else Y=A"},
{"address": "0xE56F", "comment": "A=X"},
{"address": "0xE570", "comment": "Push X"},
{"address": "0xE571", "comment": "get back Y"},
{"address": "0xE572", "comment": "move edit cursor"},
{"address": "0xE575", "comment": "restore X"},
{"address": "0xE576", "comment": "and drop through to loop back for another keypress"},
{"address": "0xE577", "comment": "check econet RDCH flag"},
{"address": "0xE57A", "comment": "if not set goto E581"},
{"address": "0xE57C", "comment": "else Econet function 6"},
{"address": "0xE57E", "comment": "Jump to NETV, Econet vector"},
{"address": "0xE581", "comment": "get length of keystring"},
{"address": "0xE584", "comment": "if 0 E539 get a character from the buffer"},
{"address": "0xE586", "comment": "get soft key expansion pointer"},
{"address": "0xE589", "comment": "get character from string"},
{"address": "0xE58C", "comment": "increment pointer"},
{"address": "0xE58F", "comment": "decrement length"},
{"address": "0xE593", "comment": "exit"},
{"address": "0xE594", "comment": "restore original code"},
{"address": "0xE595", "comment": "blank high nybble to get function key number"},
{"address": "0xE597", "comment": "Y=A"},
{"address": "0xE598", "comment": "get string length in A"},
{"address": "0xE59B", "comment": "and store it"},
{"address": "0xE59E", "comment": "get start point"},
{"address": "0xE5A1", "comment": "and store it"},
{"address": "0xE5A4", "comment": "if not 0 then get byte via E577 and exit"},
{"address": "0xE5A6", "comment": "A=X"},
{"address": "0xE5A7", "comment": "Push A"},
{"address": "0xE5A8", "comment": "read a character from the screen"},
{"address": "0xE5AB", "comment": "Y=A"},
{"address": "0xE5AC", "comment": "if not valid A=0 so BEEP"},
{"address": "0xE5AE", "comment": "else restore X"},
{"address": "0xE5B0", "comment": "and Y"},
{"address": "0xE5B1", "comment": "clear carry"},
{"address": "0xE5B2", "comment": "and exit"},
{"address": "0xE658", "comment": "A=0"},
{"address": "0xE659", "comment": "Jump via USERV"},
{"address": "0xE65C", "comment": "X=0"},
{"address": "0xE65E", "comment": "if bit 7 not set there is no ESCAPE condition"},
{"address": "0xE660", "comment": "so E673"},
{"address": "0xE662", "comment": "else get ESCAPE Action, if this is 0"},
{"address": "0xE665", "comment": "else do none of the above"},
{"address": "0xE667", "comment": "allow interrupts"},
{"address": "0xE668", "comment": "number of lines printed since last halt in paged"},
{"address": "0xE66B", "comment": "close any open EXEC files"},
{"address": "0xE66E", "comment": "clear all buffers"},
{"address": "0xE671", "comment": "X=&FF to indicate ESCAPE acknowledged"},
{"address": "0xE673", "comment": "clear carry"},
{"address": "0xE674", "comment": "clear  bit 7 of ESCAPE flag"},
{"address": "0xE676", "comment": "read bit 7 of Tube flag"},
{"address": "0xE679", "comment": "if set TUBE exists so E67C"},
{"address": "0xE67B", "comment": "else RETURN"},
{"address": "0xE67C", "comment": "Jump to Tube entry point"},
{"address": "0xE67F", "comment": "get serial ULA control setting"},
{"address": "0xE682", "comment": "Y=A"},
{"address": "0xE683", "comment": "rotate left to get bit 7 into carry"},
{"address": "0xE684", "comment": "if X=1 then user wants motor on so CARRY set else"},
{"address": "0xE686", "comment": "put carry back in control RAM copy"},
{"address": "0xE687", "comment": "if bit 6 is clear then cassette is selected"},
{"address": "0xE689", "comment": "Convert 8 to &38 for *FX8"},
{"address": "0xE68B", "comment": "convert to mask, rx 7 to &38, tx 8 to &07"},
{"address": "0xE68D", "comment": "store result"},
{"address": "0xE68F", "comment": "get serial ULA control register setting"},
{"address": "0xE692", "comment": "is it 9 or more?"},
{"address": "0xE694", "comment": "if so exit, return current ULA setting"},
{"address": "0xE696", "comment": "AND with byte from lookup table"},
{"address": "0xE699", "comment": "store it, %00abc000 for rx, &00000def for tx"},
{"address": "0xE69B", "comment": "get current serial ULA register in Y into A"},
{"address": "0xE69C", "comment": "ORA with rx/tx mask,  %st111xyz for rx, %stuvw111 for tx"},
{"address": "0xE69E", "comment": "toggle them to zero,  %st000xyz for rx, %stuvw000 for tx"},
{"address": "0xE6A0", "comment": "merge in lookup bits, %stabcxyz for rx, %stuvwdef for tx"},
{"address": "0xE6A2", "comment": "set bit 6 for serial, %x1abcxyz for rx, %s1uvwdef for tx"},
{"address": "0xE6A4", "comment": "toggle bit 6 via cassette/RS423 flag"},
{"address": "0xE6A7", "comment": "store serial ULA flag"},
{"address": "0xE6AA", "comment": "and write to control register"},
{"address": "0xE6AD", "comment": "put Y in A to return old contents in X"},
{"address": "0xE6AE", "comment": "return old setting in X"},
{"address": "0xE6AF", "comment": "and return"},
{"address": "0xE6B0", "comment": "Y is incremented to 1"},
{"address": "0xE6B1", "comment": "clear carry"},
{"address": "0xE6B2", "comment": "get mark period count"},
{"address": "0xE6B5", "comment": "push it"},
{"address": "0xE6B6", "comment": "get new count"},
{"address": "0xE6B7", "comment": "store it"},
{"address": "0xE6BA", "comment": "get back original value"},
{"address": "0xE6BB", "comment": "put it in Y"},
{"address": "0xE6BC", "comment": "get value of flash counter"},
{"address": "0xE6BF", "comment": "if not zero E6D1"},
{"address": "0xE6C1", "comment": "else restore old value"},
{"address": "0xE6C4", "comment": "get current video ULA control register setting"},
{"address": "0xE6C7", "comment": "push flags"},
{"address": "0xE6C8", "comment": "rotate bit 0 into carry, carry into bit 7"},
{"address": "0xE6C9", "comment": "get back flags"},
{"address": "0xE6CA", "comment": "rotate back carry into bit 0"},
{"address": "0xE6CB", "comment": "store it in RAM copy"},
{"address": "0xE6CE", "comment": "and ULA control register"},
{"address": "0xE6D1", "comment": "return old setting in X"},
{"address": "0xE6D3", "comment": "A=X"},
{"address": "0xE6D4", "comment": "blank out bits 1 - 7"},
{"address": "0xE6D6", "comment": "push A"},
{"address": "0xE6D7", "comment": "and get current ACIA control setting"},
{"address": "0xE6DA", "comment": "Bit 7 into carry"},
{"address": "0xE6DB", "comment": "if X>=1 then"},
{"address": "0xE6DD", "comment": "bit 7 of A=1"},
{"address": "0xE6DE", "comment": "compare this with ACIA control setting"},
{"address": "0xE6E1", "comment": "push flags"},
{"address": "0xE6E2", "comment": "put A into ACIA control setting"},
{"address": "0xE6E5", "comment": "and write to control register"},
{"address": "0xE6E8", "comment": "set up RS423 buffer"},
{"address": "0xE6EB", "comment": "get flags back"},
{"address": "0xE6EC", "comment": "if new setting different from old E6F1 else"},
{"address": "0xE6EE", "comment": "set bit 6 and 7"},
{"address": "0xE6F1", "comment": "get current input buffer number"},
{"address": "0xE6F4", "comment": "get A back"},
{"address": "0xE6F5", "comment": "store it"},
{"address": "0xE6F8", "comment": "and return"},
{"address": "0xE6F9", "comment": "Y=0 A=0"},
{"address": "0xE6FA", "comment": "if X>9"},
{"address": "0xE6FC", "comment": "goto E6AE for exit"},
{"address": "0xE6FE", "comment": "else get event enable flag"},
{"address": "0xE701", "comment": "store new value in flag"},
{"address": "0xE704", "comment": "and exit via E6AD"},
{"address": "0xE706", "comment": "if X=0 then E70B"},
{"address": "0xE708", "comment": "start conversion"},
{"address": "0xE70B", "comment": "get current maximum ADC channel number"},
{"address": "0xE70E", "comment": "store new value"},
{"address": "0xE711", "comment": "put old value in X"},
{"address": "0xE712", "comment": "and exit"},
{"address": "0xE713", "comment": "A=Y"},
{"address": "0xE714", "comment": "if Y=&FF the E721"},
{"address": "0xE716", "comment": "else allow interrupts"},
{"address": "0xE717", "comment": "and go to timed routine"},
{"address": "0xE71A", "comment": "if carry set then E71F"},
{"address": "0xE71C", "comment": "then X=A"},
{"address": "0xE71D", "comment": "A=0"},
{"address": "0xE71F", "comment": "Y=A"},
{"address": "0xE720", "comment": "and return"},
{"address": "0xE721", "comment": "A=X"},
{"address": "0xE722", "comment": "convert to keyboard scan code, keeping bit 7"},
{"address": "0xE724", "comment": "X=A"},
{"address": "0xE725", "comment": "then scan keyboard"},
{"address": "0xE728", "comment": "put bit 7 into carry"},
{"address": "0xE729", "comment": "X=&FF"},
{"address": "0xE72B", "comment": "Y=&FF"},
{"address": "0xE72D", "comment": "if bit 7 of A was set goto E731 (RTS)"},
{"address": "0xE72F", "comment": "else X=0"},
{"address": "0xE730", "comment": "and Y=0"},
{"address": "0xE731", "comment": "and exit"},
{"address": "0xE732", "comment": "buffer number in A"},
{"address": "0xE733", "comment": "invert it"},
{"address": "0xE735", "comment": "X=A"},
{"address": "0xE736", "comment": "is X>1"},
{"address": "0xE738", "comment": "clear V flag"},
{"address": "0xE739", "comment": "and goto E73E count buffer"},
{"address": "0xE73B", "comment": "set V"},
{"address": "0xE73E", "comment": "CNPV defaults to E1D1"},
{"address": "0xE742", "comment": "X=1 to point to buffer"},
{"address": "0xE744", "comment": "and count it"},
{"address": "0xE747", "comment": "if the hi byte of the answer is 1 or more"},
{"address": "0xE749", "comment": "then Return"},
{"address": "0xE74B", "comment": "else compare with minimum buffer space"},
{"address": "0xE74E", "comment": "and exit"},
{"address": "0xE74F", "comment": "if X is -ve then E732 count spaces"},
{"address": "0xE751", "comment": "if X=0 then E75F"},
{"address": "0xE753", "comment": "else check for Valid channel"},
{"address": "0xE755", "comment": "if not E729 set X & Y to 0 and exit (*BUG* should pass to ROMs)"},
{"address": "0xE757", "comment": "get conversion values for channel of interest Hi &"},
{"address": "0xE75A", "comment": "lo byte"},
{"address": "0xE75D", "comment": "X=lo byte"},
{"address": "0xE75E", "comment": "and exit"},
{"address": "0xE75F", "comment": "read system VIA port B"},
{"address": "0xE762", "comment": "move high nybble to low"},
{"address": "0xE766", "comment": "and invert it"},
{"address": "0xE768", "comment": "isolate the FIRE buttons"},
{"address": "0xE76A", "comment": "get analogue system flag byte"},
{"address": "0xE76D", "comment": "store X here"},
{"address": "0xE770", "comment": "A=X bits 0 and 1 indicate fire buttons"},
{"address": "0xE771", "comment": "and return"},
{"address": "0xE772", "comment": "save A"},
{"address": "0xE773", "comment": "save Processor flags"},
{"address": "0xE774", "comment": "disable interrupts"},
{"address": "0xE775", "comment": "store A,X,Y in zero page"},
{"address": "0xE77B", "comment": "X=7 to signal osbyte is being attempted"},
{"address": "0xE77D", "comment": "if A=0-116"},
{"address": "0xE77F", "comment": "then E7C2"},
{"address": "0xE781", "comment": "if A<161"},
{"address": "0xE783", "comment": "then E78E"},
{"address": "0xE785", "comment": "if A=161-165"},
{"address": "0xE787", "comment": "then EC78"},
{"address": "0xE789", "comment": "clear carry"},
{"address": "0xE78A", "comment": "A=&A1"},
{"address": "0xE78E", "comment": "set carry"},
{"address": "0xE78F", "comment": "convert to &16 to &41 (22-65)"},
{"address": "0xE791", "comment": "double it (44-130)"},
{"address": "0xE792", "comment": "set carry"},
{"address": "0xE793", "comment": "store Y"},
{"address": "0xE795", "comment": "Y=A"},
{"address": "0xE796", "comment": "read econet intercept flag"},
{"address": "0xE799", "comment": "if no econet intercept required E7A2"},
{"address": "0xE79B", "comment": "else A=X"},
{"address": "0xE79C", "comment": "V=0"},
{"address": "0xE79D", "comment": "to JMP via ECONET vector"},
{"address": "0xE7A0", "comment": "if return with V set E7BC"},
{"address": "0xE7A2", "comment": "get address from table"},
{"address": "0xE7A5", "comment": "store it as hi byte"},
{"address": "0xE7A7", "comment": "repeat for lo byte"},
{"address": "0xE7AC", "comment": "restore A"},
{"address": "0xE7AE", "comment": "Y"},
{"address": "0xE7B0", "comment": "if carry is set E7B6"},
{"address": "0xE7B2", "comment": "else"},
{"address": "0xE7B4", "comment": "get value from address pointed to by &F0/1 (Y,X)"},
{"address": "0xE7B6", "comment": "set carry"},
{"address": "0xE7B7", "comment": "restore X"},
{"address": "0xE7B9", "comment": "call &FA/B"},
{"address": "0xE7BC", "comment": "C=bit 0"},
{"address": "0xE7BD", "comment": "get back flags"},
{"address": "0xE7BE", "comment": "bit 0=Carry"},
{"address": "0xE7BF", "comment": "get back A"},
{"address": "0xE7C0", "comment": "clear V"},
{"address": "0xE7C1", "comment": "and exit"},
{"address": "0xE7C2", "comment": "Y=0"},
{"address": "0xE7C4", "comment": "if A<&16"},
{"address": "0xE7C6", "comment": "goto E791"},
{"address": "0xE7C8", "comment": "push flags"},
{"address": "0xE7C9", "comment": "push flags"},
{"address": "0xE7CA", "comment": "pull flags"},
{"address": "0xE7CB", "comment": "pull flags"},
{"address": "0xE7CC", "comment": "offer paged ROMs service 7/8 unrecognised osbyte/word"},
{"address": "0xE7CF", "comment": "if roms dont recognise it then E7D6"},
{"address": "0xE7D1", "comment": "else restore X"},
{"address": "0xE7D3", "comment": "and exit"},
{"address": "0xE7D6", "comment": "else pull flags"},
{"address": "0xE7D7", "comment": "and A"},
{"address": "0xE7D8", "comment": "set V and C"},
{"address": "0xE7DB", "comment": "and return"},
{"address": "0xE7DC", "comment": "read cassette critical flag bit 7 = busy"},
{"address": "0xE7DE", "comment": "if busy then EB12"},
{"address": "0xE7E0", "comment": "else A=8 to check current Catalogue status"},
{"address": "0xE7E2", "comment": "by ANDing with CFS status flag"},
{"address": "0xE7E4", "comment": "if not set (not in use) then E7EA RTS"},
{"address": "0xE7E6", "comment": "A=%10001000"},
{"address": "0xE7E8", "comment": "AND with FS options (short msg bits)"},
{"address": "0xE7EA", "comment": "RETURN"},
{"address": "0xE7EB", "comment": "Push A"},
{"address": "0xE7EC", "comment": "Push flags"},
{"address": "0xE7ED", "comment": "disable interrupts"},
{"address": "0xE7EE", "comment": "store A,X,Y"},
{"address": "0xE7F4", "comment": "X=8"},
{"address": "0xE7F6", "comment": "if A=>224"},
{"address": "0xE7F8", "comment": "then E78A with carry set"},
{"address": "0xE7FA", "comment": "else if A=>14"},
{"address": "0xE7FC", "comment": "else E7C8 with carry set pass to ROMs & exit"},
{"address": "0xE7FE", "comment": "add to form pointer to table"},
{"address": "0xE800", "comment": "double it"},
{"address": "0xE801", "comment": "goto E793 ALWAYS (carry clear E7F8)"},
{"address": "0xE803", "comment": "set up address of data block"},
{"address": "0xE806", "comment": "get byte"},
{"address": "0xE808", "comment": "store it"},
{"address": "0xE80A", "comment": "exit"},
{"address": "0xE80B", "comment": "set up address"},
{"address": "0xE80E", "comment": "get byte"},
{"address": "0xE810", "comment": "store it"},
{"address": "0xE812", "comment": "a=0"},
{"address": "0xE814", "comment": "exit"},
{"address": "0xE815", "comment": "&FA=A"},
{"address": "0xE817", "comment": "Y=1"},
{"address": "0xE818", "comment": "get byte from block"},
{"address": "0xE81A", "comment": "store it"},
{"address": "0xE81C", "comment": "Y=4"},
{"address": "0xE81E", "comment": "X=1"},
{"address": "0xE820", "comment": "and exit"},
{"address": "0xE821", "comment": "if A <> 0 then exit with X=OS, else generate error"},
{"address": "0xE82E", "comment": "Get channel high byte"},
{"address": "0xE832", "comment": "Channel &FFxx, speech command"},
{"address": "0xE834", "comment": "Is channel>=&20 ?"},
{"address": "0xE836", "comment": "Prepare X=8 for unrecognised OSWORD call"},
{"address": "0xE838", "comment": "Pass to sideways ROMs for channel &2000+"},
{"address": "0xE83A", "comment": "Point back to channel low byte"},
{"address": "0xE83B", "comment": "Get Channel 0-3, and Cy if >=&10 for Flush"},
{"address": "0xE83E", "comment": "Convert to buffer number 4-7"},
{"address": "0xE841", "comment": "If not Flush, skip past"},
{"address": "0xE843", "comment": "Flush buffer"},
{"address": "0xE846", "comment": "Point back to channel high byte"},
{"address": "0xE848", "comment": "Get Sync 0-3, and Cy if >=&10 for Hold"},
{"address": "0xE84B", "comment": "Save Sync in &FA"},
{"address": "0xE84D", "comment": "Stack flags"},
{"address": "0xE850", "comment": "Get Duration byte"},
{"address": "0xE852", "comment": "and stack it"},
{"address": "0xE855", "comment": "Get pitch byte"},
{"address": "0xE857", "comment": "and stack it"},
{"address": "0xE85A", "comment": "Get amplitude/envelope byte"},
{"address": "0xE85C", "comment": "Move Hold into bit 0"},
{"address": "0xE85D", "comment": "set carry"},
{"address": "0xE85E", "comment": "subract 2"},
{"address": "0xE860", "comment": "multiply by 4"},
{"address": "0xE862", "comment": "add S byte (0-3)"},
{"address": "0xE864", "comment": "Wait for space and insert into buffer"},
{"address": "0xE867", "comment": "Byte inserted, jump to insert the rest"},
{"address": "0xE869", "comment": "Insert aborted (Escape pressed), drop stacked pitch"},
{"address": "0xE86A", "comment": "Drop stacked duration"},
{"address": "0xE86B", "comment": "Restore flags"},
{"address": "0xE86C", "comment": "get VDU status byte in X"},
{"address": "0xE86E", "comment": "and return"},
{"address": "0xE86F", "comment": "push P"},
{"address": "0xE870", "comment": "bar interrupts"},
{"address": "0xE871", "comment": "get bell channel number in A"},
{"address": "0xE874", "comment": "(bits 0-3 only set)"},
{"address": "0xE876", "comment": "set bit 2"},
{"address": "0xE878", "comment": "X=A = bell channel number +4=buffer number"},
{"address": "0xE879", "comment": "get bell amplitude/envelope number"},
{"address": "0xE87C", "comment": "store it in buffer pointed to by X"},
{"address": "0xE87F", "comment": "get bell duration"},
{"address": "0xE882", "comment": "save it"},
{"address": "0xE883", "comment": "get bell frequency"},
{"address": "0xE886", "comment": "save it"},
{"address": "0xE887", "comment": "Set carry"},
{"address": "0xE888", "comment": "Set bit 7 of channel flags to indicate its active"},
{"address": "0xE88B", "comment": "Jump forward to insert pitch and duration"},
{"address": "0xE88D", "comment": "Save flags"},
{"address": "0xE88E", "comment": "Y=2"},
{"address": "0xE88F", "comment": "Get word number low byte"},
{"address": "0xE891", "comment": "and stack it"},
{"address": "0xE892", "comment": "Y=3"},
{"address": "0xE893", "comment": "Get word number high byte"},
{"address": "0xE895", "comment": "and stack it"},
{"address": "0xE896", "comment": "Y=0"},
{"address": "0xE898", "comment": "Get speech command"},
{"address": "0xE89A", "comment": "X=8 for Speech buffer"},
{"address": "0xE89C", "comment": "Insert speech command into speech buffer"},
{"address": "0xE89F", "comment": "Buffer insert aborted (Escape pressed), drop stack and abandon"},
{"address": "0xE8A1", "comment": "Clear bit 7 of speech buffer busy flag"},
{"address": "0xE8A4", "comment": "Get word number high byte or pitch back"},
{"address": "0xE8A5", "comment": "Insert into speech buffer or sound buffer"},
{"address": "0xE8A8", "comment": "Get word number low byte or duration back"},
{"address": "0xE8A9", "comment": "Insert into speech buffer or sound buffer"},
{"address": "0xE8AC", "comment": "Restore flags"},
{"address": "0xE8AD", "comment": "and return"},
{"address": "0xE8AE", "comment": "set up appropriate displacement to storage area"},
{"address": "0xE8B0", "comment": "A=(A-1)*16 or 15"},
{"address": "0xE8B6", "comment": "X=A"},
{"address": "0xE8B7", "comment": "A=0"},
{"address": "0xE8B9", "comment": "Y=&10"},
{"address": "0xE8BB", "comment": "is Y>=14??"},
{"address": "0xE8BD", "comment": "yes then E8C1"},
{"address": "0xE8BF", "comment": "else get byte from parameter block"},
{"address": "0xE8C1", "comment": "and store it in appropriate area"},
{"address": "0xE8C4", "comment": "decrement X"},
{"address": "0xE8C5", "comment": "Decrement Y"},
{"address": "0xE8C6", "comment": "if not 0 then do it again"},
{"address": "0xE8C8", "comment": "else exit"},
{"address": "0xE8C9", "comment": "get byte"},
{"address": "0xE8CB", "comment": "is it greater than 15, if so set carry"},
{"address": "0xE8CD", "comment": "AND 3 to keep channel in bits 0-1"},
{"address": "0xE8CF", "comment": "increment Y, step to next parameter byte"},
{"address": "0xE8D0", "comment": "and exit"},
{"address": "0xE8D1", "comment": "X=&F displacement from clock to timer"},
{"address": "0xE8D3", "comment": "jump to E8D8"},
{"address": "0xE8D5", "comment": "X=current system clock store pointer"},
{"address": "0xE8D8", "comment": "Y=4"},
{"address": "0xE8DA", "comment": "read byte"},
{"address": "0xE8DD", "comment": "store it in parameter block"},
{"address": "0xE8DF", "comment": "X=x+1"},
{"address": "0xE8E0", "comment": "Y=Y-1"},
{"address": "0xE8E1", "comment": "if Y>0 then do it again"},
{"address": "0xE8E3", "comment": "else exit"},
{"address": "0xE8E4", "comment": "offset between clock and timer"},
{"address": "0xE8E6", "comment": "jump to E8EE ALWAYS!!"},
{"address": "0xE8E8", "comment": "get current clock store pointer"},
{"address": "0xE8EB", "comment": "and invert to get inactive timer"},
{"address": "0xE8ED", "comment": "clear carry"},
{"address": "0xE8EE", "comment": "store A"},
{"address": "0xE8EF", "comment": "X=A"},
{"address": "0xE8F0", "comment": "Y=4"},
{"address": "0xE8F2", "comment": "and transfer all 5 bytes"},
{"address": "0xE8F4", "comment": "to the clock or timer"},
{"address": "0xE8F9", "comment": "if Y>0 then E8F2"},
{"address": "0xE8FB", "comment": "get back stack"},
{"address": "0xE8FC", "comment": "if set (write to timer) E8E3 exit"},
{"address": "0xE8FE", "comment": "write back current clock store"},
{"address": "0xE901", "comment": "and exit"},
{"address": "0xE902", "comment": "Y=4"},
{"address": "0xE904", "comment": "transfer bytes 4,3,2 to 2B3-2B5"},
{"address": "0xE909", "comment": "decrement Y"},
{"address": "0xE90A", "comment": "until Y=1"},
{"address": "0xE90E", "comment": "get address of input buffer"},
{"address": "0xE910", "comment": "store it in &E9 as temporary buffer"},
{"address": "0xE912", "comment": "decrement Y"},
{"address": "0xE913", "comment": "Y=0 store in print line counter for paged mode"},
{"address": "0xE916", "comment": "get lo byte of address"},
{"address": "0xE918", "comment": "and store in &E8"},
{"address": "0xE91A", "comment": "allow interrupts"},
{"address": "0xE91B", "comment": "Jump to E924"},
{"address": "0xE91D", "comment": "A=7"},
{"address": "0xE91F", "comment": "decrement Y"},
{"address": "0xE920", "comment": "increment Y"},
{"address": "0xE921", "comment": "and call OSWRCH"},
{"address": "0xE924", "comment": "else read character  from input stream"},
{"address": "0xE927", "comment": "if carry set then illegal character or other error"},
{"address": "0xE929", "comment": "X=A"},
{"address": "0xE92A", "comment": "A=&27C get character destination status"},
{"address": "0xE92D", "comment": "put VDU driver bit in carry"},
{"address": "0xE92E", "comment": "if this is 1 VDU driver is disabled"},
{"address": "0xE92F", "comment": "X=A"},
{"address": "0xE930", "comment": "if Carry set E937"},
{"address": "0xE932", "comment": "get number of items in VDU queque"},
{"address": "0xE935", "comment": "if not 0 output character and loop round again"},
{"address": "0xE937", "comment": "if character is not delete"},
{"address": "0xE939", "comment": "goto E942"},
{"address": "0xE93B", "comment": "else is Y=0"},
{"address": "0xE93D", "comment": "and goto E924"},
{"address": "0xE93F", "comment": "decrement Y"},
{"address": "0xE940", "comment": "and if carry set E921 to output it"},
{"address": "0xE942", "comment": "is it delete line &21"},
{"address": "0xE944", "comment": "if not E953"},
{"address": "0xE946", "comment": "else Y=A, if its 0 we are still reading first"},
{"address": "0xE947", "comment": "so E924"},
{"address": "0xE949", "comment": "else output DELETES"},
{"address": "0xE94B", "comment": "until Y=0"},
{"address": "0xE951", "comment": "then read character again"},
{"address": "0xE953", "comment": "store character in designated buffer"},
{"address": "0xE955", "comment": "is it CR?"},
{"address": "0xE957", "comment": "if so E96C"},
{"address": "0xE959", "comment": "else check the line length"},
{"address": "0xE95C", "comment": "if = or greater loop to ring bell"},
{"address": "0xE95E", "comment": "check minimum character"},
{"address": "0xE961", "comment": "if less than minimum backspace"},
{"address": "0xE963", "comment": "check maximum character"},
{"address": "0xE966", "comment": "if equal E920"},
{"address": "0xE968", "comment": "or less E920"},
{"address": "0xE96A", "comment": "then JUMP E91F"},
{"address": "0xE96C", "comment": "output CR/LF"},
{"address": "0xE96F", "comment": "call Econet vector with A=13"},
{"address": "0xE972", "comment": "A=ESCAPE FLAG"},
{"address": "0xE974", "comment": "put bit 7 into carry"},
{"address": "0xE975", "comment": "and exit routine"},
{"address": "0xE976", "comment": "allow interrupts briefly"},
{"address": "0xE977", "comment": "bar interrupts"},
{"address": "0xE978", "comment": "check if ESCAPE is pending"},
{"address": "0xE97A", "comment": "if it is E9AC"},
{"address": "0xE97C", "comment": "else check bit 7 buffer 3 (printer)"},
{"address": "0xE97F", "comment": "if not empty bit 7=0 E976"},
{"address": "0xE981", "comment": "check for user defined routine"},
{"address": "0xE984", "comment": "Y=0"},
{"address": "0xE986", "comment": "F1=0"},
{"address": "0xE988", "comment": "A=osbyte +&F0"},
{"address": "0xE98A", "comment": "JUMP to E99A"},
{"address": "0xE98C", "comment": "if &F0<>0 goto E995"},
{"address": "0xE98E", "comment": "if X=0 in original call then X=32"},
{"address": "0xE990", "comment": "to set keyboard autorepeat delay ram copy"},
{"address": "0xE993", "comment": "X=8"},
{"address": "0xE995", "comment": "A=A+&D0 (carry set)"},
{"address": "0xE997", "comment": "clear carry"},
{"address": "0xE998", "comment": "A=A+&E9"},
{"address": "0xE99A", "comment": "store X"},
{"address": "0xE99C", "comment": "Y=A"},
{"address": "0xE99D", "comment": "i.e. A=&190 +osbyte call number"},
{"address": "0xE9A0", "comment": "preserve this"},
{"address": "0xE9A1", "comment": "new value = OLD value AND Y EOR X!"},
{"address": "0xE9A5", "comment": "store it"},
{"address": "0xE9A8", "comment": "get value of next byte into A"},
{"address": "0xE9AB", "comment": "Y=A"},
{"address": "0xE9AC", "comment": "and exit"},
{"address": "0xE9B6", "comment": "read vertical sync counter"},
{"address": "0xE9B9", "comment": "allow interrupts briefly"},
{"address": "0xE9BA", "comment": "bar interrupts"},
{"address": "0xE9BB", "comment": "has it changed?"},
{"address": "0xE9BE", "comment": "no then E9B9"},
{"address": "0xE9C0", "comment": "get VDU variable hi"},
{"address": "0xE9C3", "comment": "low"},
{"address": "0xE9C6", "comment": "X=low byte"},
{"address": "0xE9C7", "comment": "and exit"},
{"address": "0xE9C8", "comment": "set consistency flag"},
{"address": "0xE9CD", "comment": "X=0"},
{"address": "0xE9CF", "comment": "and wipe clean"},
{"address": "0xE9D2", "comment": "soft key buffer"},
{"address": "0xE9D3", "comment": "until X=0 again"},
{"address": "0xE9D5", "comment": "zero consistency flag"},
{"address": "0xE9D8", "comment": "and exit"},
{"address": "0xE9D9", "comment": "save flags"},
{"address": "0xE9DA", "comment": "disable interupts"},
{"address": "0xE9DB", "comment": "switch on CAPS and SHIFT lock lights"},
{"address": "0xE9DD", "comment": "via subroutine"},
{"address": "0xE9E0", "comment": "if ESCAPE exists (M set) E9E7"},
{"address": "0xE9E2", "comment": "else clear V and C"},
{"address": "0xE9E3", "comment": "before calling main keyboard routine to"},
{"address": "0xE9E4", "comment": "switch on lights and read Ctrl and Shift to A=%csxxxxxx"},
{"address": "0xE9E7", "comment": "restore IRQs"},
{"address": "0xE9E8", "comment": "rotate bit 7 (Ctrl) into Carry, and bit 6 (Shift) into Minus"},
{"address": "0xE9E9", "comment": "return to calling routine, A=%sxxxxxxx, C=Ctrl, M=Shift"},
{"address": "0xE9EA", "comment": "if carry clear"},
{"address": "0xE9EC", "comment": "switch on shift lock light"},
{"address": "0xE9F1", "comment": "Y=6"},
{"address": "0xE9F2", "comment": "switch on Caps lock light"},
{"address": "0xE9F5", "comment": "set minus flag if bit 7 of &00FF is set indicating"},
{"address": "0xE9F7", "comment": "that ESCAPE condition exists, then return"},
{"address": "0xE9F8", "comment": "push flags"},
{"address": "0xE9F9", "comment": "disable interupts"},
{"address": "0xE9FA", "comment": "write register B from Accumulator"},
{"address": "0xE9FD", "comment": "get back flags"},
{"address": "0xE9FE", "comment": "and exit"},
{"address": "0xE9FF", "comment": "osbyte entry, X transferred to A thence to"},
{"address": "0xEA00", "comment": "save flags"},
{"address": "0xEA01", "comment": "disable interupts"},
{"address": "0xEA02", "comment": "save RAM copy of new parameter"},
{"address": "0xEA05", "comment": "write to control register"},
{"address": "0xEA08", "comment": "read  space count"},
{"address": "0xEA0B", "comment": "set flash counter to this value"},
{"address": "0xEA0E", "comment": "get back status"},
{"address": "0xEA0F", "comment": "and return"},
{"address": "0xEA10", "comment": "A=X"},
{"address": "0xEA11", "comment": "convert to palette format"},
{"address": "0xEA14", "comment": "prevent interrupts"},
{"address": "0xEA15", "comment": "store as current palette setting"},
{"address": "0xEA18", "comment": "store actual colour in register"},
{"address": "0xEA1B", "comment": "get back flags"},
{"address": "0xEA1C", "comment": "and exit"},
{"address": "0xEA1D", "comment": "clear carry"},
{"address": "0xEA1E", "comment": "Rotate moves carry to &E4"},
{"address": "0xEA20", "comment": "skip spaces and get character"},
{"address": "0xEA23", "comment": "increment Y to point to next character"},
{"address": "0xEA24", "comment": "check to see if its"},
{"address": "0xEA26", "comment": "if so EA2A (carry set)"},
{"address": "0xEA28", "comment": "decrement Y"},
{"address": "0xEA29", "comment": "clear carry"},
{"address": "0xEA2A", "comment": "move bit 7 to bit 6 and put carry in bit 7"},
{"address": "0xEA2C", "comment": "check to see if its CR to set Z"},
{"address": "0xEA2E", "comment": "and return"},
{"address": "0xEA2F", "comment": "A=0"},
{"address": "0xEA31", "comment": "store A"},
{"address": "0xEA33", "comment": "read first character"},
{"address": "0xEA35", "comment": "is it CR"},
{"address": "0xEA37", "comment": "if not goto EA3F"},
{"address": "0xEA39", "comment": "if bit 7=1 no 2nd  found"},
{"address": "0xEA3B", "comment": "goto EA8F - error Bad string"},
{"address": "0xEA3D", "comment": "if not EA5A"},
{"address": "0xEA3F", "comment": "is it a control character?"},
{"address": "0xEA41", "comment": "if so, go to EA8F - error Bad string"},
{"address": "0xEA43", "comment": "if its not a space EA4B"},
{"address": "0xEA45", "comment": "is bit 7 of &E4 =1"},
{"address": "0xEA47", "comment": "if so goto EA89"},
{"address": "0xEA49", "comment": "if bit 6 = 0 EA5A"},
{"address": "0xEA4B", "comment": "is it"},
{"address": "0xEA4D", "comment": "if not EA5F"},
{"address": "0xEA4F", "comment": "if so and Bit 7 of &E4 =0 (no previous )"},
{"address": "0xEA51", "comment": "then EA89"},
{"address": "0xEA53", "comment": "else point at next character"},
{"address": "0xEA54", "comment": "get it"},
{"address": "0xEA56", "comment": "is it"},
{"address": "0xEA58", "comment": "if so then EA89"},
{"address": "0xEA5A", "comment": "skip spaces and read a byte from text"},
{"address": "0xEA5D", "comment": "and return with carry set"},
{"address": "0xEA5E", "comment": "and (&F2),Y=>any following text"},
{"address": "0xEA5F", "comment": "is it |"},
{"address": "0xEA61", "comment": "if not EA89"},
{"address": "0xEA63", "comment": "if so increase Y to point to next character"},
{"address": "0xEA64", "comment": "get it"},
{"address": "0xEA66", "comment": "and compare it with | again"},
{"address": "0xEA68", "comment": "if its | then EA89"},
{"address": "0xEA6A", "comment": "else is it"},
{"address": "0xEA6C", "comment": "if so then EA89"},
{"address": "0xEA6E", "comment": "is it !"},
{"address": "0xEA70", "comment": "if not then EA77"},
{"address": "0xEA72", "comment": "increment Y again"},
{"address": "0xEA73", "comment": "set bit 7"},
{"address": "0xEA75", "comment": "loop back to EA31 to set bit 7 in next CHR"},
{"address": "0xEA77", "comment": "is it a space"},
{"address": "0xEA79", "comment": "if less than EA8F Bad String Error"},
{"address": "0xEA7B", "comment": "is it ?"},
{"address": "0xEA7D", "comment": "if so EA87"},
{"address": "0xEA7F", "comment": "else modify code as if CTRL had been pressed"},
{"address": "0xEA82", "comment": "if bit 6 set"},
{"address": "0xEA85", "comment": "then EA8A"},
{"address": "0xEA87", "comment": "else set bits 0 to 6 in A"},
{"address": "0xEA89", "comment": "clear V"},
{"address": "0xEA8A", "comment": "increment Y"},
{"address": "0xEA8B", "comment": "add in any bit 7 from |! prefix"},
{"address": "0xEA8D", "comment": "clear carry"},
{"address": "0xEA8E", "comment": "Return"},
{"address": "0xEA9C", "comment": "if A=0 skip routine"},
{"address": "0xEAA0", "comment": "if A=@ skip routine"},
{"address": "0xEAA4", "comment": "if A<@ then EAB8"},
{"address": "0xEAA6", "comment": "else is it DELETE"},
{"address": "0xEAA8", "comment": "if so skip routine"},
{"address": "0xEAAA", "comment": "if greater than &7F then toggle bit 4"},
{"address": "0xEAAC", "comment": "reverse bits 4 and 5"},
{"address": "0xEAAE", "comment": "is it &6F (previously  _ (&5F))"},
{"address": "0xEAB0", "comment": "goto EAB6"},
{"address": "0xEAB2", "comment": "is it &50 (previously ` (&60))"},
{"address": "0xEAB4", "comment": "if not EAB8"},
{"address": "0xEAB6", "comment": "else continue to convert ` _"},
{"address": "0xEAB8", "comment": "compare &21 !"},
{"address": "0xEABA", "comment": "if less than return"},
{"address": "0xEABC", "comment": "else finish conversion by toggling bit 4"},
{"address": "0xEABE", "comment": "exit"},
{"address": "0xEABF", "comment": "is it DEL"},
{"address": "0xEAC1", "comment": "if so ignore routine"},
{"address": "0xEAC3", "comment": "if greater than &7F go to EAAC"},
{"address": "0xEAC5", "comment": "if A<>`"},
{"address": "0xEAC7", "comment": "goto EACB"},
{"address": "0xEAC9", "comment": "if A=&60, A=&5F"},
{"address": "0xEACB", "comment": "if A<&40"},
{"address": "0xEACD", "comment": "goto EAD1  and return unchanged"},
{"address": "0xEACF", "comment": "else zero bits 5 to 7"},
{"address": "0xEAD1", "comment": "return"},
{"address": "0xEAD9", "comment": "get BREAK vector code"},
{"address": "0xEADC", "comment": "produces 0 if JMP not in &287"},
{"address": "0xEADE", "comment": "if not goto EAF3"},
{"address": "0xEAE0", "comment": "else jump to user BREAK code"},
{"address": "0xEAE3", "comment": "VDU vertical adjustment"},
{"address": "0xEAE6", "comment": "store new value"},
{"address": "0xEAE9", "comment": "put old value in X"},
{"address": "0xEAEA", "comment": "put interlace flag in A"},
{"address": "0xEAEB", "comment": "maximum value =1"},
{"address": "0xEAED", "comment": "get old value into Y"},
{"address": "0xEAF0", "comment": "put new value into A"},
{"address": "0xEAF3", "comment": "and Exit"},
{"address": "0xEB03", "comment": "mark end of release phase"},
{"address": "0xEB05", "comment": "to channel X"},
{"address": "0xEB08", "comment": "load code for zero volume"},
{"address": "0xEB0A", "comment": "store A to give basic sound level of Zero"},
{"address": "0xEB0D", "comment": "get sound output/enable flag"},
{"address": "0xEB10", "comment": "if sound enabled goto EB14"},
{"address": "0xEB12", "comment": "else load zero sound code"},
{"address": "0xEB14", "comment": "set carry"},
{"address": "0xEB15", "comment": "subtract &40"},
{"address": "0xEB17", "comment": "divide by 8"},
{"address": "0xEB18", "comment": "to get into bits 0 - 3"},
{"address": "0xEB1A", "comment": "invert bits 0-3"},
{"address": "0xEB1C", "comment": "get channel number into top nybble"},
{"address": "0xEB22", "comment": "disable interrupts"},
{"address": "0xEB23", "comment": "System VIA port A all outputs"},
{"address": "0xEB25", "comment": "set"},
{"address": "0xEB28", "comment": "output A on port A"},
{"address": "0xEB2B", "comment": "Y=0"},
{"address": "0xEB2C", "comment": "enable sound chip"},
{"address": "0xEB2F", "comment": "set and"},
{"address": "0xEB31", "comment": "execute short delay"},
{"address": "0xEB34", "comment": "then disable sound chip again"},
{"address": "0xEB39", "comment": "set delay"},
{"address": "0xEB3B", "comment": "and loop delay"},
{"address": "0xEB3E", "comment": "get back flags"},
{"address": "0xEB3F", "comment": "and exit"},
{"address": "0xEB44", "comment": "just to allow relative branches in early part"},
{"address": "0xEB49", "comment": "zero number of channels on hold for sync"},
{"address": "0xEB4C", "comment": "get number of channels required for sync"},
{"address": "0xEB4F", "comment": "if this <>0 then EB57"},
{"address": "0xEB51", "comment": "else number of chanels on hold for sync =1"},
{"address": "0xEB54", "comment": "number of channels required for sync =255"},
{"address": "0xEB57", "comment": "set loop counter"},
{"address": "0xEB59", "comment": "loop"},
{"address": "0xEB5A", "comment": "get value of &800 +offset (sound queue occupancy)"},
{"address": "0xEB5D", "comment": "if 0 goto EC59 no sound this channel"},
{"address": "0xEB5F", "comment": "else get buffer busy flag"},
{"address": "0xEB62", "comment": "if negative (buffer empty) goto EB69"},
{"address": "0xEB64", "comment": "else if duration count not zer0"},
{"address": "0xEB67", "comment": "goto EB6C"},
{"address": "0xEB69", "comment": "check and pick up new sound if required"},
{"address": "0xEB6C", "comment": "if duration count 0"},
{"address": "0xEB6F", "comment": "goto EB84"},
{"address": "0xEB71", "comment": "else if it is &FF (infinite duration)"},
{"address": "0xEB73", "comment": "go onto EB87"},
{"address": "0xEB75", "comment": "decrement 10 mS count"},
{"address": "0xEB78", "comment": "and if 0"},
{"address": "0xEB7A", "comment": "reset to 5"},
{"address": "0xEB7C", "comment": "to give 50 mSec delay"},
{"address": "0xEB7F", "comment": "and decrement main counter"},
{"address": "0xEB82", "comment": "if not zero then EB87"},
{"address": "0xEB84", "comment": "else check and get nw sound"},
{"address": "0xEB87", "comment": "if step progress counter is 0 no envelope involved"},
{"address": "0xEB8A", "comment": "so jump to EB91"},
{"address": "0xEB8C", "comment": "else decrement it"},
{"address": "0xEB8F", "comment": "and if not zero go on to EC59"},
{"address": "0xEB91", "comment": "get  envelope data offset from (8C0)"},
{"address": "0xEB94", "comment": "if 255 no envelope set so"},
{"address": "0xEB96", "comment": "goto EC59"},
{"address": "0xEB98", "comment": "else get get step length"},
{"address": "0xEB9B", "comment": "zero repeat bit"},
{"address": "0xEB9D", "comment": "and store it"},
{"address": "0xEBA0", "comment": "get phase counter"},
{"address": "0xEBA3", "comment": "if release phase completed"},
{"address": "0xEBA5", "comment": "goto EC07"},
{"address": "0xEBA7", "comment": "else start new step by getting phase"},
{"address": "0xEBAB", "comment": "add it to interval multiplier"},
{"address": "0xEBAE", "comment": "transfer to Y"},
{"address": "0xEBAF", "comment": "and get target value base for envelope"},
{"address": "0xEBB5", "comment": "store modified number as current target amplitude"},
{"address": "0xEBB8", "comment": "get byte from envelope store"},
{"address": "0xEBBB", "comment": "store as current amplitude step"},
{"address": "0xEBBE", "comment": "get base volumelevel"},
{"address": "0xEBC1", "comment": "save it"},
{"address": "0xEBC2", "comment": "clear carry"},
{"address": "0xEBC3", "comment": "add to current amplitude step"},
{"address": "0xEBC6", "comment": "if no overflow"},
{"address": "0xEBC8", "comment": "double it Carry = bit 7"},
{"address": "0xEBC9", "comment": "if bit =1 A=&3F"},
{"address": "0xEBCB", "comment": "into &EBCF"},
{"address": "0xEBCD", "comment": "else toggle bits (A=&C0)"},
{"address": "0xEBCF", "comment": "store in current volume"},
{"address": "0xEBD2", "comment": "multiply by 2"},
{"address": "0xEBD3", "comment": "if bits 6 and 7 are equal"},
{"address": "0xEBD6", "comment": "goto &EBE1"},
{"address": "0xEBD8", "comment": "if carry clear A=&3F (maximum)"},
{"address": "0xEBDA", "comment": "or"},
{"address": "0xEBDC", "comment": "&C0 minimum"},
{"address": "0xEBDE", "comment": "and this is stored in current volume"},
{"address": "0xEBE1", "comment": "decrement amplitude change per step"},
{"address": "0xEBE4", "comment": "get volume again"},
{"address": "0xEBE7", "comment": "set carry"},
{"address": "0xEBE8", "comment": "subtract target value"},
{"address": "0xEBEB", "comment": "negative value undicates correct trend"},
{"address": "0xEBEE", "comment": "so jump to next part"},
{"address": "0xEBF0", "comment": "else enter new phase"},
{"address": "0xEBF9", "comment": "get the old volume level"},
{"address": "0xEBFA", "comment": "and compare with the old"},
{"address": "0xEBFF", "comment": "if they are the same goto EC07"},
{"address": "0xEC01", "comment": "else set new level"},
{"address": "0xEC04", "comment": "via EB0A"},
{"address": "0xEC07", "comment": "get absolute pitch value"},
{"address": "0xEC0A", "comment": "if it =3"},
{"address": "0xEC0C", "comment": "skip rest of loop as all sections are finished"},
{"address": "0xEC0E", "comment": "else if 814,X is not 0 current section is not"},
{"address": "0xEC11", "comment": "so EC3D"},
{"address": "0xEC13", "comment": "else implement a section change"},
{"address": "0xEC16", "comment": "check if its complete"},
{"address": "0xEC19", "comment": "if not"},
{"address": "0xEC1B", "comment": "goto EC2D"},
{"address": "0xEC1D", "comment": "else set A from"},
{"address": "0xEC20", "comment": "&820 and &8C0 (first envelope byte)"},
{"address": "0xEC23", "comment": "if negative there is no repeat"},
{"address": "0xEC25", "comment": "else restart section sequence"},
{"address": "0xEC2D", "comment": "get number of steps in new section"},
{"address": "0xEC38", "comment": "set in 814+X"},
{"address": "0xEC3B", "comment": "and if 0 then EC59"},
{"address": "0xEC3D", "comment": "decrement"},
{"address": "0xEC40", "comment": "and pick up rate of pitch change"},
{"address": "0xEC4C", "comment": "add to rate of differential pitch change"},
{"address": "0xEC4F", "comment": "and save it"},
{"address": "0xEC53", "comment": "ad to base pitch"},
{"address": "0xEC56", "comment": "and set new pitch"},
{"address": "0xEC59", "comment": "if X=4 (last channel)"},
{"address": "0xEC5B", "comment": "goto EC6A (RTS)"},
{"address": "0xEC5D", "comment": "else do loop again"},
{"address": "0xEC60", "comment": "X=7 again"},
{"address": "0xEC62", "comment": "loop"},
{"address": "0xEC63", "comment": "clear channel"},
{"address": "0xEC66", "comment": "if not 4"},
{"address": "0xEC68", "comment": "do it again"},
{"address": "0xEC6A", "comment": "and return"},
{"address": "0xEC6B", "comment": "check for last channel"},
{"address": "0xEC6E", "comment": "is it 4 (release complete)"},
{"address": "0xEC70", "comment": "if so EC77"},
{"address": "0xEC72", "comment": "else mark release in progress"},
{"address": "0xEC74", "comment": "and store it"},
{"address": "0xEC77", "comment": "is buffer not empty"},
{"address": "0xEC7A", "comment": "if so EC90"},
{"address": "0xEC7C", "comment": "else mark buffer not empty"},
{"address": "0xEC7E", "comment": "an store it"},
{"address": "0xEC81", "comment": "loop counter"},
{"address": "0xEC83", "comment": "zero sync bytes"},
{"address": "0xEC87", "comment": "until Y=0"},
{"address": "0xEC89", "comment": "zero duration count"},
{"address": "0xEC8C", "comment": "and set sync count to"},
{"address": "0xEC8D", "comment": "&FF"},
{"address": "0xEC90", "comment": "get synchronising flag"},
{"address": "0xEC93", "comment": "if its 0 then ECDB"},
{"address": "0xEC95", "comment": "else get number of channels on hold"},
{"address": "0xEC98", "comment": "if 0 then ECD0"},
{"address": "0xEC9A", "comment": "else"},
{"address": "0xEC9C", "comment": "zero note length interval"},
{"address": "0xEC9F", "comment": "and goto ED98"},
{"address": "0xECA2", "comment": "silence the channel"},
{"address": "0xECA5", "comment": "Y=0 A=Y"},
{"address": "0xECA6", "comment": "zero main count"},
{"address": "0xECA9", "comment": "mark buffer not empty"},
{"address": "0xECAC", "comment": "mark channel dormant"},
{"address": "0xECAF", "comment": "loop counter"},
{"address": "0xECB1", "comment": "zero sync flags"},
{"address": "0xECB7", "comment": "number of channels to &FF"},
{"address": "0xECBA", "comment": "jump to ED06 ALWAYS"},
{"address": "0xECBC", "comment": "save flags"},
{"address": "0xECBD", "comment": "and disable interrupts"},
{"address": "0xECBE", "comment": "check for end of release"},
{"address": "0xECC3", "comment": "and if not found ECCF"},
{"address": "0xECC5", "comment": "elseexamine buffer"},
{"address": "0xECC8", "comment": "if not empty ECCF"},
{"address": "0xECCA", "comment": "else mark channel dormant"},
{"address": "0xECCF", "comment": "get back flags"},
{"address": "0xECD0", "comment": "if no envelope 820=&FF"},
{"address": "0xECD5", "comment": "then terminate sound"},
{"address": "0xECD7", "comment": "via EB03"},
{"address": "0xECDA", "comment": "else return"},
{"address": "0xECDB", "comment": "examine buffer if empty carry set"},
{"address": "0xECE0", "comment": "else examine next word if>3 or 0"},
{"address": "0xECE2", "comment": "goto ED98 (via EC9F)"},
{"address": "0xECE4", "comment": "else get synchronising count"},
{"address": "0xECE7", "comment": "in 0 (complete) goto ECFE"},
{"address": "0xECE9", "comment": "else set sync flag"},
{"address": "0xECEC", "comment": "if 0838 is +ve S has already been set so"},
{"address": "0xECEF", "comment": "jump to ECFB"},
{"address": "0xECF1", "comment": "else get first byte"},
{"address": "0xECF4", "comment": "mask bits 0,1"},
{"address": "0xECF6", "comment": "and store result"},
{"address": "0xECF9", "comment": "Jump to ECFE (ALWAYS!!)"},
{"address": "0xECFB", "comment": "decrement 0838"},
{"address": "0xECFE", "comment": "and silence the channel if envelope not in use"},
{"address": "0xED01", "comment": "If A=&82C,X then pitch is unchanged"},
{"address": "0xED04", "comment": "then exit via ECDA"},
{"address": "0xED06", "comment": "store new pitch"},
{"address": "0xED09", "comment": "if X<>4 then not noise so"},
{"address": "0xED0B", "comment": "jump to ED16"},
{"address": "0xED0D", "comment": "convert to chip format"},
{"address": "0xED12", "comment": "save flags"},
{"address": "0xED13", "comment": "and pass to chip control routine at EB22 via ED95"},
{"address": "0xED19", "comment": "lose eigth tone surplus"},
{"address": "0xED21", "comment": "get back A"},
{"address": "0xED22", "comment": "divide by 12"},
{"address": "0xED28", "comment": "store result"},
{"address": "0xED2B", "comment": "with remainder in A"},
{"address": "0xED2F", "comment": "Y=A"},
{"address": "0xED30", "comment": "get octave number into A"},
{"address": "0xED33", "comment": "push it"},
{"address": "0xED34", "comment": "get byte from look up table"},
{"address": "0xED37", "comment": "store it"},
{"address": "0xED3A", "comment": "get byte from second table"},
{"address": "0xED3D", "comment": "push it"},
{"address": "0xED3E", "comment": "keep two LS bits only"},
{"address": "0xED40", "comment": "save them"},
{"address": "0xED43", "comment": "pull second table byte"},
{"address": "0xED44", "comment": "push hi nybble into lo nybble"},
{"address": "0xED48", "comment": "store it"},
{"address": "0xED4B", "comment": "get back octave number"},
{"address": "0xED4E", "comment": "adjust for surplus eighth tones"},
{"address": "0xED83", "comment": "push P"},
{"address": "0xED84", "comment": "bar interrupts"},
{"address": "0xED85", "comment": "set up chip access 1"},
{"address": "0xED95", "comment": "set up chip access 2 and return"},
{"address": "0xED98", "comment": "push flags"},
{"address": "0xED99", "comment": "disable interrupts"},
{"address": "0xED9A", "comment": "read a byte from buffer"},
{"address": "0xED9D", "comment": "push A"},
{"address": "0xED9E", "comment": "isolate H bit"},
{"address": "0xEDA0", "comment": "if 0 then EDB7"},
{"address": "0xEDA2", "comment": "get back A"},
{"address": "0xEDA3", "comment": "get envelope setting for this channel"},
{"address": "0xEDA6", "comment": "check for &FF=no envelope"},
{"address": "0xEDA8", "comment": "envelope is in use, keep playing it"},
{"address": "0xEDAA", "comment": "no envelope, so call EB03 to silence channel"},
{"address": "0xEDAD", "comment": "clear buffer of redundant data, get ignored pitch"},
{"address": "0xEDB0", "comment": "get ignored duration"},
{"address": "0xEDB3", "comment": "get flags back"},
{"address": "0xEDB4", "comment": "set main duration count using last byte from buffer"},
{"address": "0xEDB7", "comment": "get back A"},
{"address": "0xEDB8", "comment": "zero bits 0-2, Hold and Sync bits"},
{"address": "0xEDBA", "comment": "put bit 7 volume/envelope flag into carry"},
{"address": "0xEDBB", "comment": "if zero (envelope) jump to EDC8"},
{"address": "0xEDBD", "comment": "invert A"},
{"address": "0xEDBF", "comment": "shift right"},
{"address": "0xEDC1", "comment": "subtract &40"},
{"address": "0xEDC3", "comment": "and set volume"},
{"address": "0xEDC6", "comment": "A=&FF"},
{"address": "0xEDC8", "comment": "get envelope no.-1 *16 into A"},
{"address": "0xEDCB", "comment": "set duration sub-counter"},
{"address": "0xEDD0", "comment": "set phase counter"},
{"address": "0xEDD5", "comment": "set step counter"},
{"address": "0xEDDA", "comment": "and envelope phase"},
{"address": "0xEDDD", "comment": "and pitch differential"},
{"address": "0xEDE2", "comment": "set step count"},
{"address": "0xEDE5", "comment": "get pitch from buffer"},
{"address": "0xEDE8", "comment": "set it"},
{"address": "0xEDEB", "comment": "get duration from buffer"},
{"address": "0xEDEF", "comment": "save duration"},
{"address": "0xEDF0", "comment": "get back pitch value"},
{"address": "0xEDF3", "comment": "and set it"},
{"address": "0xEDF6", "comment": "get back duration"},
{"address": "0xEDF7", "comment": "set it"},
{"address": "0xEDFA", "comment": "and return"},
{"address": "0xEE13", "comment": "start with ROM &F0-1"},
{"address": "0xEE15", "comment": "store it"},
{"address": "0xEE17", "comment": "return"},
{"address": "0xEE18", "comment": "X=13"},
{"address": "0xEE1A", "comment": "increment current ROM number"},
{"address": "0xEE1C", "comment": "get ROM"},
{"address": "0xEE1E", "comment": "if +ve its a sideways ROM else its a PHROM"},
{"address": "0xEE20", "comment": "PHROM"},
{"address": "0xEE22", "comment": "set address pointer in PHROM"},
{"address": "0xEE25", "comment": "to 0001"},
{"address": "0xEE27", "comment": "pass info to speech processor"},
{"address": "0xEE2A", "comment": "X=3"},
{"address": "0xEE2C", "comment": "check for speech processor and output until"},
{"address": "0xEE2F", "comment": "if A <> DF0C+X then EE18 (DF0C = (C))"},
{"address": "0xEE34", "comment": "else decrement X"},
{"address": "0xEE35", "comment": "and do it again"},
{"address": "0xEE39", "comment": "set lo byte address"},
{"address": "0xEE3B", "comment": "select address and PROM from &F5/6/7"},
{"address": "0xEE3E", "comment": "read to bytes, to &F6 and &F7"},
{"address": "0xEE40", "comment": "read byte from this address from PHROM"},
{"address": "0xEE43", "comment": "8 bits to rotate"},
{"address": "0xEE45", "comment": "reverse the byte into &F6 on first pass"},
{"address": "0xEE46", "comment": "and then into &F7 on the second pass"},
{"address": "0xEE49", "comment": "loop for 8 bits"},
{"address": "0xEE4C", "comment": "loop for two bytes"},
{"address": "0xEE4F", "comment": "jump to set PHROM address to this address weve just read"},
{"address": "0xEE53", "comment": "if Y is negative (PHROM)"},
{"address": "0xEE55", "comment": "GOTO EE62"},
{"address": "0xEE57", "comment": "else Y=255"},
{"address": "0xEE59", "comment": "push flags"},
{"address": "0xEE5A", "comment": "offer paged rom service"},
{"address": "0xEE5D", "comment": "pull processor flags"},
{"address": "0xEE60", "comment": "A=Y"},
{"address": "0xEE61", "comment": "return"},
{"address": "0xEE62", "comment": "push processor flags"},
{"address": "0xEE63", "comment": "disable interrupts"},
{"address": "0xEE64", "comment": "Y=&10 - Read Byte"},
{"address": "0xEE66", "comment": "Send command to Speech Processor"},
{"address": "0xEE69", "comment": "Y=0"},
{"address": "0xEE6B", "comment": "Jump to EE84 to read resultant byte from Speech"},
{"address": "0xEE6D", "comment": "Y=0 to set speech proc to read"},
{"address": "0xEE6F", "comment": "jump to EE82 always"},
{"address": "0xEE71", "comment": "push A"},
{"address": "0xEE72", "comment": "to write to speech processor"},
{"address": "0xEE75", "comment": "get back A"},
{"address": "0xEE76", "comment": "bring upper nybble to lower nybble"},
{"address": "0xEE77", "comment": "by rotate right"},
{"address": "0xEE78", "comment": "4 times"},
{"address": "0xEE7A", "comment": "Y=lo nybble A +&40"},
{"address": "0xEE7E", "comment": "forming command for speech processor"},
{"address": "0xEE7F", "comment": "transfer command to A"},
{"address": "0xEE80", "comment": "to set speech proc to write"},
{"address": "0xEE82", "comment": "push flags"},
{"address": "0xEE83", "comment": "disable interrupts"},
{"address": "0xEE84", "comment": "test for presence of speech processor"},
{"address": "0xEE87", "comment": "if not there goto EEAA"},
{"address": "0xEE89", "comment": "else push A"},
{"address": "0xEE8D", "comment": "set DDRA of system VIA to give input (Y=0) or output (Y=1)"},
{"address": "0xEE90", "comment": "get command back in A"},
{"address": "0xEE91", "comment": "and send to speech chip, write to PortA"},
{"address": "0xEE94", "comment": "Get A=&01 for read, A=&02 for write"},
{"address": "0xEE97", "comment": "Write to PortB, A=&01 set VP_READ, A=&02 set VP_WRITE"},
{"address": "0xEE9A", "comment": "Test System VIA PortA, bit 7 is VP_RDY"},
{"address": "0xEE9D", "comment": "Loop until Speech Processor reports ready"},
{"address": "0xEE9F", "comment": "Read Speech Processor data from Port A"},
{"address": "0xEEA2", "comment": "Save it - will be returned data for read, data written for write"},
{"address": "0xEEA3", "comment": "Get A=&09 for read, A=&0A for write"},
{"address": "0xEEA6", "comment": "Write to PortB, A=&09 clear VP_READ, A=&0A clear VP_WRITE"},
{"address": "0xEEA9", "comment": "Get data byte back"},
{"address": "0xEEAA", "comment": "Restore IRQs"},
{"address": "0xEEAB", "comment": "Transfer A to Y to set flags"},
{"address": "0xEEAC", "comment": "And return"},
{"address": "0xEEAD", "comment": "set rom displacement pointer"},
{"address": "0xEEB0", "comment": "in &F6"},
{"address": "0xEEB5", "comment": "And &F7"},
{"address": "0xEEB7", "comment": "if F5 is +ve ROM is selected so"},
{"address": "0xEEB9", "comment": "goto EED9"},
{"address": "0xEEBB", "comment": "else push processor"},
{"address": "0xEEBC", "comment": "disable interrupts"},
{"address": "0xEEBD", "comment": "get lo displacement"},
{"address": "0xEEBF", "comment": "pass two nybbles to speech proc."},
{"address": "0xEEC2", "comment": "&FA=&F5 = ROM number or SOUND command &80-&FF"},
{"address": "0xEEC6", "comment": "get hi displacement value"},
{"address": "0xEEC8", "comment": "replace two most significant bits of A"},
{"address": "0xEEC9", "comment": "by 2 LSBs of &FA"},
{"address": "0xEECF", "comment": "A= now %rraaaaaa"},
{"address": "0xEED0", "comment": "pass two nybbles to speech processor"},
{"address": "0xEED3", "comment": "FA has now been divided by 4 so pass"},
{"address": "0xEED5", "comment": "lower nybble to speech proc., passing %xxrr"},
{"address": "0xEED8", "comment": "get back flags"},
{"address": "0xEED9", "comment": "and Return"},
{"address": "0xEEDC", "comment": "get value of most recently pressed key"},
{"address": "0xEEDE", "comment": "OR it with previous key to check for presses"},
{"address": "0xEEE0", "comment": "if A=0 no keys pressed so off you go"},
{"address": "0xEEE2", "comment": "else enable keybd interupt only by writing bit 7"},
{"address": "0xEEE4", "comment": "and bit 0 of system VIA interupt register"},
{"address": "0xEEE7", "comment": "set X=0"},
{"address": "0xEEE8", "comment": "reset keyboard semaphore"},
{"address": "0xEEEB", "comment": "save flags"},
{"address": "0xEEEC", "comment": "read keyboard status"},
{"address": "0xEEEF", "comment": "shift Caps bit into bit 3"},
{"address": "0xEEF0", "comment": "mask out all but 4 and 3"},
{"address": "0xEEF2", "comment": "returns &06 if caps lock OFF, &0E if ON"},
{"address": "0xEEF4", "comment": "turn on or off caps light if required"},
{"address": "0xEEF7", "comment": "bring shift bit into bit 3"},
{"address": "0xEEFA", "comment": "turn on or off shift  lock light"},
{"address": "0xEEFD", "comment": "set keyboard counter"},
{"address": "0xEF00", "comment": "pop flags into A register, setting M from saved M"},
{"address": "0xEF01", "comment": "return, A.b7=Control, A.b6=Shift, MI=Control, VS=Shift"},
{"address": "0xEF02", "comment": "If V is clear jump to keyscan routines"},
{"address": "0xEF04", "comment": "Disable keyboard interrupts"},
{"address": "0xEF06", "comment": "by writing to VIA interrupt settings"},
{"address": "0xEF09", "comment": "Jump with timer interupt"},
{"address": "0xEF0B", "comment": "Otherwise, jump with keypress interupt"},
{"address": "0xEF0E", "comment": "Jump to test SHIFT and CTRL"},
{"address": "0xEF10", "comment": "Otherwise, jump to scan whole keyboard"},
{"address": "0xEF13", "comment": "Increment keyboard semaphore (to 0)"},
{"address": "0xEF16", "comment": "Get current keyboard status"},
{"address": "0xEF19", "comment": "Clear bits 3 and 6, Shift & Ctrl off"},
{"address": "0xEF1B", "comment": "X=&00 to test for Shift key"},
{"address": "0xEF1D", "comment": "Interrogate keyboard, does INKEY-(0+1), ie INKEY-1"},
{"address": "0xEF20", "comment": "Save SHIFT keypress state"},
{"address": "0xEF22", "comment": "Clear V = SHIFT not pressed"},
{"address": "0xEF23", "comment": "If SHIFT not pressed, if no key press (X=0) then EF2A else"},
{"address": "0xEF25", "comment": "Set V = SHIFT is pressed"},
{"address": "0xEF28", "comment": "Set bit 3 to indicate Shift was pressed"},
{"address": "0xEF2A", "comment": "X=&01 or &81 to test for Control key"},
{"address": "0xEF2B", "comment": "Interrogate keyboard, does INKEY-(1+1), ie INKEY-2"},
{"address": "0xEF2E", "comment": "If Carry Clear, was entered to test Shift & Control,"},
{"address": "0xEF30", "comment": "If CTRL not pressed, skip past"},
{"address": "0xEF32", "comment": "Set bit 6 to indicate Control pressed"},
{"address": "0xEF34", "comment": "Update keyboard status byte"},
{"address": "0xEF37", "comment": "Get previous keypress"},
{"address": "0xEF39", "comment": "if no key previously pressed then EF4D"},
{"address": "0xEF3B", "comment": "else check to see if key still pressed"},
{"address": "0xEF3E", "comment": "if so enter repeat routine at EF50"},
{"address": "0xEF40", "comment": "else compare X with last key pressed (set flags)"},
{"address": "0xEF42", "comment": "store X in last key pressed"},
{"address": "0xEF44", "comment": "if different from previous (Z clear) then EF4D"},
{"address": "0xEF46", "comment": "else zero"},
{"address": "0xEF48", "comment": "last key pressed"},
{"address": "0xEF4A", "comment": "and reset repeat system"},
{"address": "0xEF50", "comment": "if X<>than last key pressed"},
{"address": "0xEF52", "comment": "then back to EF42"},
{"address": "0xEF54", "comment": "else get value of AUTO REPEAT COUNTDOWN TIMER"},
{"address": "0xEF56", "comment": "if 0 goto EF7B"},
{"address": "0xEF58", "comment": "else decrement"},
{"address": "0xEF5A", "comment": "and if not 0 goto EF7B"},
{"address": "0xEF5C", "comment": "next value for countdown timer"},
{"address": "0xEF5F", "comment": "store it"},
{"address": "0xEF61", "comment": "get auto repeat rate from 0255"},
{"address": "0xEF64", "comment": "store it as next value for Countdown timer"},
{"address": "0xEF67", "comment": "get keyboard status"},
{"address": "0xEF6A", "comment": "get last key pressed"},
{"address": "0xEF6C", "comment": "if not SHIFT LOCK key (&D0) goto"},
{"address": "0xEF6E", "comment": "EF7E"},
{"address": "0xEF70", "comment": "sets shift enabled, & no caps lock all else preserved"},
{"address": "0xEF72", "comment": "reverses shift lock disables Caps lock and Shift enab"},
{"address": "0xEF74", "comment": "reset keyboard status"},
{"address": "0xEF77", "comment": "and set timer"},
{"address": "0xEF79", "comment": "to 0"},
{"address": "0xEF7E", "comment": "if not CAPS LOCK"},
{"address": "0xEF80", "comment": "goto EF91"},
{"address": "0xEF82", "comment": "sets shift enabled and disables SHIFT LOCK"},
{"address": "0xEF84", "comment": "if bit 7 not set by (EF20) shift NOT pressed"},
{"address": "0xEF86", "comment": "goto EF8C"},
{"address": "0xEF88", "comment": "else set CAPS LOCK not enabled"},
{"address": "0xEF8A", "comment": "reverse SHIFT enabled"},
{"address": "0xEF8C", "comment": "reverse both SHIFT enabled and CAPs Lock"},
{"address": "0xEF8E", "comment": "reset keyboard status and set timer"},
{"address": "0xEF91", "comment": "get code from lookup table"},
{"address": "0xEF94", "comment": "if not zero goto EF99 else TAB pressed"},
{"address": "0xEF96", "comment": "get TAB character"},
{"address": "0xEF99", "comment": "get keyboard status"},
{"address": "0xEF9C", "comment": "store it in &FA"},
{"address": "0xEF9E", "comment": "rotate to get CTRL pressed into bit 7"},
{"address": "0xEFA0", "comment": "if CTRL NOT pressed EFA9"},
{"address": "0xEFA2", "comment": "get no. of previously pressed key"},
{"address": "0xEFA4", "comment": "if not 0 goto EF4A to reset repeat system etc."},
{"address": "0xEFA6", "comment": "else perform code changes for CTRL"},
{"address": "0xEFA9", "comment": "move shift lock into bit 7"},
{"address": "0xEFAB", "comment": "if not effective goto EFB5 else"},
{"address": "0xEFAD", "comment": "make code changes for SHIFT"},
{"address": "0xEFB0", "comment": "move CAPS LOCK into bit 7"},
{"address": "0xEFB2", "comment": "and Jump to EFC1"},
{"address": "0xEFB5", "comment": "move CAPS LOCK into bit 7"},
{"address": "0xEFB7", "comment": "if not effective goto EFC6"},
{"address": "0xEFB9", "comment": "else make changes for CAPS LOCK on, return with"},
{"address": "0xEFBC", "comment": "if carry set goto EFC6 else make changes for"},
{"address": "0xEFBE", "comment": "SHIFT as above"},
{"address": "0xEFC1", "comment": "if shift enabled bit is clear"},
{"address": "0xEFC4", "comment": "goto EFD1"},
{"address": "0xEFC6", "comment": "else get shift bit into 7"},
{"address": "0xEFC8", "comment": "if not set goto EFD1"},
{"address": "0xEFCA", "comment": "get previous key press"},
{"address": "0xEFCC", "comment": "if not 0 reset repeat system etc. via EFA4"},
{"address": "0xEFCE", "comment": "else make code changes for SHIFT"},
{"address": "0xEFD1", "comment": "if A<>ESCAPE code"},
{"address": "0xEFD4", "comment": "goto EFDD"},
{"address": "0xEFD6", "comment": "get Escape key status"},
{"address": "0xEFD9", "comment": "if ESCAPE returns ASCII code goto EFDD"},
{"address": "0xEFDB", "comment": "store in Auto repeat countdown timer"},
{"address": "0xEFDE", "comment": "disable keyboard"},
{"address": "0xEFE1", "comment": "read Keyboard disable flag used by Econet"},
{"address": "0xEFE4", "comment": "if keyboard locked goto EFE9"},
{"address": "0xEFE6", "comment": "put character in input buffer"},
{"address": "0xEFE9", "comment": "get previous keypress"},
{"address": "0xEFEB", "comment": "if none, go to EFF8"},
{"address": "0xEFED", "comment": "examine to see if key still pressed"},
{"address": "0xEFF0", "comment": "store result"},
{"address": "0xEFF2", "comment": "if pressed goto EFF8"},
{"address": "0xEFF4", "comment": "else zero X"},
{"address": "0xEFF6", "comment": "and &ED"},
{"address": "0xEFF8", "comment": "get &ED"},
{"address": "0xEFFA", "comment": "if not 0 goto F012"},
{"address": "0xEFFC", "comment": "get first keypress into Y"},
{"address": "0xEFFE", "comment": "scan keyboard from &10 (osbyte 122)"},
{"address": "0xF001", "comment": "if exit is negative goto F00C"},
{"address": "0xF003", "comment": "else make last key the"},
{"address": "0xF005", "comment": "first key pressed i.e. rollover"},
{"address": "0xF007", "comment": "save X into &EC"},
{"address": "0xF009", "comment": "set keyboard repeat delay"},
{"address": "0xF00C", "comment": "go back to EEDA"},
{"address": "0xF00F", "comment": "Stop autoscan by testing for a random keypress"},
{"address": "0xF012", "comment": "Get previous key press"},
{"address": "0xF014", "comment": "If key currently pressed, back to housekeeping routine"},
{"address": "0xF016", "comment": "Point Y to last keypress location"},
{"address": "0xF018", "comment": "Scan keyboard for a pressed key"},
{"address": "0xF01B", "comment": "If negative, no key found, exit"},
{"address": "0xF01D", "comment": "Positive, key press found, store it and prepare autorepeat"},
{"address": "0xF01F", "comment": "set timer to 1"},
{"address": "0xF023", "comment": "get next timer value"},
{"address": "0xF026", "comment": "and store it"},
{"address": "0xF02A", "comment": "stop Auto scan"},
{"address": "0xF02C", "comment": "by writing to system VIA"},
{"address": "0xF02F", "comment": "set bits 0 to 6 of port A to input on bit 7"},
{"address": "0xF034", "comment": "write X to Port A system VIA"},
{"address": "0xF037", "comment": "read back &80 if key pressed (M set)"},
{"address": "0xF03A", "comment": "and return"},
{"address": "0xF045", "comment": "store Y as latest key pressed"},
{"address": "0xF047", "comment": "store X as previous key pressed"},
{"address": "0xF049", "comment": "and exit"},
{"address": "0xF055", "comment": "Jim paged entry vector"},
{"address": "0xF065", "comment": "Set V to signal interupt call"},
{"address": "0xF068", "comment": "Jump via KEYV to keyboard handler"},
{"address": "0xF085", "comment": "read current OSHWM"},
{"address": "0xF088", "comment": "address is &xx00"},
{"address": "0xF095", "comment": "get current input buffer"},
{"address": "0xF098", "comment": "flush it"},
{"address": "0xF0A5", "comment": "go to eventV handling routine"},
{"address": "0xF0A8", "comment": "if X<>1 flush input buffer only"},
{"address": "0xF0AA", "comment": "else load highest buffer number (8)"},
{"address": "0xF0AC", "comment": "allow interrupts"},
{"address": "0xF0AD", "comment": "briefly!"},
{"address": "0xF0AE", "comment": "flush buffer"},
{"address": "0xF0B1", "comment": "decrement X to point at next buffer"},
{"address": "0xF0B2", "comment": "if X>=0 flush next buffer"},
{"address": "0xF0B4", "comment": "is X<9?"},
{"address": "0xF0B6", "comment": "if so flush buffer or else"},
{"address": "0xF0B8", "comment": "exit"},
{"address": "0xF0BB", "comment": "send service call 9 to ROMs"},
{"address": "0xF0BE", "comment": "print inline message, corrupting &B8/9, assumes Y<>0"},
{"address": "0xF0C2", "comment": "help message"},
{"address": "0xF0CC", "comment": "Clear carry to bypass KEYV and use supplied Y as we"},
{"address": "0xF0CD", "comment": "Set X to scan from &10, skipping modifier keys"},
{"address": "0xF0CF", "comment": "If carry set from OSBYTE entry, vector via KEYV"},
{"address": "0xF0D1", "comment": "if X is +ve goto F0D9"},
{"address": "0xF0D2", "comment": "&00-&7F, scan for single keypress (INKEY-129 to -256)"},
{"address": "0xF0D4", "comment": "else interrogate keyboard, scan for single keypress"},
{"address": "0xF0D7", "comment": "if carry set from entry, jump to F12E to exit"},
{"address": "0xF0D9", "comment": "push flags"},
{"address": "0xF0DA", "comment": "if carry clear, Y already set, skip to LF0DE"},
{"address": "0xF0DC", "comment": "set Y so next operation saves to &02CD"},
{"address": "0xF0DE", "comment": "Store keypress number in &02CB, &02CC or &02CD"},
{"address": "0xF0E1", "comment": "Start with column 9 in X"},
{"address": "0xF0E3", "comment": "select auto scan"},
{"address": "0xF0E6", "comment": "set port A for input on bit 7 others outputs"},
{"address": "0xF0EB", "comment": "stop auto scan"},
{"address": "0xF0F0", "comment": "select non-existent keyboard column F (only 0-9 have keys)"},
{"address": "0xF0F5", "comment": "cancel keyboard interrupt"},
{"address": "0xF0FA", "comment": "select column X (9 max)"},
{"address": "0xF0FD", "comment": "if bit 1 =0 there is no keyboard interrupt so"},
{"address": "0xF100", "comment": "goto F123"},
{"address": "0xF102", "comment": "else put column address in A"},
{"address": "0xF103", "comment": "compare with 1DF+Y"},
{"address": "0xF106", "comment": "if less then F11E"},
{"address": "0xF108", "comment": "else select column again"},
{"address": "0xF10B", "comment": "and if bit 7 is 0"},
{"address": "0xF10E", "comment": "then F11E"},
{"address": "0xF110", "comment": "else push and pull flags"},
{"address": "0xF112", "comment": "and if carry set goto F127"},
{"address": "0xF114", "comment": "else Push A"},
{"address": "0xF115", "comment": "EOR with EC,ED, or EE depending on Y value"},
{"address": "0xF118", "comment": "shift left"},
{"address": "0xF119", "comment": "set carry if = or greater than number holds EC,ED,EE"},
{"address": "0xF11B", "comment": "get back A"},
{"address": "0xF11C", "comment": "if carry set F127"},
{"address": "0xF11E", "comment": "else clear carry"},
{"address": "0xF11F", "comment": "add 16"},
{"address": "0xF121", "comment": "and do it again if 0=<result<128"},
{"address": "0xF123", "comment": "decrement X"},
{"address": "0xF124", "comment": "scan again if greater than 0"},
{"address": "0xF128", "comment": "pull flags"},
{"address": "0xF129", "comment": "call autoscan"},
{"address": "0xF12C", "comment": "allow interrupts"},
{"address": "0xF12D", "comment": "disable interrupts"},
{"address": "0xF12E", "comment": "select auto scan of keyboard"},
{"address": "0xF130", "comment": "tell VIA"},
{"address": "0xF133", "comment": "Get A into X"},
{"address": "0xF134", "comment": "and return"},
{"address": "0xF135", "comment": "if its *TAPE A=0 *ROM A=1"},
{"address": "0xF137", "comment": "double it"},
{"address": "0xF138", "comment": "store it in filing system flag store"},
{"address": "0xF13B", "comment": "if X>=3 C set X=3 Z set"},
{"address": "0xF140", "comment": "save flags"},
{"address": "0xF141", "comment": "set sequential access abort if error, no messages"},
{"address": "0xF143", "comment": "set load/save retry if error, short messages"},
{"address": "0xF145", "comment": "set interblock gap"},
{"address": "0xF147", "comment": "and store it"},
{"address": "0xF14A", "comment": "get back flags"},
{"address": "0xF14B", "comment": "push flags"},
{"address": "0xF14C", "comment": "filing system taking over call to FSCV"},
{"address": "0xF14E", "comment": "call OSFSC"},
{"address": "0xF153", "comment": "get back flags"},
{"address": "0xF154", "comment": "if Z set earlier"},
{"address": "0xF156", "comment": "do not decrement X"},
{"address": "0xF157", "comment": "set current baud rate X=5 300 baud X=6 1200 baud"},
{"address": "0xF159", "comment": "CLAIM FILING SYSTEM VECTORS"},
{"address": "0xF164", "comment": "&C2=&00 set progress flag = idle"},
{"address": "0xF166", "comment": "set X to make ROM service call &0F, vectors changed"},
{"address": "0xF168", "comment": "Get current ROM number"},
{"address": "0xF16A", "comment": "Save it"},
{"address": "0xF16B", "comment": "Pass service call number to A"},
{"address": "0xF16C", "comment": "Start at ROM 15"},
{"address": "0xF16E", "comment": "Read bit 7 on ROM type table"},
{"address": "0xF174", "comment": "If not set (+ve result), step to next ROM down"},
{"address": "0xF176", "comment": "Otherwise, select this ROM, &F4 RAM copy"},
{"address": "0xF178", "comment": "Page in selected ROM"},
{"address": "0xF17B", "comment": "Call the ROMs service entry"},
{"address": "0xF17E", "comment": "On exit pass A to X to chech if claimed"},
{"address": "0xF17F", "comment": "If 0, service call claimed, reselect ROM and exit"},
{"address": "0xF181", "comment": "Otherwise, get current ROM back"},
{"address": "0xF183", "comment": "Step to next ROM down"},
{"address": "0xF184", "comment": "Loop until done ROM 0"},
{"address": "0xF186", "comment": "Get back original ROM number"},
{"address": "0xF187", "comment": "Set ROM number RAM copy"},
{"address": "0xF189", "comment": "Page in the original ROM"},
{"address": "0xF18C", "comment": "Pass X back to A to set zero flag"},
{"address": "0xF18D", "comment": "And return"},
{"address": "0xF18E", "comment": "is A=00"},
{"address": "0xF190", "comment": "if not return"},
{"address": "0xF192", "comment": "is Y=0"},
{"address": "0xF194", "comment": "if not return"},
{"address": "0xF196", "comment": "else get current baud rate and zero bit 2"},
{"address": "0xF198", "comment": "C6=5 becomes 1, 6 becomes 2"},
{"address": "0xF19A", "comment": "if cassette selected A=0 else A=2"},
{"address": "0xF19D", "comment": "multiply by 2"},
{"address": "0xF19E", "comment": "Or it again"},
{"address": "0xF1A1", "comment": "divide by 2"},
{"address": "0xF1A2", "comment": "return cassette =0"},
{"address": "0xF1B1", "comment": "if A>6"},
{"address": "0xF1B3", "comment": "goto F1A2 (RTS)"},
{"address": "0xF1B5", "comment": "else save X"},
{"address": "0xF1B7", "comment": "A=A*2"},
{"address": "0xF1B8", "comment": "X=A to get offset"},
{"address": "0xF1B9", "comment": "get hi byte of address-1"},
{"address": "0xF1BC", "comment": "push it"},
{"address": "0xF1BD", "comment": "get lo byte of address-1"},
{"address": "0xF1C0", "comment": "push it"},
{"address": "0xF1C1", "comment": "get back X"},
{"address": "0xF1C3", "comment": "this now jumps to the address got from the table +1"},
{"address": "0xF1C4", "comment": "save flags on stack, allows sibroutines to turn off IRQs"},
{"address": "0xF1C5", "comment": "save load/run action"},
{"address": "0xF1C6", "comment": "Set &BB to load/save options, set &C7=6 for load/save block gap"},
{"address": "0xF1C9", "comment": "execution address LO"},
{"address": "0xF1CC", "comment": "save A on stack"},
{"address": "0xF1CD", "comment": "search for file"},
{"address": "0xF1D0", "comment": "get back A"},
{"address": "0xF1D1", "comment": "if A=0, RUN, use files own load address, go to F1ED"},
{"address": "0xF1D3", "comment": "else X=3"},
{"address": "0xF1D5", "comment": "A=&FF"},
{"address": "0xF1D7", "comment": "save A on stack"},
{"address": "0xF1D8", "comment": "get load address"},
{"address": "0xF1DB", "comment": "store it as current load address"},
{"address": "0xF1DD", "comment": "get back A"},
{"address": "0xF1DE", "comment": "test for &FFFFFFFF load address"},
{"address": "0xF1E0", "comment": "X=X-1"},
{"address": "0xF1E1", "comment": "until all 4 bytes copied"},
{"address": "0xF1E3", "comment": "if all bytes contain dont contain &FF"},
{"address": "0xF1E5", "comment": "continue"},
{"address": "0xF1E7", "comment": "else sound bell, reset ACIA & motor off"},
{"address": "0xF1EA", "comment": "Bad Address error"},
{"address": "0xF1ED", "comment": "Get block flag"},
{"address": "0xF1F0", "comment": "Set carry from Locked flag in bit 0"},
{"address": "0xF1F1", "comment": "Get action back"},
{"address": "0xF1F2", "comment": "If A=0, *RUN, jump to F202 to test Locked flag"},
{"address": "0xF1F4", "comment": "A<>0, *LOAD, if unlocked, jump to load"},
{"address": "0xF1F6", "comment": "Release Tube and reset serial system"},
{"address": "0xF202", "comment": "Carry clear, unlocked, jump to F209 to load file"},
{"address": "0xF204", "comment": "else A=3"},
{"address": "0xF206", "comment": "store to cause ESCAPE disable and memory clear on break"},
{"address": "0xF20B", "comment": "Get current error OPTions"},
{"address": "0xF20D", "comment": "If all errors ignored, skip checking checksum"},
{"address": "0xF20F", "comment": "Else get checksum result"},
{"address": "0xF211", "comment": "If checksum not ok, jump to F21D to..."},
{"address": "0xF213", "comment": "A=Y"},
{"address": "0xF214", "comment": "Save Y on stack"},
{"address": "0xF215", "comment": "Claim Tube, start Host->Tube transfer"},
{"address": "0xF219", "comment": "Get Y back"},
{"address": "0xF21A", "comment": "Set block offset=0, status=load data block"},
{"address": "0xF21D", "comment": "Load data block"},
{"address": "0xF220", "comment": "If not found return to search"},
{"address": "0xF222", "comment": "Increment current block number"},
{"address": "0xF225", "comment": "Test block flag"},
{"address": "0xF228", "comment": "If bit 7=1 then this is last block so jump to F232"},
{"address": "0xF22A", "comment": "Else increment current load address"},
{"address": "0xF22D", "comment": "Read next block header"},
{"address": "0xF230", "comment": "And loop back to F209"},
{"address": "0xF232", "comment": "Y=>length in control block"},
{"address": "0xF234", "comment": "File length counter low"},
{"address": "0xF236", "comment": "Store in OSFILE parameter block"},
{"address": "0xF238", "comment": "Y=Y+1"},
{"address": "0xF239", "comment": "File length counter high"},
{"address": "0xF23B", "comment": "Store in OSFILE parameter block"},
{"address": "0xF23D", "comment": "Always return 16-bit length"},
{"address": "0xF23F", "comment": "Y=Y+1"},
{"address": "0xF240", "comment": "Store in OSFILE parameter block"},
{"address": "0xF242", "comment": "Y=Y+1"},
{"address": "0xF243", "comment": "Store in OSFILE parameter block"},
{"address": "0xF245", "comment": "Get flags back"},
{"address": "0xF246", "comment": "Ring bell, reset ACIA & motor"},
{"address": "0xF249", "comment": "Test if error reported, set in current block flag"},
{"address": "0xF24B", "comment": "If bit 7 set, already reported an error, skip"},
{"address": "0xF24D", "comment": "Save flags on stack"},
{"address": "0xF24E", "comment": "Print message following call (in this case NEWLINE!)"},
{"address": "0xF253", "comment": "Restore flags"},
{"address": "0xF254", "comment": "And return"},
{"address": "0xF255", "comment": "search for a specified block"},
{"address": "0xF258", "comment": "loop back to F209"},
{"address": "0xF25A", "comment": "OS filename/command line pointer lo"},
{"address": "0xF25C", "comment": "OS filename/command line pointer hi"},
{"address": "0xF25E", "comment": "Y=0"},
{"address": "0xF260", "comment": "initialise GS string reading"},
{"address": "0xF263", "comment": "X=0"},
{"address": "0xF265", "comment": "call GSREAD"},
{"address": "0xF268", "comment": "if end of character string F277"},
{"address": "0xF26A", "comment": "if CHR$0 jump to error as &00 used as a terminator"},
{"address": "0xF26C", "comment": "store character in CFS filename area"},
{"address": "0xF26F", "comment": "increment character count"},
{"address": "0xF270", "comment": "if X<>11"},
{"address": "0xF272", "comment": "loop for up to ten characters"},
{"address": "0xF274", "comment": "else Bad String error"},
{"address": "0xF277", "comment": "terminate filename with 0"},
{"address": "0xF27C", "comment": "return"},
{"address": "0xF27D", "comment": "save A on stack"},
{"address": "0xF27E", "comment": "osfile block pointer lo"},
{"address": "0xF280", "comment": "osfile block pointer hi"},
{"address": "0xF282", "comment": "Y=0"},
{"address": "0xF284", "comment": "OSFILE parameter  block"},
{"address": "0xF286", "comment": "X=A"},
{"address": "0xF287", "comment": "Y=Y+1"},
{"address": "0xF288", "comment": "OSFILE parameter  block"},
{"address": "0xF28A", "comment": "Y=A"},
{"address": "0xF28B", "comment": "get filename from BUFFER"},
{"address": "0xF28E", "comment": "Y=2"},
{"address": "0xF290", "comment": "copy parameters to Cassette block at 3BE/C5"},
{"address": "0xF292", "comment": "from LOAD and EXEC address"},
{"address": "0xF295", "comment": "make second copy at B0-B8"},
{"address": "0xF298", "comment": "Y=Y+1"},
{"address": "0xF299", "comment": "until Y=10"},
{"address": "0xF29D", "comment": "get back A"},
{"address": "0xF29E", "comment": "if A=0, jump to do SAVE"},
{"address": "0xF2A0", "comment": "else if A<>&FF"},
{"address": "0xF2A2", "comment": "RETURN as cassette has no other options"},
{"address": "0xF2A4", "comment": "if A=&FF, jump to do LOAD"},
{"address": "0xF2A7", "comment": "Zero block number low"},
{"address": "0xF2AA", "comment": "Zero block number high"},
{"address": "0xF2AD", "comment": "Copy start/end from control block"},
{"address": "0xF2AF", "comment": "Store to zero page copy (&B0 to &B7)"},
{"address": "0xF2B2", "comment": "Data start and data end address"},
{"address": "0xF2B3", "comment": "Loop until Y=18"},
{"address": "0xF2B7", "comment": "A=X"},
{"address": "0xF2B8", "comment": "If X=0 no filename found so jump to Bad string error"},
{"address": "0xF2BA", "comment": "Set load/save cassette options into &BB, set C7=6"},
{"address": "0xF2BD", "comment": "Prompt to start recording, generate error if ROMFS"},
{"address": "0xF2C0", "comment": "A=0"},
{"address": "0xF2C2", "comment": "Claim Tube for Tube->Host transfers"},
{"address": "0xF2C5", "comment": "Set up CFS for write operation"},
{"address": "0xF2C8", "comment": "Set carry flag"},
{"address": "0xF2C9", "comment": "X=&FD"},
{"address": "0xF2CB", "comment": "Calculate 24-bit end-start"},
{"address": "0xF2D1", "comment": "Store remaining length in block header"},
{"address": "0xF2D4", "comment": "Overlaps into block flag to allow &10000"},
{"address": "0xF2D7", "comment": "Check length b16-b23"},
{"address": "0xF2D8", "comment": "Jump if length>&FFFF"},
{"address": "0xF2DA", "comment": "Check length b0-b7, CC if len<>&xx00, CS if len=&xx00"},
{"address": "0xF2DD", "comment": "A=1"},
{"address": "0xF2DF", "comment": "Subtract block length high, A=number of blocks to save"},
{"address": "0xF2E2", "comment": "If carry clear, 256 or more bytes, jump to save"},
{"address": "0xF2E4", "comment": "If length<257, X=&80, b7=last block"},
{"address": "0xF2E6", "comment": "Jump F2F0"},
{"address": "0xF2E8", "comment": "Set block length=256"},
{"address": "0xF2EA", "comment": "block length high"},
{"address": "0xF2ED", "comment": "block length"},
{"address": "0xF2F0", "comment": "block flag, flags=&00 not last block, or &80 last block"},
{"address": "0xF2F3", "comment": "Write block to Tape"},
{"address": "0xF2F6", "comment": "If negative, all done, return"},
{"address": "0xF2F8", "comment": "Increment current start address"},
{"address": "0xF2FB", "comment": "Increment block number low"},
{"address": "0xF2FE", "comment": "If not 0, loop back to save next block"},
{"address": "0xF300", "comment": "Increment block number high"},
{"address": "0xF303", "comment": "And loop back"},
{"address": "0xF305", "comment": "get filename from BUFFER"},
{"address": "0xF308", "comment": "X=&FF"},
{"address": "0xF30A", "comment": "execution address"},
{"address": "0xF30D", "comment": "load file"},
{"address": "0xF310", "comment": "&FF if tube present"},
{"address": "0xF313", "comment": "No Tube present, enter at I/O address"},
{"address": "0xF315", "comment": "Get execution address b16-b23"},
{"address": "0xF318", "comment": "AND with execution address b24-b31"},
{"address": "0xF31B", "comment": "If exec is not &FFFFxxxx, jump to I/O address"},
{"address": "0xF31D", "comment": "If exec<>&FFFFxxxx, call Tube"},
{"address": "0xF31F", "comment": "Call file in I/O via exec address"},
{"address": "0xF322", "comment": "Point XY to exec address at &03C2"},
{"address": "0xF326", "comment": "Tube call 4=Execute code"},
{"address": "0xF328", "comment": "And issue to Tube to run file"},
{"address": "0xF32B", "comment": "A=8"},
{"address": "0xF32D", "comment": "set status bits from A"},
{"address": "0xF330", "comment": "Set cassette options into (BB),set C7=6"},
{"address": "0xF333", "comment": "A=0"},
{"address": "0xF335", "comment": "search for a header"},
{"address": "0xF338", "comment": "perform read"},
{"address": "0xF33B", "comment": "A=&F7"},
{"address": "0xF33D", "comment": "clear bit 3 of CFS status bit, not cataloging"},
{"address": "0xF341", "comment": "return"},
{"address": "0xF342", "comment": "set bit 6 of E2 cassette options, EOF met"},
{"address": "0xF346", "comment": "and Jump F33F"},
{"address": "0xF348", "comment": "save A on stack, A=0 for CAT, A<>0 for LOAD"},
{"address": "0xF349", "comment": "filing system flag 0=CFS 2=RFS"},
{"address": "0xF34C", "comment": "if CFS, jump to read header"},
{"address": "0xF34E", "comment": "set current ROM/PHROM to &EF"},
{"address": "0xF351", "comment": "get byte from ROM/PHROM, CC=byte returned, CS=no response"},
{"address": "0xF354", "comment": "if carry clear, jump to read header"},
{"address": "0xF356", "comment": "clear overflow flag"},
{"address": "0xF357", "comment": "jump to return with VC, CS"},
{"address": "0xF359", "comment": "read block header"},
{"address": "0xF35C", "comment": "block number"},
{"address": "0xF35F", "comment": "current block no. lo"},
{"address": "0xF361", "comment": "block number hi"},
{"address": "0xF364", "comment": "current block no. hi"},
{"address": "0xF366", "comment": "X=&FF"},
{"address": "0xF368", "comment": "set copy of last read block flag to &FF"},
{"address": "0xF36B", "comment": "X=X+1"},
{"address": "0xF36C", "comment": "set current block flag to &00"},
{"address": "0xF36E", "comment": "jump to F376"},
{"address": "0xF370", "comment": "inc. current block no."},
{"address": "0xF373", "comment": "read block header"},
{"address": "0xF376", "comment": "get filing system flag 0=CFS 2=RFS"},
{"address": "0xF379", "comment": "if CFS F37D"},
{"address": "0xF37B", "comment": "if V clear F39A"},
{"address": "0xF37D", "comment": "get back A"},
{"address": "0xF37E", "comment": "save A on stack"},
{"address": "0xF37F", "comment": "if A=0, CAT, skip checking filename match"},
{"address": "0xF381", "comment": "else check filename header block matches searched filename"},
{"address": "0xF384", "comment": "filename doesnt match, jump to keep searching"},
{"address": "0xF386", "comment": "else A=&30 to read bits 4/5 of current OPTions"},
{"address": "0xF388", "comment": "current error OPTions"},
{"address": "0xF38A", "comment": "if ignore all errors, dont check block number"},
{"address": "0xF38C", "comment": "block number"},
{"address": "0xF38F", "comment": "compare with expected block no. lo"},
{"address": "0xF391", "comment": "wrong block"},
{"address": "0xF393", "comment": "loaded block number hi"},
{"address": "0xF396", "comment": "compare with expected block no. hi"},
{"address": "0xF398", "comment": "wrong block"},
{"address": "0xF39A", "comment": "get back A"},
{"address": "0xF39B", "comment": "matching file header found, return"},
{"address": "0xF39C", "comment": "filing system flag 0=CFS 2=RFS"},
{"address": "0xF39F", "comment": "if tape, jump to go back to searching"},
{"address": "0xF3A1", "comment": "ROMFS, use ROM displacement address"},
{"address": "0xF3A4", "comment": "set block number to &FFFF"},
{"address": "0xF3A6", "comment": "block number lo"},
{"address": "0xF3A9", "comment": "block number hi"},
{"address": "0xF3AC", "comment": "jump F370"},
{"address": "0xF3AE", "comment": "if overflow clear F3B5"},
{"address": "0xF3B0", "comment": "A=&FF"},
{"address": "0xF3B2", "comment": "set flags"},
{"address": "0xF3B5", "comment": "X=0"},
{"address": "0xF3B7", "comment": "report DATA?"},
{"address": "0xF3BA", "comment": "filing system flag 0=CFS 2=RFS"},
{"address": "0xF3BF", "comment": "current OPTions"},
{"address": "0xF3C1", "comment": "long messages not required if BIT 6 =0"},
{"address": "0xF3C3", "comment": "block flag"},
{"address": "0xF3C6", "comment": "if -ve F3A4"},
{"address": "0xF3C8", "comment": "else loop back and do it again"},
{"address": "0xF3CA", "comment": "file status or temporary store"},
{"address": "0xF3CC", "comment": "A=X"},
{"address": "0xF3CD", "comment": "save X on stack"},
{"address": "0xF3CE", "comment": "A=Y"},
{"address": "0xF3CF", "comment": "save Y on stack"},
{"address": "0xF3D0", "comment": "file status or temporary store"},
{"address": "0xF3D2", "comment": "if A is non zero open a file via F3F2"},
{"address": "0xF3D4", "comment": "A=Y"},
{"address": "0xF3D5", "comment": "if A<> 0 close specified file else close them all"},
{"address": "0xF3D7", "comment": "close spool/exec files via OSBYTE 77"},
{"address": "0xF3DA", "comment": "tidy up"},
{"address": "0xF3DD", "comment": "CFS status byte is shifted left and right to clear"},
{"address": "0xF3DF", "comment": "bit 0"},
{"address": "0xF3E1", "comment": "and if carry clear no input file was open so F3EF"},
{"address": "0xF3E3", "comment": "A contains file handle so shift bit 0 into carry"},
{"address": "0xF3E4", "comment": "if carry set close input file"},
{"address": "0xF3E6", "comment": "else shift bit 1 into carry"},
{"address": "0xF3E7", "comment": "if carry set close output file"},
{"address": "0xF3E9", "comment": "else report Channel Error as CFS can only support"},
{"address": "0xF3EC", "comment": "tidy up"},
{"address": "0xF3EF", "comment": "and exit"},
{"address": "0xF3F2", "comment": "get filename from BUFFER"},
{"address": "0xF3F5", "comment": "file status or temporary store"},
{"address": "0xF3F7", "comment": "check A at input if bit 6 not set its an output file"},
{"address": "0xF3F9", "comment": "else its an input file"},
{"address": "0xF3FB", "comment": "BGET buffer offset for next byte"},
{"address": "0xF3FE", "comment": "Expected BGET file block number lo"},
{"address": "0xF401", "comment": "expected BGET file block number hi"},
{"address": "0xF404", "comment": "A=&3E"},
{"address": "0xF406", "comment": "CFS status =CFS status AND A"},
{"address": "0xF409", "comment": "claim serial system and set OPTions"},
{"address": "0xF40C", "comment": "save flags on stack"},
{"address": "0xF40D", "comment": "search for file"},
{"address": "0xF410", "comment": "check protection bit of block status and respond"},
{"address": "0xF413", "comment": "get back flags"},
{"address": "0xF414", "comment": "X=&FF increment to 0 on next instruction"},
{"address": "0xF416", "comment": "X=X+1"},
{"address": "0xF417", "comment": "get file name and"},
{"address": "0xF41A", "comment": "store as BGET filename"},
{"address": "0xF41D", "comment": "until end of filename"},
{"address": "0xF41F", "comment": "A=1 to show file open"},
{"address": "0xF421", "comment": "set status bits from A"},
{"address": "0xF424", "comment": "CFS currently resident file block length lo"},
{"address": "0xF427", "comment": "CFS currently resident file block length hi"},
{"address": "0xF42A", "comment": "if block length is 0"},
{"address": "0xF42C", "comment": "set CFS status bit 3 (EOF reached)"},
{"address": "0xF42F", "comment": "A=1"},
{"address": "0xF431", "comment": "filing system flag 0=CFS 2=RFS"},
{"address": "0xF434", "comment": "and exit after restoring registers"},
{"address": "0xF436", "comment": "A=X"},
{"address": "0xF437", "comment": "if X=0 then zero length filename so"},
{"address": "0xF439", "comment": "Bad String error"},
{"address": "0xF43C", "comment": "X=&FF"},
{"address": "0xF43E", "comment": "X=X+1"},
{"address": "0xF43F", "comment": "sought filename"},
{"address": "0xF442", "comment": "BPUT file header block"},
{"address": "0xF445", "comment": "until A=0 end of filename"},
{"address": "0xF447", "comment": "A=&FF"},
{"address": "0xF449", "comment": "X=8"},
{"address": "0xF44B", "comment": "set 38C-93 to &FF"},
{"address": "0xF44E", "comment": "set load/exec to &FFFFFFFF"},
{"address": "0xF451", "comment": "A=X=0"},
{"address": "0xF452", "comment": "X=14"},
{"address": "0xF454", "comment": "BPUT file header block"},
{"address": "0xF457", "comment": "X=X+1"},
{"address": "0xF458", "comment": "this zeros 394-D"},
{"address": "0xF45F", "comment": "Set cassette options into &BB, set &C7=6"},
{"address": "0xF462", "comment": "prompt to start recording, generate error if ROMFS"},
{"address": "0xF465", "comment": "claim Tube and reset serial system"},
{"address": "0xF468", "comment": "A=2"},
{"address": "0xF46A", "comment": "set status bits from A"},
{"address": "0xF46D", "comment": "A=2"},
{"address": "0xF46F", "comment": "file status or temporary store"},
{"address": "0xF471", "comment": "get back A"},
{"address": "0xF472", "comment": "Y=A"},
{"address": "0xF473", "comment": "get back A"},
{"address": "0xF474", "comment": "X=A"},
{"address": "0xF475", "comment": "file status or temporary store"},
{"address": "0xF477", "comment": "return"},
{"address": "0xF478", "comment": "A=2 clearing all but bit 1 of status byte"},
{"address": "0xF47A", "comment": "CFS status byte, with output file open"},
{"address": "0xF47C", "comment": "if file not open then exit"},
{"address": "0xF47E", "comment": "else A=0"},
{"address": "0xF480", "comment": "set block length to current value of BPUT offset"},
{"address": "0xF483", "comment": "A=&80"},
{"address": "0xF485", "comment": "get BPUT buffer offset"},
{"address": "0xF488", "comment": "set block length to current value of BPUT offset"},
{"address": "0xF48B", "comment": "mark current block as last"},
{"address": "0xF48E", "comment": "save block to tape"},
{"address": "0xF491", "comment": "A=&FD"},
{"address": "0xF493", "comment": "CFS status =CFS status AND A"},
{"address": "0xF496", "comment": "claim serial system and set OPTions"},
{"address": "0xF499", "comment": "X=11"},
{"address": "0xF49B", "comment": "copy header block from 38C-39D"},
{"address": "0xF49E", "comment": "to 3BE/DF"},
{"address": "0xF4A1", "comment": "X=X-1"},
{"address": "0xF4A4", "comment": "set start address to &FFFFxxxx"},
{"address": "0xF4A6", "comment": "to point to cassette buffers in I/O memory"},
{"address": "0xF4A8", "comment": "X=X+1, (X=0)"},
{"address": "0xF4A9", "comment": "current load address low byte set to &00"},
{"address": "0xF4AB", "comment": "A=9 to set current load address at &900"},
{"address": "0xF4AD", "comment": "start address set to &FFFF0900"},
{"address": "0xF4AF", "comment": "X=&7F"},
{"address": "0xF4B1", "comment": "copy from 301/C+X to 3D2/C sought filename"},
{"address": "0xF4B4", "comment": "copy of last read block flag"},
{"address": "0xF4B7", "comment": "switch Motor On"},
{"address": "0xF4BA", "comment": "set up CFS for write operation"},
{"address": "0xF4BD", "comment": "write block to Tape"},
{"address": "0xF4C0", "comment": "block number lo"},
{"address": "0xF4C5", "comment": "block number hi"},
{"address": "0xF4C8", "comment": "return"},
{"address": "0xF4C9", "comment": "A=X"},
{"address": "0xF4CA", "comment": "save A on stack"},
{"address": "0xF4CB", "comment": "A=Y"},
{"address": "0xF4CC", "comment": "save A on stack"},
{"address": "0xF4CD", "comment": "A=1"},
{"address": "0xF4CF", "comment": "check conditions for OSBGET are OK"},
{"address": "0xF4D2", "comment": "CFS status byte"},
{"address": "0xF4D4", "comment": "shift bit 7 into carry (EOF warning given)"},
{"address": "0xF4D5", "comment": "if carry set F523"},
{"address": "0xF4D7", "comment": "shift bit 6 into carry"},
{"address": "0xF4D8", "comment": "if clear EOF not reached F4E3"},
{"address": "0xF4DA", "comment": "else A=&80 setting bit 7 of status byte EOF warning"},
{"address": "0xF4DC", "comment": "set status bits from A"},
{"address": "0xF4DF", "comment": "A=&FE"},
{"address": "0xF4E1", "comment": "if carry set F51B"},
{"address": "0xF4E3", "comment": "BGET buffer offset for next byte"},
{"address": "0xF4E6", "comment": "X=X+1"},
{"address": "0xF4E7", "comment": "CFS currently resident file block length lo"},
{"address": "0xF4EA", "comment": "read a byte"},
{"address": "0xF4EC", "comment": "block flag of currently resident block"},
{"address": "0xF4EF", "comment": "if bit 7=1 this is the last block so F513 else"},
{"address": "0xF4F1", "comment": "last character of currently resident block"},
{"address": "0xF4F4", "comment": "save A on stack"},
{"address": "0xF4F5", "comment": "claim serial system and set OPTions"},
{"address": "0xF4F8", "comment": "save flags on stack"},
{"address": "0xF4F9", "comment": "read in a new block"},
{"address": "0xF4FC", "comment": "get back flags"},
{"address": "0xF4FD", "comment": "get back A"},
{"address": "0xF4FE", "comment": "file status or temporary store"},
{"address": "0xF500", "comment": "clear carry flag"},
{"address": "0xF501", "comment": "block flag of currently resident block"},
{"address": "0xF504", "comment": "if not last block (bit 7=0)"},
{"address": "0xF506", "comment": "CFS currently resident file block length lo"},
{"address": "0xF509", "comment": "CFS currently resident file block length hi"},
{"address": "0xF50C", "comment": "if block size not 0 F51D else"},
{"address": "0xF50E", "comment": "set CFS status bit 6 (EOF reached)"},
{"address": "0xF511", "comment": "goto F51D"},
{"address": "0xF513", "comment": "set CFS status bit 6 (EOF reached)"},
{"address": "0xF516", "comment": "X=X-1"},
{"address": "0xF517", "comment": "clear carry flag"},
{"address": "0xF518", "comment": "read byte from cassette buffer"},
{"address": "0xF51B", "comment": "file status or temporary store"},
{"address": "0xF51D", "comment": "BGET buffer offset for next byte"},
{"address": "0xF520", "comment": "exit via F471"},
{"address": "0xF529", "comment": "store A in temorary store"},
{"address": "0xF52B", "comment": "and stack X and Y"},
{"address": "0xF52C", "comment": "save  on stack"},
{"address": "0xF52D", "comment": "A=Y"},
{"address": "0xF52E", "comment": "save on stack"},
{"address": "0xF52F", "comment": "A=2"},
{"address": "0xF531", "comment": "check conditions necessary for OSBPUT are OK"},
{"address": "0xF534", "comment": "BPUT buffer offset for next byte"},
{"address": "0xF537", "comment": "get back original value of A"},
{"address": "0xF539", "comment": "Cassette buffer"},
{"address": "0xF53C", "comment": "X=X+1"},
{"address": "0xF53D", "comment": "if not 0 F545, otherwise buffer is full so"},
{"address": "0xF53F", "comment": "save block to tape"},
{"address": "0xF542", "comment": "enable second processor and reset serial system"},
{"address": "0xF545", "comment": "BPUT buffer offset for next byte"},
{"address": "0xF548", "comment": "get back A"},
{"address": "0xF54A", "comment": "and exit"},
{"address": "0xF54D", "comment": "A=X"},
{"address": "0xF54E", "comment": "*OPT 0 - set default options"},
{"address": "0xF550", "comment": "if X=3"},
{"address": "0xF552", "comment": "F573 to set interblock gap"},
{"address": "0xF554", "comment": "else if Y>2 then BAD COMMAND error"},
{"address": "0xF558", "comment": "X=X-1"},
{"address": "0xF559", "comment": "i.e. if X=1 F561 message control"},
{"address": "0xF55B", "comment": "X=X-1"},
{"address": "0xF55C", "comment": "i.e. if X=2 F568 error response"},
{"address": "0xF55E", "comment": "else E310 to issue Bad Command error"},
{"address": "0xF561", "comment": "keep lower two bits of each nybble"},
{"address": "0xF563", "comment": "Y=Y+1"},
{"address": "0xF564", "comment": "Y=Y+1"},
{"address": "0xF565", "comment": "Y=Y+1"},
{"address": "0xF566", "comment": "go to F56A"},
{"address": "0xF568", "comment": "keep top two bits of each nybble"},
{"address": "0xF56A", "comment": "Y=Y+1"},
{"address": "0xF56B", "comment": "clear lower two bits of each nybble"},
{"address": "0xF56D", "comment": "ORA with table value"},
{"address": "0xF570", "comment": "store it in &E3"},
{"address": "0xF572", "comment": "return"},
{"address": "0xF573", "comment": "A=Y"},
{"address": "0xF574", "comment": "If Y>127 use default values"},
{"address": "0xF576", "comment": "If Y<>0 dont use default value"},
{"address": "0xF578", "comment": "Else A=&19 default value"},
{"address": "0xF57A", "comment": "Sequential block gap"},
{"address": "0xF57D", "comment": "Return"},
{"address": "0xF57E", "comment": "Y=A"},
{"address": "0xF57F", "comment": "jump to F56D"},
{"address": "0xF588", "comment": "filing system buffer flag"},
{"address": "0xF58A", "comment": "filing system flag 0=CFS 2=RFS"},
{"address": "0xF58D", "comment": "if CFS F596"},
{"address": "0xF58F", "comment": "read RFS data rom or Phrom"},
{"address": "0xF592", "comment": "Y=A"},
{"address": "0xF593", "comment": "clear carry flag"},
{"address": "0xF594", "comment": "jump to F5B0"},
{"address": "0xF596", "comment": "ACIA status register"},
{"address": "0xF599", "comment": "save A on stack"},
{"address": "0xF59A", "comment": "clear all but bits 0,1 A=(0-3)"},
{"address": "0xF59C", "comment": "if 0 F5A9 transmit data register full or RDR empty"},
{"address": "0xF5A2", "comment": "get back A"},
{"address": "0xF5A3", "comment": "character temporary storage"},
{"address": "0xF5A5", "comment": "ACIA transmit data register"},
{"address": "0xF5A8", "comment": "return"},
{"address": "0xF5A9", "comment": "read ACIA recieve data register"},
{"address": "0xF5AC", "comment": "get back A"},
{"address": "0xF5AD", "comment": "bit 2 to carry (data carrier detect)"},
{"address": "0xF5B0", "comment": "progress flag"},
{"address": "0xF5B2", "comment": "if &C2=0 exit"},
{"address": "0xF5B4", "comment": "X=X-1"},
{"address": "0xF5B5", "comment": "if &C2>1 then F5BD"},
{"address": "0xF5B7", "comment": "else if carrier tone from cassette detected exit"},
{"address": "0xF5B9", "comment": "Y=2"},
{"address": "0xF5BD", "comment": "X=X-1"},
{"address": "0xF5BE", "comment": "if &C2>2"},
{"address": "0xF5C0", "comment": "if carrier tone from cassette not detected  exit"},
{"address": "0xF5C2", "comment": "A=byte read"},
{"address": "0xF5C3", "comment": "set (BE/C0) to 0"},
{"address": "0xF5C6", "comment": "Y=3, sync byte found"},
{"address": "0xF5C8", "comment": "is A= to synchronising byte &2A?"},
{"address": "0xF5CA", "comment": "if so F61B"},
{"address": "0xF5CC", "comment": "control cassette system"},
{"address": "0xF5CF", "comment": "Y=1, waiting for carrier tone"},
{"address": "0xF5D1", "comment": "goto F61B"},
{"address": "0xF5D3", "comment": "X=X-1"},
{"address": "0xF5D4", "comment": "if &C2>3"},
{"address": "0xF5D8", "comment": "get character read into Y"},
{"address": "0xF5DA", "comment": "if 0 exit via F61D"},
{"address": "0xF5DC", "comment": "else A=&80"},
{"address": "0xF5DE", "comment": "filing system buffer flag"},
{"address": "0xF5E0", "comment": "and exit"},
{"address": "0xF5E2", "comment": "X=X-1"},
{"address": "0xF5E3", "comment": "if &C2>4 F60E"},
{"address": "0xF5E5", "comment": "if carry set F616"},
{"address": "0xF5E7", "comment": "A=Y"},
{"address": "0xF5E8", "comment": "perform CRC"},
{"address": "0xF5EB", "comment": "get offset into current block"},
{"address": "0xF5ED", "comment": "increment offset into current block"},
{"address": "0xF5EF", "comment": "if bit 7 set this is the last byte read"},
{"address": "0xF5F1", "comment": "so F600"},
{"address": "0xF5F3", "comment": "check if second processor file test tube prescence"},
{"address": "0xF5F6", "comment": "if return with A=0 F5FD"},
{"address": "0xF5F8", "comment": "Tube FIFO3"},
{"address": "0xF5FD", "comment": "A=X restore value"},
{"address": "0xF5FE", "comment": "store to current load address"},
{"address": "0xF600", "comment": "Y=Y+1"},
{"address": "0xF601", "comment": "block length"},
{"address": "0xF604", "comment": "exit with NE"},
{"address": "0xF606", "comment": "A=1, two bytes of CRC to fetch"},
{"address": "0xF608", "comment": "store for next call"},
{"address": "0xF60A", "comment": "Y=5"},
{"address": "0xF60C", "comment": "exit, setting progress=&05, looking for CRC"},
{"address": "0xF60E", "comment": "A=Y"},
{"address": "0xF60F", "comment": "perform CRC"},
{"address": "0xF612", "comment": "decrement number of CRC bytes to fetch"},
{"address": "0xF614", "comment": "more to fetch, exit"},
{"address": "0xF616", "comment": "reset ACIA"},
{"address": "0xF619", "comment": "Y=0, progress=idle"},
{"address": "0xF61B", "comment": "set progress flag"},
{"address": "0xF61D", "comment": "return"},
{"address": "0xF61E", "comment": "save A on stack"},
{"address": "0xF61F", "comment": "A=Y"},
{"address": "0xF620", "comment": "save Y on stack"},
{"address": "0xF621", "comment": "A=X to put X into Y"},
{"address": "0xF622", "comment": "Y=A"},
{"address": "0xF623", "comment": "A=3"},
{"address": "0xF625", "comment": "confirm file is open"},
{"address": "0xF628", "comment": "CFS status byte"},
{"address": "0xF62C", "comment": "X=A"},
{"address": "0xF62D", "comment": "get back A"},
{"address": "0xF62E", "comment": "Y=A"},
{"address": "0xF62F", "comment": "get back A"},
{"address": "0xF630", "comment": "return"},
{"address": "0xF631", "comment": "A=0"},
{"address": "0xF633", "comment": "current block no. lo"},
{"address": "0xF635", "comment": "current block no. hi"},
{"address": "0xF637", "comment": "current block no. lo"},
{"address": "0xF639", "comment": "save current block lo on stack"},
{"address": "0xF63A", "comment": "set expected block to current block"},
{"address": "0xF63C", "comment": "current block no. hi"},
{"address": "0xF63E", "comment": "save current block hi"},
{"address": "0xF63F", "comment": "set expected block to current block"},
{"address": "0xF641", "comment": "print inline message"},
{"address": "0xF64F", "comment": "A=&FF for loading (A=0 for CAT)"},
{"address": "0xF651", "comment": "Search for header"},
{"address": "0xF655", "comment": "Restore current block hi"},
{"address": "0xF658", "comment": "Restore current block lo"},
{"address": "0xF65A", "comment": "Check expected block number"},
{"address": "0xF65E", "comment": "If expected block<>0, jump to return"},
{"address": "0xF660", "comment": "Set current block back to zero"},
{"address": "0xF664", "comment": "Get checksum result"},
{"address": "0xF666", "comment": "Bad checksum, skip setting current filename"},
{"address": "0xF668", "comment": "X+1=>filename in block header"},
{"address": "0xF66A", "comment": "Copy filename from block header to current filename"},
{"address": "0xF66D", "comment": "Filing system flag 0=CFS 2=RFS"},
{"address": "0xF670", "comment": "If cassette, exit with Y=&FF at F685"},
{"address": "0xF672", "comment": "If ROMFS and not end-of-ROM, exit"},
{"address": "0xF674", "comment": "ROMFS and no more ROM, give error"},
{"address": "0xF685", "comment": "Y=&FF"},
{"address": "0xF687", "comment": "Copy of last read block flag"},
{"address": "0xF68A", "comment": "Return"},
{"address": "0xF68B", "comment": "A=0"},
{"address": "0xF68D", "comment": "save flags on stack"},
{"address": "0xF68E", "comment": "&E6=Y"},
{"address": "0xF690", "comment": "EXEC file handle"},
{"address": "0xF693", "comment": "EXEC file handle"},
{"address": "0xF696", "comment": "if not 0 close file via OSFIND"},
{"address": "0xF69B", "comment": "else Y= original Y"},
{"address": "0xF69D", "comment": "get back flags"},
{"address": "0xF69E", "comment": "if A=0 on entry exit else"},
{"address": "0xF6A0", "comment": "A=&40"},
{"address": "0xF6A2", "comment": "to open an input file"},
{"address": "0xF6A5", "comment": "Y=A"},
{"address": "0xF6A6", "comment": "If Y=0 File not found else store"},
{"address": "0xF6A8", "comment": "EXEC file handle"},
{"address": "0xF6AB", "comment": "return"},
{"address": "0xF6AC", "comment": "X=&A6"},
{"address": "0xF6AE", "comment": "copy from 301/C+X to 3D2/C sought filename"},
{"address": "0xF6B1", "comment": "read block header"},
{"address": "0xF6B4", "comment": "block flag"},
{"address": "0xF6B7", "comment": "A=A/2 bit 0 into carry to check for locked file"},
{"address": "0xF6B8", "comment": "if not set then skip next instruction"},
{"address": "0xF6BA", "comment": "locked file routine"},
{"address": "0xF6BD", "comment": "Expected BGET file block number lo"},
{"address": "0xF6C0", "comment": "current block no. lo"},
{"address": "0xF6C2", "comment": "expected BGET file block number hi"},
{"address": "0xF6C5", "comment": "current block no. hi"},
{"address": "0xF6C7", "comment": "A=0"},
{"address": "0xF6C9", "comment": "current load address"},
{"address": "0xF6CB", "comment": "A=&A setting current load address to the CFS/RFS"},
{"address": "0xF6CD", "comment": "current load address buffer at &A00"},
{"address": "0xF6CF", "comment": "A=&FF to set other 2 bytes"},
{"address": "0xF6D1", "comment": "current load address high word"},
{"address": "0xF6D3", "comment": "current load address high word"},
{"address": "0xF6D5", "comment": "reset flags"},
{"address": "0xF6D8", "comment": "load file from tape"},
{"address": "0xF6DB", "comment": "if return non zero F702 else"},
{"address": "0xF6DD", "comment": "get last character from input buffer"},
{"address": "0xF6E0", "comment": "last character currently resident block"},
{"address": "0xF6E3", "comment": "inc. current block no."},
{"address": "0xF6E6", "comment": "expected BGET file block number lo"},
{"address": "0xF6E9", "comment": "expected BGET file block number hi"},
{"address": "0xF6EC", "comment": "X=2"},
{"address": "0xF6EE", "comment": "read bytes from block flag/block length"},
{"address": "0xF6F1", "comment": "store into current values of above"},
{"address": "0xF6F4", "comment": "X=X-1"},
{"address": "0xF6F5", "comment": "until X=-1 (&FF)"},
{"address": "0xF6F7", "comment": "block flag of currently resident block"},
{"address": "0xF6FC", "comment": "print newline if needed"},
{"address": "0xF6FF", "comment": "enable second processor and reset serial system"},
{"address": "0xF702", "comment": "search for a specified block"},
{"address": "0xF705", "comment": "if NE check for locked condition else"},
{"address": "0xF707", "comment": "is it Synchronising byte &2A?"},
{"address": "0xF709", "comment": "if so F742"},
{"address": "0xF70B", "comment": "else is it &23 (header substitute in ROM files)"},
{"address": "0xF70D", "comment": "if not BAD ROM error"},
{"address": "0xF70F", "comment": "block number"},
{"address": "0xF714", "comment": "block number hi"},
{"address": "0xF717", "comment": "X=&FF"},
{"address": "0xF719", "comment": "to set V & M"},
{"address": "0xF71C", "comment": "and jump (ALWAYS!!) to F773"},
{"address": "0xF71E", "comment": "clear bit 3 of RFS status (current CAT status)"},
{"address": "0xF720", "comment": "RFS status =RFS status AND A"},
{"address": "0xF723", "comment": "and cause error"},
{"address": "0xF72D", "comment": "get ESCAPE flag"},
{"address": "0xF72F", "comment": "switch Motor on"},
{"address": "0xF732", "comment": "A=1"},
{"address": "0xF734", "comment": "progress flag"},
{"address": "0xF736", "comment": "control serial system"},
{"address": "0xF739", "comment": "confirm ESC not set and CFS not executing"},
{"address": "0xF73C", "comment": "A=3"},
{"address": "0xF73E", "comment": "progress flag"},
{"address": "0xF740", "comment": "back until &C2=3"},
{"address": "0xF742", "comment": "Y=0"},
{"address": "0xF744", "comment": "zero checksum bytes"},
{"address": "0xF747", "comment": "get character from file and do CRC"},
{"address": "0xF74A", "comment": "if V clear on exit F766"},
{"address": "0xF74C", "comment": "else store"},
{"address": "0xF74F", "comment": "or if A=0 F757"},
{"address": "0xF751", "comment": "Y=Y+1"},
{"address": "0xF752", "comment": "if Y<>&B"},
{"address": "0xF754", "comment": "go back for next character"},
{"address": "0xF756", "comment": "Y=Y-1"},
{"address": "0xF757", "comment": "X=12"},
{"address": "0xF759", "comment": "get character from file and do CRC"},
{"address": "0xF75C", "comment": "if V clear on exit F766"},
{"address": "0xF75E", "comment": "else store byte"},
{"address": "0xF761", "comment": "X=X+1"},
{"address": "0xF762", "comment": "if X<>31"},
{"address": "0xF764", "comment": "goto F759"},
{"address": "0xF766", "comment": "A=Y"},
{"address": "0xF767", "comment": "X=A"},
{"address": "0xF768", "comment": "A=0"},
{"address": "0xF76A", "comment": "store it"},
{"address": "0xF76D", "comment": "CRC workspace"},
{"address": "0xF76F", "comment": "CRC workspace"},
{"address": "0xF771", "comment": "Checksum result"},
{"address": "0xF773", "comment": "set (BE/C0) to 0"},
{"address": "0xF776", "comment": "progress flag"},
{"address": "0xF778", "comment": "A=X"},
{"address": "0xF77B", "comment": "filing system flag 0=CFS 2=RFS"},
{"address": "0xF77E", "comment": "if cassette F72D"},
{"address": "0xF780", "comment": "read RFS data rom or Phrom"},
{"address": "0xF783", "comment": "is it ROM file terminator?"},
{"address": "0xF785", "comment": "if not F707"},
{"address": "0xF787", "comment": "A=8 isolating bit 3 CAT status"},
{"address": "0xF789", "comment": "CFS status byte"},
{"address": "0xF78B", "comment": "if clera skip next instruction"},
{"address": "0xF78D", "comment": "print CR if CFS not operational"},
{"address": "0xF790", "comment": "get byte from data Rom"},
{"address": "0xF793", "comment": "if carry set F780"},
{"address": "0xF795", "comment": "clear overflow flag"},
{"address": "0xF796", "comment": "return"},
{"address": "0xF797", "comment": "filing system flag 0=CFS 2=RFS"},
{"address": "0xF79A", "comment": "if cassette F7AD"},
{"address": "0xF79C", "comment": "A=X to save X and Y"},
{"address": "0xF79D", "comment": "save X on stack"},
{"address": "0xF79E", "comment": "A=Y"},
{"address": "0xF79F", "comment": "save Y on stack"},
{"address": "0xF7A0", "comment": "read RFS data rom or Phrom"},
{"address": "0xF7A3", "comment": "put it in temporary storage"},
{"address": "0xF7A5", "comment": "A=&FF"},
{"address": "0xF7A7", "comment": "filing system buffer flag"},
{"address": "0xF7A9", "comment": "get back Y"},
{"address": "0xF7AA", "comment": "Y=A"},
{"address": "0xF7AB", "comment": "get back X"},
{"address": "0xF7AC", "comment": "X=A"},
{"address": "0xF7AD", "comment": "check for Escape and loop till bit 7 of FS buffer"},
{"address": "0xF7B0", "comment": "save flags on stack"},
{"address": "0xF7B1", "comment": "save A on stack"},
{"address": "0xF7B2", "comment": "set carry flag"},
{"address": "0xF7B3", "comment": "CRC Bit counter"},
{"address": "0xF7B5", "comment": "CRC workspace"},
{"address": "0xF7B7", "comment": "CRC workspace"},
{"address": "0xF7B9", "comment": "CRC workspace"},
{"address": "0xF7BB", "comment": "A=A*2 C=bit 7"},
{"address": "0xF7BE", "comment": "A=A/2"},
{"address": "0xF7C1", "comment": "CRC workspace"},
{"address": "0xF7C3", "comment": "CRC workspace"},
{"address": "0xF7C7", "comment": "CRC workspace"},
{"address": "0xF7C9", "comment": "set carry flag"},
{"address": "0xF7CA", "comment": "CRC workspace"},
{"address": "0xF7CC", "comment": "CRC workspace"},
{"address": "0xF7CE", "comment": "CRC Bit counter"},
{"address": "0xF7D2", "comment": "get back A"},
{"address": "0xF7D3", "comment": "get back flags"},
{"address": "0xF7D4", "comment": "return"},
{"address": "0xF7D5", "comment": "A=0"},
{"address": "0xF7D7", "comment": "&BD=character temporary storage buffer=0"},
{"address": "0xF7D9", "comment": "X=0"},
{"address": "0xF7DB", "comment": "file status or temporary store"},
{"address": "0xF7DF", "comment": "block length"},
{"address": "0xF7E2", "comment": "block length hi"},
{"address": "0xF7E5", "comment": "if 0 F7E9"},
{"address": "0xF7E7", "comment": "else X=4"},
{"address": "0xF7E9", "comment": "filename length/progress flag"},
{"address": "0xF7EB", "comment": "return"},
{"address": "0xF7EC", "comment": "save flags on stack"},
{"address": "0xF7ED", "comment": "X=3"},
{"address": "0xF7EF", "comment": "A=0"},
{"address": "0xF7F1", "comment": "clear 03CB/E (RFS EOF+1?)"},
{"address": "0xF7F4", "comment": "X=X-1"},
{"address": "0xF7F7", "comment": "block number"},
{"address": "0xF7FA", "comment": "block number hi"},
{"address": "0xF7FD", "comment": "if block =0 F804 else"},
{"address": "0xF7FF", "comment": "generate a 5 second delay"},
{"address": "0xF802", "comment": "goto F807"},
{"address": "0xF804", "comment": "generate delay set by interblock gap"},
{"address": "0xF807", "comment": "A=&2A"},
{"address": "0xF809", "comment": "store it in temporary file"},
{"address": "0xF80B", "comment": "set (BE/C0) to 0"},
{"address": "0xF80E", "comment": "set ACIA control register"},
{"address": "0xF811", "comment": "check for Escape and loop till bit 7 of FS buffer"},
{"address": "0xF814", "comment": "Y=Y-1"},
{"address": "0xF815", "comment": "Y=Y+1"},
{"address": "0xF816", "comment": "move sought filename"},
{"address": "0xF819", "comment": "into filename block"},
{"address": "0xF81C", "comment": "transfer byte to CFS and do CRC"},
{"address": "0xF81F", "comment": "if filename not complet then do it again"},
{"address": "0xF821", "comment": "X=12"},
{"address": "0xF823", "comment": "get filename byte"},
{"address": "0xF826", "comment": "transfer byte to CFS and do CRC"},
{"address": "0xF829", "comment": "X=X+1"},
{"address": "0xF82A", "comment": "until X=29"},
{"address": "0xF82E", "comment": "save checksum to TAPE reset buffer flag"},
{"address": "0xF831", "comment": "block length"},
{"address": "0xF834", "comment": "block length hi"},
{"address": "0xF837", "comment": "if 0 F855"},
{"address": "0xF839", "comment": "else Y=0"},
{"address": "0xF83B", "comment": "zero checksum bytes"},
{"address": "0xF83E", "comment": "get a data byte"},
{"address": "0xF840", "comment": "check if second processor file test tube prescence"},
{"address": "0xF843", "comment": "if not F848 else"},
{"address": "0xF845", "comment": "Tube FIFO3"},
{"address": "0xF848", "comment": "A=X"},
{"address": "0xF849", "comment": "transfer byte to CFS and do CRC"},
{"address": "0xF84C", "comment": "Y=Y+1"},
{"address": "0xF84D", "comment": "block length"},
{"address": "0xF852", "comment": "save checksum to TAPE reset buffer flag"},
{"address": "0xF855", "comment": "check for Escape and loop till bit 7 of FS buffer"},
{"address": "0xF858", "comment": "check for Escape and loop till bit 7 of FS buffer"},
{"address": "0xF85B", "comment": "reset ACIA"},
{"address": "0xF85E", "comment": "A=1"},
{"address": "0xF860", "comment": "generate 0.1 * A second delay"},
{"address": "0xF863", "comment": "get back flags"},
{"address": "0xF864", "comment": "update block flag, PRINT filename (& address if reqd)"},
{"address": "0xF867", "comment": "block flag"},
{"address": "0xF86A", "comment": "is this last block (bit 7 set)?"},
{"address": "0xF86C", "comment": "save flags on stack"},
{"address": "0xF86D", "comment": "generate a 5 second delay"},
{"address": "0xF870", "comment": "sound bell and abort"},
{"address": "0xF873", "comment": "get back flags"},
{"address": "0xF874", "comment": "return"},
{"address": "0xF875", "comment": "save byte to buffer, transfer to CFS & reset flag"},
{"address": "0xF878", "comment": "perform CRC"},
{"address": "0xF87B", "comment": "CRC workspace"},
{"address": "0xF87D", "comment": "save byte to buffer, transfer to CFS & reset flag"},
{"address": "0xF880", "comment": "CRC workspace"},
{"address": "0xF882", "comment": "store A in temporary buffer"},
{"address": "0xF884", "comment": "confirm ESC not set and CFS not executing"},
{"address": "0xF887", "comment": "filing system buffer flag"},
{"address": "0xF889", "comment": "loop until bit 7 of &C0 is set"},
{"address": "0xF88B", "comment": "A=0"},
{"address": "0xF88D", "comment": "filing system buffer flag"},
{"address": "0xF88F", "comment": "get temporary store byte"},
{"address": "0xF891", "comment": "return"},
{"address": "0xF892", "comment": "A=50"},
{"address": "0xF894", "comment": "generate delay 100ms *A (5 seconds)"},
{"address": "0xF896", "comment": "get current interblock flag"},
{"address": "0xF898", "comment": "X=5"},
{"address": "0xF89A", "comment": "CFS timeout counter"},
{"address": "0xF89D", "comment": "confirm ESC not set and CFS not executing"},
{"address": "0xF8A0", "comment": "CFS timeout counter (decremented each 20ms)"},
{"address": "0xF8A3", "comment": "if +ve F89D"},
{"address": "0xF8A5", "comment": "X=X-1"},
{"address": "0xF8A8", "comment": "return"},
{"address": "0xF8A9", "comment": "block number"},
{"address": "0xF8AC", "comment": "block number hi"},
{"address": "0xF8AF", "comment": "if 0 F8B6"},
{"address": "0xF8B1", "comment": "copy of last read block flag"},
{"address": "0xF8B4", "comment": "update block flag, PRINT filename (& address if reqd)"},
{"address": "0xF8B6", "comment": "print newline if needed"},
{"address": "0xF8B9", "comment": "Y=0"},
{"address": "0xF8BB", "comment": "current block flag"},
{"address": "0xF8BD", "comment": "block flag"},
{"address": "0xF8C0", "comment": "copy of last read block flag"},
{"address": "0xF8C3", "comment": "check if free to print message"},
{"address": "0xF8C6", "comment": "if A=0 on return Cassette system is busy"},
{"address": "0xF8C8", "comment": "else A=&0D :carriage return"},
{"address": "0xF8CA", "comment": "print it (note no linefeed as its via OSWRCH)"},
{"address": "0xF8CD", "comment": "get byte from filename"},
{"address": "0xF8D0", "comment": "if 0 filename is ended"},
{"address": "0xF8D2", "comment": "if <SPACE"},
{"address": "0xF8D4", "comment": "F8DA"},
{"address": "0xF8D6", "comment": "if less than DELETE"},
{"address": "0xF8D8", "comment": "its a printable character for F8DC else"},
{"address": "0xF8DA", "comment": "else A=?"},
{"address": "0xF8DC", "comment": "and print it"},
{"address": "0xF8DF", "comment": "Y=Y+1"},
{"address": "0xF8E0", "comment": "back to get rest of filename"},
{"address": "0xF8E2", "comment": "filing system flag 0=CFS 2=RFS"},
{"address": "0xF8E5", "comment": "if cassette F8EB"},
{"address": "0xF8E7", "comment": "test current OPTions"},
{"address": "0xF8E9", "comment": "if bit 6 clear no,long messages needed F933"},
{"address": "0xF8EB", "comment": "print a space"},
{"address": "0xF8EE", "comment": "Y=Y+1"},
{"address": "0xF8EF", "comment": "if Y<11 then"},
{"address": "0xF8F1", "comment": "loop again to fill out filename with spaces"},
{"address": "0xF8F3", "comment": "block number"},
{"address": "0xF8F6", "comment": "X=A"},
{"address": "0xF8F7", "comment": "print ASCII equivalent of hex byte"},
{"address": "0xF8FA", "comment": "block flag"},
{"address": "0xF8FD", "comment": "if not end of file return"},
{"address": "0xF8FF", "comment": "A=X"},
{"address": "0xF900", "comment": "clear carry flag"},
{"address": "0xF901", "comment": "block length hi"},
{"address": "0xF904", "comment": "file length counter hi"},
{"address": "0xF906", "comment": "print space + ASCII equivalent of hex byte"},
{"address": "0xF909", "comment": "block length"},
{"address": "0xF90C", "comment": "file length counter lo"},
{"address": "0xF90E", "comment": "print ASCII equivalent of hex byte"},
{"address": "0xF911", "comment": "current OPTions"},
{"address": "0xF913", "comment": "if bit 6 clear no long messages required so F933"},
{"address": "0xF915", "comment": "X=4"},
{"address": "0xF917", "comment": "print a space"},
{"address": "0xF91A", "comment": "X=X-1"},
{"address": "0xF91B", "comment": "loop to print 4 spaces"},
{"address": "0xF91D", "comment": "X=&0F to point to load address"},
{"address": "0xF91F", "comment": "print 4 bytes from CFS block header"},
{"address": "0xF922", "comment": "print a space"},
{"address": "0xF925", "comment": "X=&13 point to Execution address"},
{"address": "0xF927", "comment": "loop pointer"},
{"address": "0xF929", "comment": "block header"},
{"address": "0xF92C", "comment": "print ASCII equivalent of hex byte"},
{"address": "0xF92F", "comment": "X=X-1"},
{"address": "0xF930", "comment": "Y=Y-1"},
{"address": "0xF933", "comment": "return"},
{"address": "0xF934", "comment": "filing system flag 0=CFS 2=RFS"},
{"address": "0xF937", "comment": "if cassette F93C"},
{"address": "0xF939", "comment": "else Bad Command error message"},
{"address": "0xF93C", "comment": "switch Motor On"},
{"address": "0xF93F", "comment": "set up CFS for write operation"},
{"address": "0xF942", "comment": "check if free to print message"},
{"address": "0xF945", "comment": "if not exit else"},
{"address": "0xF947", "comment": "print message following call"},
{"address": "0xF95D", "comment": "confirm CFS not operating, nor ESCAPE flag set"},
{"address": "0xF960", "comment": "wait for keypress"},
{"address": "0xF963", "comment": "is it &0D (RETURN)"},
{"address": "0xF965", "comment": "no then do it again"},
{"address": "0xF967", "comment": "output Carriage RETURN and LINE FEED"},
{"address": "0xF96A", "comment": "current load address"},
{"address": "0xF96E", "comment": "current load address high word"},
{"address": "0xF972", "comment": "current load address high word"},
{"address": "0xF974", "comment": "return"},
{"address": "0xF975", "comment": "save A on stack"},
{"address": "0xF976", "comment": "print a space"},
{"address": "0xF979", "comment": "get back A"},
{"address": "0xF97A", "comment": "save A on stack"},
{"address": "0xF97B", "comment": "/16 to put high nybble in lo"},
{"address": "0xF97F", "comment": "print its ASCII equivalent"},
{"address": "0xF982", "comment": "get back A"},
{"address": "0xF983", "comment": "clear carry flag"},
{"address": "0xF984", "comment": "clear high nybble"},
{"address": "0xF986", "comment": "Add &30 to convert 0-9 to ASCII A-F to :"},
{"address": "0xF988", "comment": "if A< ASC(:)"},
{"address": "0xF98A", "comment": "goto F98E"},
{"address": "0xF98C", "comment": "else add 7 to convert :"},
{"address": "0xF98E", "comment": "print character and return"},
{"address": "0xF991", "comment": "A="},
{"address": "0xF993", "comment": "goto F98E to print it"},
{"address": "0xF995", "comment": "save flags on stack"},
{"address": "0xF996", "comment": "CFS Active flag"},
{"address": "0xF99A", "comment": "if ESCAPE condition"},
{"address": "0xF99C", "comment": "goto F9A0"},
{"address": "0xF99E", "comment": "get back flags"},
{"address": "0xF99F", "comment": "return"},
{"address": "0xF9A0", "comment": "close input file"},
{"address": "0xF9A3", "comment": "enable second processor and reset serial system"},
{"address": "0xF9A6", "comment": "A=&7E (126) Acknowledge ESCAPE"},
{"address": "0xF9A8", "comment": "OSBYTE Call"},
{"address": "0xF9B4", "comment": "A=Y"},
{"address": "0xF9B7", "comment": "print message following call"},
{"address": "0xF9C5", "comment": "current block flag"},
{"address": "0xF9C6", "comment": "X=&FF"},
{"address": "0xF9C8", "comment": "Checksum result"},
{"address": "0xF9CA", "comment": "if not 0 F9D9"},
{"address": "0xF9CC", "comment": "else check filename header block matches searched"},
{"address": "0xF9CF", "comment": "save flags on stack"},
{"address": "0xF9D0", "comment": "X=&FF"},
{"address": "0xF9D2", "comment": "Y=&99"},
{"address": "0xF9D4", "comment": "A=&FA this set Y/A to point to File? FA99"},
{"address": "0xF9D6", "comment": "get back flags"},
{"address": "0xF9D7", "comment": "report a query unexpected file name"},
{"address": "0xF9D9", "comment": "making Y/A point to Data FA8E for CRC error"},
{"address": "0xF9DB", "comment": "Checksum result"},
{"address": "0xF9DD", "comment": "if 0 F9E3"},
{"address": "0xF9DF", "comment": "A=&FA"},
{"address": "0xF9E1", "comment": "jump to F9F5"},
{"address": "0xF9E3", "comment": "block number"},
{"address": "0xF9E6", "comment": "current block no. lo"},
{"address": "0xF9E8", "comment": "if not eual F9F1"},
{"address": "0xF9EA", "comment": "block number hi"},
{"address": "0xF9ED", "comment": "current block no. hi"},
{"address": "0xF9EF", "comment": "if equal FA04"},
{"address": "0xF9F1", "comment": "Y=&A4"},
{"address": "0xF9F3", "comment": "A=&FA  point to Block? error unexpected block no."},
{"address": "0xF9F5", "comment": "save A on stack"},
{"address": "0xF9F6", "comment": "A=Y"},
{"address": "0xF9F7", "comment": "save Y on stack"},
{"address": "0xF9F8", "comment": "A=X"},
{"address": "0xF9F9", "comment": "save X on stack"},
{"address": "0xF9FA", "comment": "print CR if indicated by current block flag"},
{"address": "0xF9FD", "comment": "get back A"},
{"address": "0xF9FE", "comment": "X=A"},
{"address": "0xF9FF", "comment": "get back A"},
{"address": "0xFA00", "comment": "Y=A"},
{"address": "0xFA01", "comment": "get back A"},
{"address": "0xFA02", "comment": "jump to FA18"},
{"address": "0xFA04", "comment": "A=X"},
{"address": "0xFA05", "comment": "save A on stack"},
{"address": "0xFA06", "comment": "report"},
{"address": "0xFA09", "comment": "check loading progress, read another byte"},
{"address": "0xFA0C", "comment": "get back A"},
{"address": "0xFA0D", "comment": "X=A"},
{"address": "0xFA0E", "comment": "CRC workspace"},
{"address": "0xFA10", "comment": "CRC workspace"},
{"address": "0xFA14", "comment": "Y=&8E"},
{"address": "0xFA16", "comment": "A=&FA  FA8E points to Data?"},
{"address": "0xFA18", "comment": "current block flag"},
{"address": "0xFA1A", "comment": "save A on stack"},
{"address": "0xFA1B", "comment": "CFS Active flag"},
{"address": "0xFA1D", "comment": "if active FA2C"},
{"address": "0xFA1F", "comment": "A=X"},
{"address": "0xFA20", "comment": "filing system flag 0=CFS 2=RFS"},
{"address": "0xFA25", "comment": "A=X"},
{"address": "0xFA28", "comment": "current OPTions"},
{"address": "0xFA2A", "comment": "ignore errors"},
{"address": "0xFA2C", "comment": "get back A"},
{"address": "0xFA2D", "comment": "store A on &B9"},
{"address": "0xFA2F", "comment": "store Y on &B8"},
{"address": "0xFA31", "comment": "do *EXEC 0 to tidy up"},
{"address": "0xFA34", "comment": "halve CFS Active flag to clear bit 7"},
{"address": "0xFA36", "comment": "bell, reset ACIA & motor"},
{"address": "0xFA39", "comment": "display selected error report"},
{"address": "0xFA3C", "comment": "get back A"},
{"address": "0xFA3D", "comment": "Y=Y+1"},
{"address": "0xFA40", "comment": "clear carry flag"},
{"address": "0xFA41", "comment": "Add 1"},
{"address": "0xFA43", "comment": "save A on stack"},
{"address": "0xFA44", "comment": "A=Y"},
{"address": "0xFA45", "comment": "save Y on stack"},
{"address": "0xFA46", "comment": "check if free to print message"},
{"address": "0xFA49", "comment": "Y=A"},
{"address": "0xFA4A", "comment": "get back A"},
{"address": "0xFA4B", "comment": "&B8=8"},
{"address": "0xFA4D", "comment": "get back A"},
{"address": "0xFA4E", "comment": "&B9=A"},
{"address": "0xFA50", "comment": "A=Y"},
{"address": "0xFA51", "comment": "save flags on stack"},
{"address": "0xFA58", "comment": "Y=0"},
{"address": "0xFA5A", "comment": "get byte"},
{"address": "0xFA5C", "comment": "if 0 Fa68"},
{"address": "0xFA5E", "comment": "get back flags"},
{"address": "0xFA5F", "comment": "save flags on stack"},
{"address": "0xFA60", "comment": "if 0 FA52 to get next character"},
{"address": "0xFA62", "comment": "else print"},
{"address": "0xFA65", "comment": "and do it again"},
{"address": "0xFA68", "comment": "get back flags"},
{"address": "0xFA69", "comment": "increment pointers"},
{"address": "0xFA6F", "comment": "and print error message so no error condition"},
{"address": "0xFA72", "comment": "X=&FF inx will mean X=0"},
{"address": "0xFA74", "comment": "X=X+1"},
{"address": "0xFA75", "comment": "sought filename byte"},
{"address": "0xFA78", "comment": "if not 0 FA81"},
{"address": "0xFA7A", "comment": "else A=X"},
{"address": "0xFA7B", "comment": "if X=0 A=0 exit"},
{"address": "0xFA7D", "comment": "else A=filename byte"},
{"address": "0xFA80", "comment": "return"},
{"address": "0xFA81", "comment": "set carry if byte in A is not upper case Alpha"},
{"address": "0xFA84", "comment": "compare with filename"},
{"address": "0xFA87", "comment": "if carry set FA8B"},
{"address": "0xFA89", "comment": "else convert to upper case"},
{"address": "0xFA8B", "comment": "and if A=0 filename characters match so do it again"},
{"address": "0xFA8D", "comment": "return"},
{"address": "0xFAAE", "comment": "current block flag"},
{"address": "0xFAB0", "comment": "if 0 FAD3 else"},
{"address": "0xFAB2", "comment": "A=X"},
{"address": "0xFAB3", "comment": "If X=0 FAD3"},
{"address": "0xFAB5", "comment": "A=&22"},
{"address": "0xFAB7", "comment": "current OPTions checking bits 1 and 5"},
{"address": "0xFAB9", "comment": "if neither set no  retry so FAD3 else"},
{"address": "0xFABB", "comment": "reset ACIA"},
{"address": "0xFABE", "comment": "Y=A"},
{"address": "0xFABF", "comment": "print following message"},
{"address": "0xFAD2", "comment": "return"},
{"address": "0xFAD3", "comment": "print CR if CFS not operational"},
{"address": "0xFAD6", "comment": "filename length/progress flag"},
{"address": "0xFAD8", "comment": "if 0 return else"},
{"address": "0xFADA", "comment": "confirm ESC not set and CFS not executing"},
{"address": "0xFADD", "comment": "filing system flag 0=CFS 2=RFS"},
{"address": "0xFAE0", "comment": "if CFS FAD6"},
{"address": "0xFAE2", "comment": "else set up ACIA etc"},
{"address": "0xFAE5", "comment": "and loop back again"},
{"address": "0xFAE8", "comment": "check if free to print message"},
{"address": "0xFAEB", "comment": "enable second processor and reset serial system"},
{"address": "0xFAED", "comment": "beep"},
{"address": "0xFAF4", "comment": "enable 2nd proc. if present and set up osfile block"},
{"address": "0xFAF9", "comment": "switch on motor"},
{"address": "0xFAFC", "comment": "save flags on stack"},
{"address": "0xFAFD", "comment": "prevent IRQ interrupts"},
{"address": "0xFAFE", "comment": "get serial ULA control register setting"},
{"address": "0xFB01", "comment": "write to serial ULA control register setting"},
{"address": "0xFB04", "comment": "A=0"},
{"address": "0xFB06", "comment": "store A RS423 timeout counter"},
{"address": "0xFB08", "comment": "jump FB0B"},
{"address": "0xFB0A", "comment": "save flags on stacksave flags"},
{"address": "0xFB0B", "comment": "release ACIA (by &FE08=3)"},
{"address": "0xFB0E", "comment": "get last setting of ACIA"},
{"address": "0xFB11", "comment": "set ACIA and &250 from A before exit"},
{"address": "0xFB14", "comment": "get back flags"},
{"address": "0xFB15", "comment": "if bit 7of ESCAPE flag not set"},
{"address": "0xFB17", "comment": "then FB31"},
{"address": "0xFB19", "comment": "else return as unserviced ESCAPE is pending"},
{"address": "0xFB1A", "comment": "get cassette filing system options byte"},
{"address": "0xFB1C", "comment": "move low nybble into high nybble"},
{"address": "0xFB20", "comment": "current OPTions save into &BB"},
{"address": "0xFB22", "comment": "get sequential block gap"},
{"address": "0xFB25", "comment": "goto to &FB2F"},
{"address": "0xFB27", "comment": "get cassette filing system options byte"},
{"address": "0xFB29", "comment": "clear low nybble"},
{"address": "0xFB2B", "comment": "as current OPTions"},
{"address": "0xFB2D", "comment": "set current interblock gap"},
{"address": "0xFB2F", "comment": "to 6"},
{"address": "0xFB31", "comment": "allow interrupts"},
{"address": "0xFB32", "comment": "save flags on stack"},
{"address": "0xFB33", "comment": "prevent interrupts"},
{"address": "0xFB34", "comment": "check if RS423 is busy"},
{"address": "0xFB37", "comment": "if not FB14"},
{"address": "0xFB39", "comment": "see if RS423 has timed out"},
{"address": "0xFB3B", "comment": "if not FB14"},
{"address": "0xFB3D", "comment": "else load RS423 timeout counter with"},
{"address": "0xFB3F", "comment": "1 to indicate that cassette has 6850"},
{"address": "0xFB41", "comment": "reset ACIA with &FE80=3"},
{"address": "0xFB44", "comment": "get back flags"},
{"address": "0xFB45", "comment": "return"},
{"address": "0xFB46", "comment": "A=3"},
{"address": "0xFB48", "comment": "and exit after resetting ACIA"},
{"address": "0xFB4A", "comment": "set current ACIA control register"},
{"address": "0xFB4C", "comment": "to &30"},
{"address": "0xFB4E", "comment": "and goto FB63"},
{"address": "0xFB50", "comment": "set &FE10 to 5"},
{"address": "0xFB52", "comment": "setting a transmit baud rate of 300,motor off"},
{"address": "0xFB57", "comment": "delay loop"},
{"address": "0xFB5A", "comment": "&CA=0"},
{"address": "0xFB5C", "comment": "Turn motor on and keep baud rate at 300 recieve"},
{"address": "0xFB5E", "comment": "19200 transmit"},
{"address": "0xFB61", "comment": "A=&D0"},
{"address": "0xFB65", "comment": "set up ACIA control register"},
{"address": "0xFB68", "comment": "returnand return"},
{"address": "0xFB69", "comment": "block number"},
{"address": "0xFB6C", "comment": "block number hi"},
{"address": "0xFB6F", "comment": "X=X+1"},
{"address": "0xFB70", "comment": "current block no. lo"},
{"address": "0xFB74", "comment": "Y=Y+1"},
{"address": "0xFB75", "comment": "current block no. hi"},
{"address": "0xFB77", "comment": "return"},
{"address": "0xFB7A", "comment": "filing system buffer flag"},
{"address": "0xFB7C", "comment": "CRC workspace"},
{"address": "0xFB7E", "comment": "CRC workspace"},
{"address": "0xFB80", "comment": "return"},
{"address": "0xFB81", "comment": "Y=&FF"},
{"address": "0xFB83", "comment": "Y=Y+1"},
{"address": "0xFB84", "comment": "X=X+1"},
{"address": "0xFB88", "comment": "sought filename"},
{"address": "0xFB8B", "comment": "until end of filename (0)"},
{"address": "0xFB8D", "comment": "return"},
{"address": "0xFB8E", "comment": "Y=0"},
{"address": "0xFB90", "comment": "allow   IRQ interrupts"},
{"address": "0xFB91", "comment": "X=1"},
{"address": "0xFB93", "comment": "store Y as current file handle"},
{"address": "0xFB95", "comment": "do osbyte 137"},
{"address": "0xFB97", "comment": "get back file handle (preserved thru osbyte)"},
{"address": "0xFB99", "comment": "turn on motor"},
{"address": "0xFB9C", "comment": "file status or temporary store"},
{"address": "0xFB9E", "comment": "A=Y"},
{"address": "0xFB9F", "comment": "filing system flag 0=CFS 2=RFS"},
{"address": "0xFBA2", "comment": "Y=A"},
{"address": "0xFBA3", "comment": "CFS status byte"},
{"address": "0xFBA5", "comment": "file status or temporary store"},
{"address": "0xFBA7", "comment": "A=A/2"},
{"address": "0xFBA8", "comment": "Y=Y-1"},
{"address": "0xFBAB", "comment": "A=A/2"},
{"address": "0xFBAC", "comment": "Y=Y-1"},
{"address": "0xFBBB", "comment": "A=1"},
{"address": "0xFBBD", "comment": "check if second processor file test tube prescence"},
{"address": "0xFBC0", "comment": "if not exit"},
{"address": "0xFBC2", "comment": "A=X"},
{"address": "0xFBC3", "comment": "current load address"},
{"address": "0xFBC5", "comment": "Y=00"},
{"address": "0xFBC7", "comment": "save A on stack"},
{"address": "0xFBC8", "comment": "filing system buffer flag"},
{"address": "0xFBCA", "comment": "and out to TUBE"},
{"address": "0xFBCF", "comment": "get back A"},
{"address": "0xFBD3", "comment": "X=A"},
{"address": "0xFBD4", "comment": "current load address high word"},
{"address": "0xFBD6", "comment": "current load address high word"},
{"address": "0xFBDA", "comment": "if &FF then its for base processor"},
{"address": "0xFBDC", "comment": "&FF if tube present"},
{"address": "0xFBDF", "comment": "to set bit 7 alone"},
{"address": "0xFBE1", "comment": "return"},
{"address": "0xFBE2", "comment": "A=&85"},
{"address": "0xFBE4", "comment": "write to serial ULA control register setting"},
{"address": "0xFBE7", "comment": "reset ACIA"},
{"address": "0xFBEA", "comment": "A=16"},
{"address": "0xFBEC", "comment": "set ACIA to CFS baud rate"},
{"address": "0xFBEF", "comment": "confirm ESC not set and CFS not executing"},
{"address": "0xFBF2", "comment": "read ACIA status register"},
{"address": "0xFBF5", "comment": "clear all but bit 1"},
{"address": "0xFBF7", "comment": "if clear FBEF"},
{"address": "0xFBF9", "comment": "else A=&AA"},
{"address": "0xFBFB", "comment": "transmit data register"},
{"address": "0xFBFE", "comment": "return"},
{"address": "0xFC00", "comment": "test hardware"},
{"address": "0xFCFF", "comment": "paging register for JIM expansion memory"},
{"address": "0xFDFE", "comment": "Ecosoak Vector"},
{"address": "0xFE00", "comment": "6845 CRTC      address register"},
{"address": "0xFE01", "comment": "6845 CRTC      data register"},
{"address": "0xFE02", "comment": "Border colour  border colour"},
{"address": "0xFE08", "comment": "6850 ACIA      control register        status register"},
{"address": "0xFE09", "comment": "6850 ACIA      transmit data           recieve data"},
{"address": "0xFE10", "comment": "SERIAL ULA     control register"},
{"address": "0xFE18", "comment": "68B54 ADLC     Disable interrupts      Econet station ID"},
{"address": "0xFE20", "comment": "Video ULA      control register"},
{"address": "0xFE21", "comment": "Video ULA      palette register        palette register"},
{"address": "0xFE30", "comment": "ROM latch      paged ROM ID            write only"},
{"address": "0xFE31", "comment": "ALTAIR         RAM protect"},
{"address": "0xFE34", "comment": "Shadow RAM     B+ only         note different OS"},
{"address": "0xFE40", "comment": "MOS 6522 VIA Output Register B                 Input Register B"},
{"address": "0xFE41", "comment": "MOS 6522 VIA Output Register A                 Input Register A"},
{"address": "0xFE42", "comment": "MOS 6522 VIA data direction register B"},
{"address": "0xFE43", "comment": "MOS 6522 VIA data direction register A"},
{"address": "0xFE44", "comment": "MOS 6522 VIA T1C-L  latches                    T1 low Order counter"},
{"address": "0xFE45", "comment": "MOS 6522 VIA T1C-H  counter"},
{"address": "0xFE46", "comment": "MOS 6522 VIA T1L-L low order latches"},
{"address": "0xFE47", "comment": "MOS 6522 VIA T1L-H high order latches"},
{"address": "0xFE48", "comment": "MOS 6522 VIA T2C-L latches                     T2C-L lo order counter"},
{"address": "0xFE49", "comment": "MOS 6522 VIA T2C-H T2 high order counter"},
{"address": "0xFE4A", "comment": "MOS 6522 VIA shift register"},
{"address": "0xFE4B", "comment": "MOS 6522 VIA auxilliary control register ACR"},
{"address": "0xFE4C", "comment": "MOS 6522 VIA Peripheral control register PCR"},
{"address": "0xFE4D", "comment": "MOS 6522 VIA Interrupt  flag    register IFR"},
{"address": "0xFE4E", "comment": "MOS 6522 VIA Interrupt enable   register IER"},
{"address": "0xFE4F", "comment": "MOS 6522 VIA ORB/IRB but no handshake"},
{"address": "0xFE60", "comment": "USER 6522 VIA Output Register B                Input Register B"},
{"address": "0xFE61", "comment": "USER 6522 VIA Output Register A                Input Register A"},
{"address": "0xFE62", "comment": "USER 6522 VIA data direction register B"},
{"address": "0xFE63", "comment": "USER 6522 VIA data direction register A"},
{"address": "0xFE64", "comment": "USER 6522 VIA T1C-L  latches                   T1 low Order counter"},
{"address": "0xFE65", "comment": "USER 6522 VIA T1C-H  counter"},
{"address": "0xFE66", "comment": "USER 6522 VIA T1L-L low order latches"},
{"address": "0xFE67", "comment": "USER 6522 VIA T1L-H high order latches"},
{"address": "0xFE68", "comment": "USER 6522 VIA T2C-L latches                    T2C-L lo order counter"},
{"address": "0xFE69", "comment": "USER 6522 VIA T2C-H T2 high order counter"},
{"address": "0xFE6A", "comment": "USER 6522 VIA shift register"},
{"address": "0xFE6B", "comment": "USER 6522 VIA auxilliary control register ACR"},
{"address": "0xFE6C", "comment": "USER 6522 VIA Peripheral control register PCR"},
{"address": "0xFE6D", "comment": "USER 6522 VIA Interrupt  flag    register IFR"},
{"address": "0xFE6E", "comment": "USER 6522 VIA Interrupt enable   register IER"},
{"address": "0xFE6F", "comment": "USER 6522 VIA ORB/IRB but no handshake"},
{"address": "0xFE80", "comment": "8271 FDC       command register                status register"},
{"address": "0xFE81", "comment": "8271 FDC       parameter register              result register"},
{"address": "0xFE82", "comment": "8271 FDC       reset register"},
{"address": "0xFE83", "comment": "8271 FDC       illegal                         illegal"},
{"address": "0xFE84", "comment": "8271 FDC       data                            data"},
{"address": "0xFEA0", "comment": "68B54 ADLC     control register 1              status register 1"},
{"address": "0xFEA1", "comment": "68B54 ADLC     control register 2/3            status register 2/3"},
{"address": "0xFEA2", "comment": "68B54 ADLC     Tx FIFO (frame continue)        Rx      FIFO"},
{"address": "0xFEA3", "comment": "68B54 ADLC     Tx FIFO (frame terminate)       Rx      FIFO"},
{"address": "0xFEC0", "comment": "7002 ADC       data latch A/D start            status"},
{"address": "0xFEC1", "comment": "7002 ADC       hi data byte"},
{"address": "0xFEC2", "comment": "7002 ADC       lo data byte"},
{"address": "0xFEE0", "comment": "TUBE FIFO1     status register"},
{"address": "0xFEE1", "comment": "TUBE FIFO1"},
{"address": "0xFEE2", "comment": "TUBE FIFO2     status register"},
{"address": "0xFEE3", "comment": "TUBE FIFO2"},
{"address": "0xFEE4", "comment": "TUBE FIFO3     status register"},
{"address": "0xFEE5", "comment": "TUBE FIFO3"},
{"address": "0xFEE6", "comment": "TUBE FIFO4     status register"},
{"address": "0xFEE7", "comment": "TUBE FIFO4"},
{"address": "0xFF00", "comment": "XUSERV"},
{"address": "0xFF03", "comment": "XBRKV"},
{"address": "0xFF06", "comment": "XIRQ1V"},
{"address": "0xFF09", "comment": "XIRQ2V"},
{"address": "0xFF0C", "comment": "XCLIV"},
{"address": "0xFF0F", "comment": "XBYTEV"},
{"address": "0xFF12", "comment": "XWORDV"},
{"address": "0xFF15", "comment": "XWRCHV"},
{"address": "0xFF18", "comment": "XRDCHV"},
{"address": "0xFF1B", "comment": "XFILEV"},
{"address": "0xFF1E", "comment": "XARGSV"},
{"address": "0xFF21", "comment": "XBGETV"},
{"address": "0xFF24", "comment": "XBPUTV"},
{"address": "0xFF27", "comment": "XGBPBV"},
{"address": "0xFF51", "comment": "save A on stack"},
{"address": "0xFF52", "comment": "save A on stack"},
{"address": "0xFF53", "comment": "save A on stack"},
{"address": "0xFF54", "comment": "save A on stack"},
{"address": "0xFF55", "comment": "save A on stack"},
{"address": "0xFF56", "comment": "save flags on stack"},
{"address": "0xFF57", "comment": "save A on stack"},
{"address": "0xFF58", "comment": "A=X"},
{"address": "0xFF59", "comment": "save X on stack"},
{"address": "0xFF5A", "comment": "A=Y"},
{"address": "0xFF5B", "comment": "save Y on stack"},
{"address": "0xFF5C", "comment": "get stack pointer into X (&F2 or less)"},
{"address": "0xFF5D", "comment": "A=&FF"},
{"address": "0xFF5F", "comment": "A"},
{"address": "0xFF67", "comment": "this is VECTOR number*3+2!!"},
{"address": "0xFF6A", "comment": "lo byte of action address"},
{"address": "0xFF6D", "comment": "store it on stack"},
{"address": "0xFF70", "comment": "get hi byte"},
{"address": "0xFF73", "comment": "store it on stack"},
{"address": "0xFF78", "comment": "store original ROM number below this"},
{"address": "0xFF7B", "comment": "get new ROM number"},
{"address": "0xFF7E", "comment": "store it as ram copy"},
{"address": "0xFF80", "comment": "and switch to that ROM"},
{"address": "0xFF83", "comment": "get back A"},
{"address": "0xFF84", "comment": "Y=A"},
{"address": "0xFF85", "comment": "get back A"},
{"address": "0xFF86", "comment": "X=A"},
{"address": "0xFF87", "comment": "get back A"},
{"address": "0xFF88", "comment": "get back flags and jump to ROM vectored entry"},
{"address": "0xFF89", "comment": "save flags on stack"},
{"address": "0xFF8A", "comment": "save A on stack"},
{"address": "0xFF8B", "comment": "A=X"},
{"address": "0xFF8C", "comment": "save X on stack"},
{"address": "0xFF8D", "comment": "(&F7 or less)"},
{"address": "0xFF8E", "comment": "STORE A AND P OVER"},
{"address": "0xFF91", "comment": "return address from (JSR &FF51)"},
{"address": "0xFF94", "comment": "hiding garbage by duplicating A and X just saved"},
{"address": "0xFF9A", "comment": "get back X"},
{"address": "0xFF9B", "comment": "X=A"},
{"address": "0xFF9C", "comment": "get back A lose next two bytes"},
{"address": "0xFF9D", "comment": "get back A lose"},
{"address": "0xFF9E", "comment": "get back A ROM number"},
{"address": "0xFF9F", "comment": "store it"},
{"address": "0xFFA1", "comment": "and set it"},
{"address": "0xFFA4", "comment": "get back A"},
{"address": "0xFFA5", "comment": "get back flags"},
{"address": "0xFFA6", "comment": "return and exit pulling original return address"},
{"address": "0xFFA7", "comment": "A=X"},
{"address": "0xFFA8", "comment": "carry always set, jump to BPUT"},
{"address": "0xFFAA", "comment": "read a byte from FRED area"},
{"address": "0xFFAD", "comment": "return"},
{"address": "0xFFAE", "comment": "read a byte from JIM area"},
{"address": "0xFFB1", "comment": "return"},
{"address": "0xFFB2", "comment": "read a byte from SHEILA memory mapped I/O area"},
{"address": "0xFFB5", "comment": "return"},
{"address": "0xFFB9", "comment": "OSRDRM get a byte from sideways ROM"},
{"address": "0xFFBC", "comment": "VDUCHR VDU character output"},
{"address": "0xFFBF", "comment": "OSEVEN generate an EVENT"},
{"address": "0xFFC2", "comment": "GSINIT initialise OS string"},
{"address": "0xFFC5", "comment": "GSREAD read character from input stream"},
{"address": "0xFFC8", "comment": "NVRDCH non vectored OSRDCH"},
{"address": "0xFFCB", "comment": "NVWRCH non vectored OSWRCH"},
{"address": "0xFFCE", "comment": "OSFIND open or close a file"},
{"address": "0xFFD1", "comment": "OSGBPB transfer block to or from a file"},
{"address": "0xFFD4", "comment": "OSBPUT save a byte to file"},
{"address": "0xFFD7", "comment": "OSBGET get a byte from file"},
{"address": "0xFFDA", "comment": "OSARGS read or write file arguments"},
{"address": "0xFFDD", "comment": "OSFILE read or write a file"},
{"address": "0xFFE0", "comment": "OSRDCH get a byte from current input stream"},
{"address": "0xFFE3", "comment": "OSASCI output a byte to VDU stream expanding"},
{"address": "0xFFE5", "comment": "carriage returns (&0D) to LF/CR (&0A,&0D)"},
{"address": "0xFFE7", "comment": "OSNEWL output a CR/LF to VDU stream"},
{"address": "0xFFE9", "comment": "Outputs A followed by CR to VDU stream"},
{"address": "0xFFEC", "comment": "OSWRCR output a CR to VDU stream"},
{"address": "0xFFEE", "comment": "OSWRCH output a character to the VDU stream"},
{"address": "0xFFF1", "comment": "OSWORD perform operation using parameter table"},
{"address": "0xFFF4", "comment": "OSBYTE perform operation with single bytes"},
{"address": "0xFFF7", "comment": "OSCLI  pass string to command line interpreter"}
]